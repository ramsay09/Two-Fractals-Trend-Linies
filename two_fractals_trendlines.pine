//@version=5

indicator('Market Context & Confluence Suite', overlay=true, shorttitle='MCCS', max_bars_back=4000, max_lines_count=500, max_boxes_count=500, dynamic_requests=true)

general_info   = input.bool(title='General Description', defval=false, tooltip='Use the signals in confluence and as an indication of market tension, which will discharged in higher volatility or trend continuation. ... context matters.
                 Always keep in mind: the most direct indicator is the chart itself. Choose these tools wisely.')

// Constants for Panel & Weights (Centralized)
int PANEL_ROWS = 15
int PANEL_COLS = 3

// Confluence Weights
int W_FR    = 4
int W_FVG   = 4
int W_KAMA  = 1
int W_CLOUD = 1
int W_SLOPE = 1
int W_TL    = 1
int W_SEG   = 1
int W_MA    = 1
int W_L12   = 1
int W_DIV   = 1
int W_PAT   = 1
int W_VOL   = 1
int W_BB    = 1
int W_O     = 1


// --- TOP LEVEL UI ---
auto_tuning     = input.string("Balanced", "CONF/REG Auto Tuning", options=["Conservative", "Balanced", "Aggressive"], tooltip="Auto uses tuned parameters for CONF/REG. \nSensitivity of Auto Mode.\nConservative: Slower, safer.\nBalanced: Standard.\nAggressive: Faster, more signals.")

trading_approach = input.string("Custom", "Context Lenses", options=["Custom", "Session Map", "ORB", "Mean Reversion", "Breakout", "Squeeze Breakout", "Trend Continuation"], tooltip="Applies focused defaults for a trading lens. Custom = fully manual. \nâ€¢ Custom: Full manual control.\nâ€¢ Session Map: Structure, Key Levels, ADR.\nâ€¢ ORB: Opening Range, RVOL.\nâ€¢ Mean Reversion: VWAP, Bands, Divergences.\nâ€¢ Breakout/Squeeze: RVOL, Structure, Momentum.\nâ€¢ Trend Continuation: CONF/REG, FVG.")

// adx, hma and ema1 x ema2 mtf trend info panel
panel_pos      = input.string(title='MTF Info Panel', defval='None', options=['None', 'Top Right', 'Bottom Right', 'Bottom Left'],
                 tooltip='Provides an overview of multi time frame trends: FVG Close state, and Fractal Break state. Displays for 5m, 15m, 1H, 4H, 1D, 1W, 1M. Select position to enable.\nâ—‹ = developing (current candle not closed), â— = confirmed (closed).')
panel_update_mode = input.string("Realtime Preview", "Panel Update Mode", options=["Realtime Preview", "Strict Confirm"], tooltip="Realtime Preview: shows live/developing values (â—‹). Strict Confirm: shows last confirmed close values only (â—).")
bool panel_show_live = panel_update_mode == "Realtime Preview"

// Confluence & Regime Visuals
show_conf_meter     = input.bool(true, "Confluence Meterâ €â €â €", inline="conf_ui", tooltip="")
show_conf_bg        = input.bool(false, "Confluence Meter BG", inline="conf_ui", tooltip="CONF (Trend Bias) shows the current dominant trend direction as a compact 0â€“100 score.
                     \nâ€¢ BULL / BEAR / NEUT = direction
                     \nâ€¢ Number = bias strength (50 = neutral)
                     \nâ€¢ H / M / L = quality / reliability (high / medium / low)
                     How CONF is built:
                     \nâ€¢ Core bias comes from structural trend components (mainly FVG state + fractal/structure + a trend filter).
                     \n  The first FVG sets the bias and it stays valid until an opposite FVG appears.
                     \nâ€¢ Trendlines & Segments act only as short-lived confirmation (with decay) and cannot flip the bias on their own.
                     \nâ€¢ REG (SQUEEZE/TREND/RANGE) gates reliability: in SQUEEZE, CONF is intentionally dampened (FVG is not counted at full weight).
                     Visuals:
                     \nâ€¢ Green/Red = Bull/Bear bias
                     \nâ€¢ NEUT is fully transparent (panel + chart background).
                     \n\nPlots the Confluence Signal background color.")

conf_use_vwap_quality = input.bool(true, "CONF: VWAP Quality Gate", tooltip="Adjusts CONF quality using VWAP alignment + stretch (anti-chase). State remains unchanged.")
conf_vwap_mode        = input.string("Auto", "VWAP Anchor", inline="conf", options=["Auto","Session VWAP","Weekly VWAP"], tooltip="")
conf_z_penalty_mode   = input.string("Default", "â €Stretch Penalty", inline="conf", options=["Default","Conservative","Aggressive"], tooltip="Which VWAP anchor CONF uses for quality. Auto: Session â‰¤ 60m, Weekly > 60m. n\How strongly VWAP stretch reduces CONF quality.")

show_regime_panel   = input.bool(true, "Squeeze/Trend", inline="REGIME_UI", tooltip="Market Regime Detection (Squeeze/Trend/Range). \nâ€¢ Panel: Displays state in Info Table. \nâ€¢ BG: Colors chart background (Gold=Squeeze, Blue=Trend). \n\nPanel Codes: \nâ€¢ RVOL: L(<Low), M(Low-Med), H(Med-High), E(>High) \nâ€¢ VWAP Z: N(Normal), S(Stretch), T(TP), E(Extreme)\nâ—‹ = developing (current candle not closed), â— = confirmed (closed).")
regime_bg_mode      = input.string("None", "â €â €â €â €â €Squeeze/Trend BG", options=["None", "Squeeze BG", "Trend BG", "Both"], inline="REGIME_UI")

string M_FORM = "â—‹"
string M_CONF = "â—"
color MARKER_COLOR = color.new(color.white, 50)

f_marker(bool show_live, bool is_confirmed) =>
    show_live and not is_confirmed ? M_FORM : M_CONF

// --- STAGE 2: CONFIGURATION & AUTO-SCALING ---

// 1. Timeframe Classification
int tf_sec = timeframe.in_seconds(timeframe.period)

bool is_fast       = tf_sec <= 900 // <= 15m
bool is_med        = tf_sec > 900 and tf_sec <= 14400 // > 15m and <= 4h
bool is_slow       = tf_sec > 14400 and tf_sec < 86400 // > 4h and < 1D
bool is_daily      = tf_sec >= 86400 and tf_sec < 604800 // >= 1D and < 1W
bool is_weekly_plus= tf_sec >= 604800 // >= 1W

// 2. Define Effective Variables (Init)
// CONF
int eff_core_ema_len = 13
int eff_vol_len      = 80
float eff_enter_k    = 1.0
float eff_exit_k     = 0.5
int eff_persist_bars = 3
float eff_ov_decay   = 0.70
float eff_ov_clamp   = 0.15

// REG
int eff_adx_len      = 14
int eff_adx_th       = 20
int eff_bb_len       = 20
float eff_bb_mult    = 2.0
int eff_kc_len       = 20
float eff_kc_mult    = 1.5
bool eff_squeeze_strict = true
bool eff_use_kc_squeeze = true

// ADR/ATR
bool eff_use_adr_gate = true
int eff_adr_len      = 20
float eff_adr_warn   = 85.0
float eff_adr_hard   = 110.0
int eff_atr_len      = 14
int eff_atr_norm     = 50
float eff_atr_low    = 0.90
float eff_atr_high   = 1.10

// 3. PARAMETER RESOLVER

// --- AUTO MODE LOGIC (Full Auto Trader Edition) ---

// Base Values (Balanced)
int a_core_len  = 13
int a_persist   = 3
int a_vol_len   = 80
float a_enter_k = 1.0
float a_exit_k  = 0.5
float a_decay   = 0.70
float a_clamp   = 0.15
int a_adx_th    = 20

// Timeframe Scaling Defaults
if is_fast
    a_core_len := 8
    a_persist  := 3
    a_vol_len  := 50
else if is_med
    a_core_len := 13
    a_persist  := 3
    a_vol_len  := 80
else if is_slow
    a_core_len := 21
    a_persist  := 2
    a_vol_len  := 120
else if is_daily
    a_core_len := 21
    a_persist  := 2
    a_vol_len  := 150
else // Weekly+
    a_core_len := 34
    a_persist  := 2
    a_vol_len  := 200

// Auto Tuning Logic
if auto_tuning == "Conservative"
    a_enter_k := 1.25
    a_exit_k  := 0.65
    a_decay   := 0.60
    a_clamp   := 0.12
    a_adx_th  := 22

    // Scale up for robustness
    a_core_len := math.round(a_core_len * 1.4)
    a_vol_len  := math.round(a_vol_len * 1.4)
    a_persist  := math.min(a_persist + 2, 6)

    // ADR Gate: Soft (Enabled)
    eff_use_adr_gate := true
    eff_adr_warn := 85.0
    eff_adr_hard := 110.0

else if auto_tuning == "Aggressive"
    a_enter_k := 0.80
    a_exit_k  := 0.45
    a_decay   := 0.75
    a_clamp   := 0.18
    a_adx_th  := 18

    // Scale down for speed
    a_core_len := math.max(math.round(a_core_len * 0.75), 5)
    a_vol_len  := math.max(math.round(a_vol_len * 0.75), 30)
    a_persist  := math.max(a_persist - 1, 2) // Prompt says max(base-1, 2). Assuming I take current persisted value which is base.

    // ADR Gate: Off on Daily+, Soft otherwise
    eff_use_adr_gate := (is_daily or is_weekly_plus) ? false : true
    eff_adr_warn := 85.0
    eff_adr_hard := 110.0

else
    // Balanced
    // No multipliers on TF base values
    a_enter_k := 1.00
    a_exit_k  := 0.50
    a_decay   := 0.70
    a_clamp   := 0.15
    a_adx_th  := 20

    // ADR Gate: Soft (Enabled)
    eff_use_adr_gate := true
    eff_adr_warn := 85.0
    eff_adr_hard := 110.0

// Assignment
eff_core_ema_len := int(a_core_len)
eff_vol_len      := int(a_vol_len)
eff_enter_k      := a_enter_k
eff_exit_k       := a_exit_k
eff_persist_bars := int(a_persist)
eff_ov_decay     := a_decay
eff_ov_clamp     := a_clamp
eff_adx_th       := a_adx_th

// Fixed REG Settings
eff_bb_len         := 20
eff_bb_mult        := 2.0
eff_kc_len         := 20
eff_kc_mult        := 1.5
eff_squeeze_strict := true
eff_use_kc_squeeze := true

// fractals input
fractals_plot   = input.bool(title='Bill Williams Fractalsâ €', inline="fr_s", defval=true, tooltip='')
sub_fractals    = input.bool(title='Sub Fractals', inline="fr_s", defval=false, tooltip='Bill Williams Fractals (five Candles): white triangle. Works as support and resistance level.
                 \nSub Bill Williams Fractals (four Candles): Lightgray triangle. Works as support and resistance level. These are B. W. Fractals on a Lower Timeframe.')

// Gradient Volume Profile
vp_enable = input.bool(false, "Volume Profile â €â €â €â €â €", inline="line4")
vp_mode = input.string("Full TF", "VP Mode", options = ["Visible Range", "Full TF"], inline="vp_line", tooltip = "Visible: computes only the visible chart range.\nFull TF: computes over all loaded bars in the current TF (complete).")
vp_style = input.string("Gradient", "", options = ["Gradient", "Bars"], inline="vp_line", tooltip="How Volume Profile is rendered.")
vp_smart = input.bool(false, "Contrast Factor", inline="line4", tooltip="")
vp_clip  = input.float(2.5, "", minval=1.0, step=0.1, inline="line4", tooltip="Visualizes trading volume distribution by price level.\nSmart Contrast adjusts saturation when peaks dominate.\n")


// Performance Pass v3: VP Inputs (Simplified)
// Fixed, stable parameters for visible range scanning
int vp_rows     = 120
int vp_smooth   = 3
int VP_BOX_BUDGET = 220

// Basic Visuals
vp_width    = 12
vp_offset   = 15
int vp_pivot_offset = 10
int vp_bars_shift = 15
int vp_bars_w = 19

// MTF CANDLE OVERLAY INPUTS
grp_mtf_candle    = "MTF Candle Overlay"
show_mtf_candles  = input.bool(false, "MTF Candle Overlay â €â €â €â €â €", group=grp_mtf_candle, inline="mtf_ov", tooltip="Two timelines at one glance. It's like looking inside a candle with X-rays.")
mtf_tf_sel        = input.string("1h", "", options=["5m", "15m", "30m", "1h", "2h", "4h", "6h", "12h", "1d", "1w", "1M", "3M"], inline="mtf_ov", group=grp_mtf_candle)
mtf_opacity       = input.int(15, "Opacity %", minval=0, maxval=100, group=grp_mtf_candle, tooltip="0% = Invisible, 100% = Solid")

// Additional Context Inputs
grp_add         = "Additional Context"
use_sess_1st    = input.bool(false, "1st Session Candle â €â €â €â €â €", group=grp_add, inline="sess_1st", tooltip="")
sess_1st_tf     = input.timeframe("5", "", group=grp_add, inline="sess_1st", tooltip="Lines remain at the high and low of the first candle of the running trading session. \nSelect the timeframe for the 1st Session Candle calculation.")

show_last_frac  = input.bool(false, "Last Fractal S/R â €â €â €â €â €â €â €", group=grp_add, inline="l_rf", tooltip="")
last_frac_tf    = input.timeframe("240", "", group=grp_add, inline="l_rf", tooltip="Draws lines at the last confirmed Up/Down Fractals. Every new trend begins with the breaking of a fractal. (Time Frame dependent). \nSelect the timeframe for the Last Fractal calculation.")

show_vol        = input.bool(true, "High Volume Spikes", group=grp_add, inline="vol_sp", tooltip="A small 'V' indicates whether institutions are active (e.g., double the average volume). High volume is often observed at local highs and lows.")
vol_mult        = input.float(2.0, "Threshold (x Avg)", inline="vol_sp", group=grp_add)

// FVG Inputs
grp_fvg1        = "Price Imbalance (Fair Value Gap) 1"
plot_fvg1       = input.bool(true, title="FVG 1 â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €", group=grp_fvg1, inline="f1_1", tooltip="")
fvg1_tf_sel     = input.timeframe("", title="TF", group=grp_fvg1, inline="f1_1", tooltip="Indicates a potential pullback area after an strong price movement (Displacement). Also reveals institutional interest (new trend). \nSelect the timeframe for Price Imbalance detection. Chart = Current Chart Timeframe.")
fvg1_len        = input.int(1, title="Box Length", minval=1, group=grp_fvg1, inline="f1_2")
fvg1_limit      = input.int(50, title="â €â € Visible Boxes", minval=1, maxval=500, group=grp_fvg1, inline="f1_2")
col_fvg1_bull   = input.color(color.new(color.green, 80), title="Bullish Color", group=grp_fvg1, inline="f1_3")
col_fvg1_bear   = input.color(color.new(color.red, 80), title="â €â €â €â €â €â €â €â € Bearish Color", group=grp_fvg1, inline="f1_3")

grp_fvg2        = "Price Imbalance (Fair Value Gap) 2"
plot_fvg2       = input.bool(false, title="FVG 2 â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €", group=grp_fvg2, inline="f2_1", tooltip="")
fvg2_tf_sel     = input.timeframe("", title="TF", group=grp_fvg2, inline="f2_1", tooltip="Indicates a potential pullback area after an strong price movement (Displacement). Also reveals institutional interest (new trend). \nSelect the timeframe for Price Imbalance detection. Chart = Current Chart Timeframe.")
fvg2_len        = input.int(1, title="Box Length", minval=1, group=grp_fvg2, inline="f2_2")
fvg2_limit      = input.int(5, title="â €â € Visible Boxes", minval=1, maxval=500, group=grp_fvg2, inline="f2_2")
col_fvg2_bull   = input.color(color.new(color.green, 80), title="Bullish Color", group=grp_fvg2, inline="f2_3")
col_fvg2_bear   = input.color(color.new(color.red, 80), title="â €â €â €â €â €â €â €â € Bearish Color", group=grp_fvg2, inline="f2_3")

// Key Levels Inputs
grp_key             = "Key Levels"
key_levels_enabled  = input.bool(true, "Key Levels", group=grp_key, tooltip="Previous Day High/Low/Close, Weekly/Monthly Open. \nKey reference levels for intraday structure, targets, and invalidation. \n\nâ€¢ PDH/PDL: Liquidity Magnets; Break/Reject helps Bias. \nâ€¢ PDC: Mean-reversion reference. \nâ€¢ Weekly/Monthly Open: Trend-Bias; Market above = Bull, below = Bear. \n\nOrigin-anchored: Lines start at the bar where the level formed.")
show_pdh            = input.bool(true, "PDHâ €", inline="kl_1", group=grp_key, tooltip="Prior Day High = liquidity pool; break+hold â†’ continuation, sweep+reclaim â†’ trap.")
show_pdl            = input.bool(true, "PDLâ €", inline="kl_1", group=grp_key, tooltip="Prior Day Low = liquidity pool; break+hold â†’ continuation, sweep+reclaim â†’ trap.")
show_pdc            = input.bool(false, "PDCâ €", inline="kl_1", group=grp_key, tooltip="Reversion target / magnet on range days.")
show_wopen          = input.bool(true, "Weekly Openâ €", inline="kl_1", group=grp_key, tooltip="Higher timeframe bias line; watch reclaim/hold for continuation days.")
show_mopen          = input.bool(false, "Monthly Open", inline="kl_1", group=grp_key, tooltip="Higher timeframe bias line; watch reclaim/hold for continuation days.")
key_style           = input.string("Lines", "Style", options=["Lines", "Labels", "Both"], inline="kl_3", group=grp_key, tooltip="Visual style for levels.")
key_extend          = input.bool(true, "Extend", inline="kl_3", group=grp_key, tooltip="Extend projects the level into the future; turn off to keep chart clean.")

// RVOL Inputs
grp_rvol            = "Relative Volume (RVOL)"
rvol_enabled        = input.bool(true, "RVOL Enabled", group=grp_rvol, tooltip="Relative Volume = Current Vol / Avg Vol. \nMeasures participation; confirms breakouts and reclaims. \nâ€¢ ORB/Breakout: RVOL > 2.0 signals expansion. \nâ€¢ Reclaim: RVOL pickup confirms strength.")
rvol_len            = input.int(20, "Length", minval=1, group=grp_rvol, inline="rv_1", tooltip="Average window; 20 is common.")
rvol_display        = input.string("Marker", "â €Display", options=["None", "Marker", "Label", "Both"], group=grp_rvol, inline="rv_1", tooltip="Visual style.")
rvol_points_enabled = input.bool(false, "Points", group=grp_rvol, inline="rv_1", tooltip="H/E only markers to reduce noise. \nEnabled by default in Breakout/ORB lenses.")
rvol_th_1           = input.float(1.2, "Low", step=0.1, group=grp_rvol, inline="rv_2", tooltip="1.2x: Slightly elevated.")
rvol_th_2           = input.float(2.0, "â €Med", step=0.1, group=grp_rvol, inline="rv_2", tooltip="2.0x: Event / Breakout fuel.")
rvol_th_3           = input.float(3.0, "â €High", step=0.1, group=grp_rvol, inline="rv_2", tooltip="3.0x: Strong trend / News.")

// VWAP Inputs
grp_vwap            = "VWAP"
vwap_enabled        = input.bool(false, "VWAP Enabled", group=grp_vwap, tooltip="Volume-weighted fair value. \nâ€¢ Trend: Above=Bull, Below=Bear. \nâ€¢ Reversion: Far from VWAP = Stretched.")
vwap_anchor         = input.string("Session (Daily Reset)", "Anchor", options=["Session (Daily Reset)", "Weekly"], group=grp_vwap, inline="vw_1", tooltip="Session: Intraday fair value. \nWeekly: Swing bias filter.")
vwap_src_opt        = input.string("HLC3", "â €Source", options=["HLC3", "HL2", "Close", "OHLC4"], group=grp_vwap, inline="vw_1", tooltip="HLC3 standard for fair value, HL2 for range focus, Close simplest; choose oneâ€”avoid overfitting.")
vwap_show_line      = input.bool(true, "Show Lineâ €", group=grp_vwap, inline="vw_2")
vwap_only_sess      = input.bool(false, "Calc Only in Sessions", group=grp_vwap, inline="vw_2", tooltip="If enabled, VWAP pauses outside selected sessions.")

vwap_bands_enabled  = input.bool(true, "Bands Enabled", group=grp_vwap, inline="vw_3", tooltip="Standard Deviation Bands (K1/K2/K3). \nUsage: 'Don't chase' zones and Take Profit targets.")
vwap_sigma_mode     = input.string("Rolling (ta.stdev)", "â €Sigma Mode", options=["Rolling (ta.stdev)", "Session (Welford)"], group=grp_vwap, inline="vw_3", tooltip="Rolling: Last N bars (Stable). \nWelford: Session-cumulative (Precise).")
vwap_stdev_len      = input.int(100, "â €Len", inline="vw_3", minval=2, group=grp_vwap, inline="vw_3")
band_k1             = input.float(1.0, "K1", step=0.5, group=grp_vwap, inline="vw_4", tooltip="1st Band Multiplier (1Ïƒ).")
band_k2             = input.float(2.0, "â €K2", step=0.5, group=grp_vwap, inline="vw_4", tooltip="2nd Band Multiplier (2Ïƒ).")
band_k3             = input.float(3.0, "â €K3", step=0.5, group=grp_vwap, inline="vw_4", tooltip="3rd Band Multiplier (3Ïƒ).")

vwap_z_enabled      = input.bool(true, "Z-Score Enabled", group=grp_vwap, inline="vw_5", tooltip="Z-Score = Distance to VWAP in Sigmas. \nUsed for Mean Reversion signals.")
z_th_entry          = input.float(2.0, "â €Entry Th", step=0.1, group=grp_vwap, inline="vw_5", tooltip="Avoid entries when stretched > Entry Th.")
z_th_tp             = input.float(2.5, "â €TP Th", step=0.1, group=grp_vwap, inline="vw_5", tooltip="Scale out when Z reaches TP Th.")
z_th_ext            = input.float(3.0, "Ext Th", step=0.1, group=grp_vwap, inline="vw_5", tooltip="Extreme extension; look for reversals.")

// OR/IB Inputs
grp_or              = "Opening Range / Initial Balance"
or_enabled          = input.bool(false, "OR/IB Enabled", group=grp_or, tooltip="Defines the first battle zone; key for trend vs range days.")
or_type             = input.string("Opening Range", "Type", options=["Opening Range", "Initial Balance"], group=grp_or, inline="or_1", tooltip="OR: User defined minutes. \nIB: First 60 minutes.")
or_sess             = input.string("New York", "â €Session", options=["London", "New York", "Custom"], group=grp_or, inline="or_1", tooltip="Market open context.")
or_cust             = input.session("0930-1600", "Custom Sess", group=grp_or, inline="or_2")
or_min              = input.int(15, "Duration", inline="or_2", minval=1, group=grp_or, inline="or_2", tooltip="Window size in minutes (for OR).")
or_display          = input.string("Box+Lines", "Display", options=["Box+Lines", "Box", "Lines"], group=grp_or, inline="or_3", tooltip="Visual style.")
or_lock             = input.bool(true, "Lock after Window", group=grp_or, inline="or_3", tooltip="Freeze levels after window ends (required for breakouts).")

// Squeeze Box
grp_sq              = "Squeeze Box"
sq_box_enabled      = input.bool(false, "Squeeze Boxâ €", inline="sq_b", group=grp_sq, tooltip="Builds a box during squeeze regime. Trade release/break with RVOL confirmation.")
sq_lock             = input.bool(true, "Lock on Release", inline="sq_b", group=grp_sq, tooltip="Locks the box levels when the squeeze ends to provide breakout references.")


// Smart MTF S&R
grp_psr             = "Smart S&R (Support & Resistance)"
ps_mode             = input.string("None", title="Smart S&R", options=["None", "Manuell", "Auto"], group=grp_psr, inline="en_tf", tooltip="")
ps_tf               = input.timeframe("D", title="â €â €â €â €Pivot TFâ €â €", inline="en_tf", group=grp_psr, tooltip="Activates the 'Smart Market Structure' system:
                      \nâ€¢ Multi-Timeframe Analysis: Identifies significant Swing Highs/Lows from a higher timeframe (e.g., 4H levels on a 15m chart).
                      \nâ€¢ Noise Filtering: Uses adjustable pivot strength to ignore minor price fluctuations.
                      \nâ€¢ Smart Zones: Automatically merges levels that are close together into a single 'Zone' (Box) to reduce clutter.
                      \nâ€¢ Dynamic State: Tracks confirmed breakouts and can automatically flip Support to Resistance (Role Reversal) or remove broken levels.
                      \nâ€¢ Clutter Control: Manages a fixed number of active levels, removing old or irrelevant ones automatically. \nSelect the Higher Timeframe to scan for significant Swing Highs/Lows. \nSmart S&R 'Auto' affects 'Pivot TF' only.")
ps_left             = input.int(2, title="Pivot Left", inline="pivot", minval=1, group=grp_psr, tooltip="Higher values filter out minor market noise. Left Standard=2 (Bill Williams Fractal).")
ps_right            = input.int(2, title="â €â €â €â €Pivot Right", inline="pivot", minval=1, group=grp_psr, tooltip="Higher values filter out minor market noise. Right Standard=2 (Bill Williams Fractal).")
ps_max              = input.int(20, title="Max Active Levels â €", minval=1, maxval=50, group=grp_psr, tooltip="Limits the number of visible lines to prevent chart clutter. FIFO (First In, First Out).")
ps_break_act        = input.string("Role Reversal", title="On Break Action ", options=["Keep", "Delete", "Role Reversal"], group=grp_psr, tooltip="How the script handles a level when price crosses it. \nKeep: Do nothing. \nDelete: Remove line. \nRole Reversal: Support becomes Resistance (Color change).")
ps_merge_en         = input.bool(true, title="Merge Nearby Levels (Zones) ", group=grp_psr, inline="ps_m")
ps_merge_pct        = input.float(0.1, title="Threshold %", minval=0.01, step=0.05, group=grp_psr, inline="ps_m", tooltip="If a new level appears within X% of an existing level, they are merged into a Zone.")
ps_col_res          = input.color(color.new(color.red, 30), title="Res Color", group=grp_psr, inline="ps_c")
ps_col_sup          = input.color(color.new(color.green, 30), title="â €Sup Color", group=grp_psr, inline="ps_c")
ps_col_zone         = input.color(color.new(color.blue, 85), title="â €Zone Fill", group=grp_psr, inline="ps_c")

// UDT for S&R Management
type SRLevel
    float price
    bool  is_res      // True=Resistance, False=Support
    bool  is_broken
    int   start_time
    line  id_line
    box   id_box      // Used if merged into a zone
    bool  is_zone

type ActiveSD
    box   id_box
    float top
    float bottom
    bool  is_bull
    bool  mitigated
    int   start_time

// --- New UDTs ---
type VwapState
    float cumVol
    float cumPV
    float vwap

type WelfordState
    int n
    float mean
    float m2

type OrState
    int start_bar
    float hi
    float lo
    bool building
    bool locked
    box id_box
    line l_hi
    line l_lo

type SqState
    float hi
    float lo
    bool active
    bool locked
    box id_box

// Bollinger Bands
grp_bb              = 'Bollinger Bands'
BB_plot             = input.bool(true, title='Bollinger Bandsâ €', inline="bb_t", group=grp_bb, tooltip='')
near_bb             = input.bool(true, title='Touched BBs only', inline="bb_t", group=grp_bb, tooltip='This maintains a better chart overview and works as reversal zone indicator.
                      \nWorks as support and resistence, as reversal zone and as squeeze indicator.')
// BB_length_1 & BB_sdev_1 moved to Advanced: REG
BB_sdev_2           = 3
BB_sdev_3           = 4
BB_sdev_4           = 5


// ema cloud and ma inputs
grp_ma              = 'EMA cloud and MA'
en_cloud            = input.bool(false, title='EMA Cloudâ €', inline="ema_c", group=grp_ma, tooltip='')
sig_plot            = input.bool(true, title='Cloud Color Signal', inline="ema_c", group=grp_ma, tooltip='EMA1 cross EMA2 color signal.
                      n\This EMA cloud works as dynamic support and resistance and as trend indication. A wide cloud indicates high volatility, a narrow cloud indicates low volatility and breakout potential. Interesting pairs: 8/21, 40/97')

ema_inp1            = input.int(8, title='EMA1 Length', inline="ema_l", minval=1, group=grp_ma, tooltip="")
ema_inp2            = input.int(21, title='â €EMA2 Length', inline="ema_l", minval=1, group=grp_ma, tooltip="")

// MA 1 Inputs
ma1_type            = input.string("EMA", title="MA 1", options=["None", "SMA", "EMA"], inline="ma1", group=grp_ma)
ma1_len             = input.int(200, title="", minval=1, inline="ma1", group=grp_ma)
ma1_slope_c         = input.bool(false, title="Slope Color", inline="ma1", group=grp_ma)

// MA 2 Inputs
ma2_type            = input.string("SMA", title="MA 2", options=["None", "SMA", "EMA"], inline="ma2", group=grp_ma)
ma2_len             = input.int(200, title="", minval=1, inline="ma2", group=grp_ma)
ma2_slope_c         = input.bool(false, title="Slope Color", inline="ma2", group=grp_ma)

// KAMA Inputs
kama_len            = 10
kama_fast           = 2
kama_slow           = 30

// two fractals trendlines inputs
grp_fr              = 'Trend lines'
plot_trendline      = input.bool(false, title='Fractal Trend Linesâ €', inline="fr_tr", group=grp_fr, tooltip='')
fractalBarsPerSide  = input.int(2, title="Bars Per Side", minval=0, maxval=10, inline="fr_tr", group=grp_fr, tooltip="The trend lines connect two up- and two down-Bill-Williams-Fractals. Works as price action/pattern breakout signal. \nNumber of bars to the left and right of the fractal bar for trendlines. Default is 2 (5-bar fractal).
                     Min=0 (Fractal(2) using anchored linear regression, follow the highs/lows of the subsequent candles to align with the current trend), Max=10 (21 bars).")

// divergence signal inputs
grp_div             = 'Divergences'
plot_div            = input.bool(true, title='Divergences', group=grp_div, tooltip='These divergences are very early signals and must be used in confluence with other signals. Hidden and classic divergence are used')
div_indi            = input.string('rsi', title='Divergence Indicator', options=['rsi', 'macd(fast_line)', 'macd(slow_line)'], tooltip='Select an Indicator for divergence calculation.', group=grp_div)
rsi_length          = input.int(14, title='RSI Length', inline="rsi_p", minval=1, step=2, group=grp_div)
bar_div_p           = input.int(25, title='â €â €â €â €Bar Period', inline="rsi_p", minval=1, step=1, tooltip='RSI Length. n\The number of bars in which divergences are detected.', group=grp_div)
src_div             = input.string('high/low', title='Bar Divergence Source', options=['high/low', 'close'], tooltip='The bar source for divergence calculation.', group=grp_div)

// bar signals inputs
grp_bar             = 'Bar signals'
plot_l12_bar        = input.bool(true, title='Last 12 Bar (L12) â €', inline="l12", tooltip='', group=grp_bar)
L12_input           = input.int(12, minval=1, title='Bar count', inline="l12", group=grp_bar, tooltip='"Letter: L, L12 => highest low of last 12 bars -> long. Lowest high of last 12 bars -> short. Indicates a new trend. \nLast 12 Bar" Bar count.')
plot_nr_bar         = input.bool(true, title='Narrow Range Bar (NR7)', tooltip='Letter: n, NR7 = narrowest range of a bar of the last seven bars. Indicates market tension.', group=grp_bar)
plot_i_bar          = input.bool(true, title='Inside Bar', tooltip='Letter: i. An inside bar is a triangle formation on smaller time frame.', group=grp_bar)
plot_o_bar          = input.bool(true, title='Outside Bar', tooltip='Letter: o. An outside bar is an opening funnel formation on smaller time frames. gray-> normal outside bar, valid at least for the next bar: red-> short, green-> long', group=grp_bar)
plot_s_bar          = input.bool(true, title='Sandwich Bar', tooltip='Letter: s. Indicates market tension.', group=grp_bar)
plot_f_bar          = input.bool(true, title='Fakey', tooltip='Letter: F. An inside bar false breakout.', group=grp_bar)

// segments inputs
grp_seg             = 'Segment signal'
plot_segments       = input.bool(false, title='Segments â €', inline="seg", tooltip='', group=grp_seg)
sb                  = input.int(10 ,title='Max Bars', inline="seg", minval=0, step=1, tooltip='Gray lines that follow the highest highs and lowest lows. This is a subtle way to detect a new trend. The higher the timeframe the more reliable the signal.
                      \nMax bars between two segment highs or segment lows.', group=grp_seg)


// pivot points inputs
grp_pi              = 'Pivot points'
plot_pivots_h1      = input.bool(false, title= "1 Hour Classic Pivot Points", group=grp_pi, tooltip= "1 Hour Pivot points (P, R1-R4, S1-S4). Only visible on charts < 1H.")
plot_pivots_h4      = input.bool(true, title= "4 Hour Classic Pivot Points", group=grp_pi, tooltip= "4 Hour Pivot points (P, R1-R4, S1-S4). Only visible on charts < 4H.")
plot_pivots_d       = input.bool(true, title= "1 Day Classic Pivot Points", group=grp_pi, tooltip= "Daily Pivot points (P, R1-R4, S1-S4). Only visible on intraday charts.")
plot_pivots_w       = input.bool(true, title= "1 Week Classic Pivot Points", group=grp_pi, tooltip= "1 week classic Pivot points are plotted (P, R1-R4, S1-4). Pivot points are used as support and resistance levels. Watch out for clusters.")
plot_pivots_m       = input.bool(true, title='1 Month Classic Pivot Points', group=grp_pi, tooltip='1 month classic pivot points are plotted (P, R1-R4, S1-4). Pivot points are used as support and resistance levels. Watch out for clusters.')
plot_pivots_3m      = input.bool(true, title='3 Month Classic Pivot Points', group=grp_pi, tooltip='3 month classic pivot points are plotted (P, R1-R4, S1-4). Pivot points are used as support and resistance levels. Watch out for clusters.')
plot_pivots_12m     = input.bool(true, title='12 Month Classic Pivot Points', group=grp_pi, tooltip='12 month classic pivot points are plotted (P, R1-R4, S1-4). Pivot points are used as support and resistance levels. Watch out for clusters.')

// TRADING SESSIONS INPUTS ---
grp_sess      = "Trading Sessions"
sess_timezone = input.string("Europe/Berlin", title="Timezone", inline="ses", tooltip="", group=grp_sess)
sess_style    = input.string("Vertical Line", title="â €Session Style", inline="ses", options=["Vertical Line", "Box", "Background", "Inv. Background"], group=grp_sess, tooltip="Standard: Europe/Berlin. Change to 'UTC' or 'America/New_York' if needed. \nVisual style for trading sessions: \nâ€¢ Vertical Line: Start/End lines. \nâ€¢ Box: High/Low Range. \nâ€¢ Background: Session Time Window (Highest Priority Layer). \nâ€¢ Inv. Background: Unified Color (Blue 50%) during 'Off-Hours'.")

use_sess_rest   = input.bool(false, title="Session Restriction", inline="ses_rest", group=grp_sess)
sess_rest_time  = input.int(60, title="â €â €â €â €Time", inline="ses_rest", tooltip="Rstricts Session Trading Time (Default 1 hour).", group=grp_sess)

// London - ORANGE
london_show   = input.bool(true, title="London Session â €â €", group=grp_sess, inline="lon")
london_sess   = input.session("0900-1730", title="", group=grp_sess, inline="lon")
london_col    = input.color(color.new(color.orange, 90), title="", group=grp_sess, inline="lon")

// New York - BLUE
ny_show       = input.bool(true, title="New York Sessionâ €", group=grp_sess, inline="ny")
ny_sess       = input.session("1530-2200", title="", group=grp_sess, inline="ny")
ny_col        = input.color(color.new(color.blue, 90), title="", group=grp_sess, inline="ny")

// Tokyo - YELLOW
tokyo_show    = input.bool(false, title="Tokyo Session â €â €â €", group=grp_sess, inline="tok")
tokyo_sess    = input.session("0100-0900", title="", group=grp_sess, inline="tok")
tokyo_col     = input.color(color.new(color.yellow, 90), title="", group=grp_sess, inline="tok")

// Sydney - RED
sydney_show     = input.bool(false, title="Sydney Session â €â €", group=grp_sess, inline="syd")
sydney_sess     = input.session("2200-0700", title="", group=grp_sess, inline="syd")
sydney_col      = input.color(color.new(color.red, 90), title="", group=grp_sess, inline="syd")
sess_line_limit = input.int(150, "Max Session Lines (FIFO)", group=grp_sess, minval=20, tooltip="Limits total number of vertical session lines to prevent 'Max lines' error.")

// Alerts
grp_alerts      = "ðŸ”” Alerts"
alert_profile   = input.string("Normal", "Alert Profile", options=["Off", "Minimal","Normal","Moderate"], group=grp_alerts, tooltip="Controls the complexity of alert triggers to avoid spam. \nâ€¢ Off: No alerts. \nâ€¢ Minimal: Trendline Breakouts only. \nâ€¢ Normal: Adds Divergences. \nâ€¢ Moderate: Adds Regime Changes & High Confluence Events.")
alert_cooldown  = input.int(5, "Cooldown (Bars)", minval=1, group=grp_alerts, tooltip="Wait period (in bars) after an alert is triggered before the same alert type can trigger again. Prevents repetitive alerts during the same market event.")
use_rt_alert   = input.bool(false, title="Alert on 5th Fractal Candle (Real-time)", group=grp_alerts, tooltip="Triggers an alert signal while the 5th candle of a fractal pattern is forming (Real-time). Select 'Any function call' when creating the alert.")


// Debug (Performance)
debug_on       = input.bool(false, "Debug (Perf)", group="Debug")

// attributes inputs
grp_atri            = "Attributes of drawn objects"
vp_color            = input.color(color.new(color.red, 0), "Volume Profile Color", group=grp_atri)

color_fr            = input.color(color.white, "Fractal Color", group=grp_atri)
transp_fr           = input.int(40, "Fractal Transparency", minval=1, maxval= 100, group=grp_atri)

color_ema_c         = input.color(color.blue, 'EMA Cloud Color', group=grp_atri)
color_ema_sig_up    = input.color(color.green, 'EMA Signal Up Cloud Color', group=grp_atri)
color_ema_sig_dn    = input.color(color.red, 'EMA Signal Down Cloud Color', group=grp_atri)
transp_ema_c        = input.int(65, 'EMA Cloud Transparency', minval=1, maxval= 100, group=grp_atri)

color_tr            = input.color(color.blue, 'Trend Line Color', group=grp_atri)
width_tr            = input.int(2, 'Trend Line Width', minval=1, group=grp_atri)
transp_tr           = input.int(50, 'Trend Line Transparency', minval=1, maxval= 100, group=grp_atri)

color_seg           = input.color(color.white, 'Segment Line Color', group=grp_atri)
transp_seg          = input.int(65, 'Segment Line Transparency', minval=1, maxval= 100, group=grp_atri)

transp_bg           = input.int(85, 'Background Color Transparency', minval=1, maxval= 100, group=grp_atri)


//-------------------------------------------------------- GLOBAL ON-FLAGS (Performance / Gating) --------------------------------------------------------
// Stage 0: Centralized Gating Flags as aliases for inputs

// Preset Helper
f_approach_bool(_custom, _sessMap, _orb, _mr, _brk, _sqzBrk, _trend) =>
    result = _custom
    if trading_approach == "Session Map"
        result := _sessMap
    else if trading_approach == "ORB"
        result := _orb
    else if trading_approach == "Mean Reversion"
        result := _mr
    else if trading_approach == "Breakout"
        result := _brk
    else if trading_approach == "Squeeze Breakout"
        result := _sqzBrk
    else if trading_approach == "Trend Continuation"
        result := _trend
    result

// Preset Helper for Strings
f_approach_str(_custom, _sessMap, _orb, _mr, _brk, _sqzBrk, _trend) =>
    result = _custom
    if trading_approach == "Session Map"
        result := _sessMap
    else if trading_approach == "ORB"
        result := _orb
    else if trading_approach == "Mean Reversion"
        result := _mr
    else if trading_approach == "Breakout"
        result := _brk
    else if trading_approach == "Squeeze Breakout"
        result := _sqzBrk
    else if trading_approach == "Trend Continuation"
        result := _trend
    result

// Effective Feature Flags
//                                          Cust           SessMap   ORB    MR     Brk    SqzBrk  Trend
eff_fractals_plot   = f_approach_bool(fractals_plot,      true,     true,  true,  true,  true,   true)
eff_sub_fractals    = f_approach_bool(sub_fractals,       false,    false, false, false, false,  false)
eff_plot_trendline  = f_approach_bool(plot_trendline,     false,    true,  false, true,  true,   true)

eff_vp_enable       = f_approach_bool(vp_enable,          false,    false, false, false, false,  false)
eff_vp_smart        = f_approach_bool(vp_smart,           vp_smart, false, false, false, false,  false)

eff_show_mtf_candles= f_approach_bool(show_mtf_candles,   false,    false, false, false, false,  false)

eff_use_sess_1st    = f_approach_bool(use_sess_1st,       false,    false, false, false, false,  false)
eff_show_last_frac  = f_approach_bool(show_last_frac,     false,    false, false, false, false,  false)
eff_show_vol        = f_approach_bool(show_vol,           true,     false, false, false, false,  false) // Legacy spike, prefer RVOL in new modes

eff_plot_fvg1       = f_approach_bool(plot_fvg1,          false,    false, false, false, false,  true)
eff_plot_fvg2       = f_approach_bool(plot_fvg2,          false,    false, false, false, false,  false)

eff_ps_mode         = f_approach_str(ps_mode,             "None",   "None","None","None","None", "Auto")

eff_BB_plot         = f_approach_bool(BB_plot,            false,    false, false, false, false,  false) // MR uses VWAP Bands

eff_en_cloud        = f_approach_bool(en_cloud,           false,    false, false, false, false,  false)
eff_sig_plot        = f_approach_bool(sig_plot,           sig_plot, false, false, false, false,  false)
eff_ma1_type        = f_approach_str(ma1_type,            ma1_type, "None","None","None","None", "None")
eff_ma2_type        = f_approach_str(ma2_type,            ma2_type, "None","None","None","None", "None")

eff_plot_div        = f_approach_bool(plot_div,           false,    false, true,  false, false,  false)

// Bar Patterns
eff_plot_l12_bar    = f_approach_bool(plot_l12_bar,       false,    false, false, false, false,  false)
eff_plot_nr_bar     = f_approach_bool(plot_nr_bar,        false,    false, false, false, false,  false)
eff_plot_i_bar      = f_approach_bool(plot_i_bar,         false,    false, false, false, false,  false)
eff_plot_o_bar      = f_approach_bool(plot_o_bar,         false,    false, false, false, false,  false)
eff_plot_s_bar      = f_approach_bool(plot_s_bar,         false,    false, false, false, false,  false)
eff_plot_f_bar      = f_approach_bool(plot_f_bar,         false,    false, false, false, false,  false)

eff_plot_segments   = f_approach_bool(plot_segments,      false,    false, false, false, false,  false)

// Pivots (Classic)
eff_plot_pivots_h1  = f_approach_bool(plot_pivots_h1,     false,    false, false, false, false,  false)
eff_plot_pivots_h4  = f_approach_bool(plot_pivots_h4,     false,    false, false, false, false,  false)
eff_plot_pivots_d   = f_approach_bool(plot_pivots_d,      false,    false, false, false, false,  false)
eff_plot_pivots_w   = f_approach_bool(plot_pivots_w,      false,    false, false, false, false,  false)
eff_plot_pivots_m   = f_approach_bool(plot_pivots_m,      false,    false, false, false, false,  false)
eff_plot_pivots_3m  = f_approach_bool(plot_pivots_3m,     false,    false, false, false, false,  false)
eff_plot_pivots_12m = f_approach_bool(plot_pivots_12m,    false,    false, false, false, false,  false)

// Sessions
eff_london_show     = f_approach_bool(london_show,        true,     true,  false, false, false,  false)
eff_ny_show         = f_approach_bool(ny_show,            true,     true,  false, false, false,  false)
eff_tokyo_show      = f_approach_bool(tokyo_show,         true,     true,  false, false, false,  false)
eff_sydney_show     = f_approach_bool(sydney_show,        true,     true,  false, false, false,  false)

// Session BG Flag
eff_sess_bg_enable  = f_approach_bool(true,               true,     false, false, false, false,  false)

// Key Levels Flags
eff_key_levels_enabled = f_approach_bool(key_levels_enabled, true, true, true, true, true, true)
eff_show_pdh    = f_approach_bool(show_pdh, true, true, true, true, true, true)
eff_show_pdl    = f_approach_bool(show_pdl, true, true, true, true, true, true)
eff_show_pdc    = f_approach_bool(show_pdc, false, false, false, false, false, false)
eff_show_wopen  = f_approach_bool(show_wopen, true, false, true, false, false, true)
eff_show_mopen  = f_approach_bool(show_mopen, false, false, false, false, false, false)

// RVOL Flags
eff_rvol_enabled = f_approach_bool(rvol_enabled, false, true, false, true, true, false)
eff_rvol_points_enabled = f_approach_bool(rvol_points_enabled, false, true, false, true, true, false)

// VWAP Flags
eff_vwap_enabled = f_approach_bool(vwap_enabled, false, false, true, false, false, true)
eff_vwap_anchor  = f_approach_str(vwap_anchor, "Session (Daily Reset)", "Session (Daily Reset)", "Session (Daily Reset)", "Session (Daily Reset)", "Session (Daily Reset)", "Weekly")
eff_vwap_bands   = f_approach_bool(vwap_bands_enabled, false, false, true, false, false, false)
eff_vwap_z       = f_approach_bool(vwap_z_enabled, false, false, true, false, false, false)

// OR/IB Flags
eff_or_enabled   = f_approach_bool(or_enabled, false, true, false, true, false, false)

// Squeeze Box Flags
eff_sq_box_enabled = f_approach_bool(sq_box_enabled, false, false, false, false, true, false)

int active_sec_calls = 0
// Performance Counters (Per Bar)
int ops_trend = 0
int ops_vp_scan = 0
int ops_vp_draw = 0
int ops_div = 0
int ops_bb = 0

// Peak Trackers
var int peak_ops_trend = 0
var int peak_ops_vp = 0

var table tbl_dbg = na

ON_FVG1         = eff_plot_fvg1
ON_FVG2         = eff_plot_fvg2
ON_MTF_OV       = eff_show_mtf_candles
ON_SESS_1ST     = eff_use_sess_1st
ON_LAST_FR      = eff_show_last_frac
ON_PS           = eff_ps_mode != "None"

// New Features Flags (Independently Controlled)
// Confluence & Regime are now strictly controlled by their inputs, ignoring Profile Mode
eff_show_conf_meter = show_conf_meter
eff_regime_panel    = show_regime_panel
eff_regime_bg_mode  = regime_bg_mode

// ADR/KC Logic (Mapped to Config Stage)
// We map the legacy names to our new effective variables to minimize downstream changes
squeeze_strict      = eff_squeeze_strict

//----------------- Global Signal Registry (For Alerts & Confluence) -----------------
// These variables are reset to false/na on every bar execution
// We populate them inside the respective feature blocks
bool sig_tl_bull        = false
bool sig_tl_bear        = false
bool sig_div_bull       = false
bool sig_div_bear       = false
bool sig_ema_bull       = false
bool sig_ema_bear       = false
bool sig_ma_bull        = false
bool sig_ma_bear        = false
bool sig_seg_bull       = false
bool sig_seg_bear       = false
bool sig_l12_bull       = false
bool sig_l12_bear       = false
bool sig_pat_bull       = false
bool sig_pat_bear       = false // General pattern
bool sig_o_bull         = false
bool sig_o_bear         = false
bool sig_kama_bull      = false
bool sig_kama_bear      = false
bool sig_fvg_bull       = false
bool sig_fvg_bear       = false
bool sig_vol_spike      = false


// Helper Functions for Object Reuse (Unified)
f_line_get_or_create(_l, _x1, _y1, _x2, _y2, _col, _style, _xloc=xloc.bar_index) =>
    line ret = _l
    if na(ret)
        ret := line.new(_x1, _y1, _x2, _y2, extend=extend.right, color=_col, style=_style, width=1, xloc=_xloc)
    else
        line.set_xy1(ret, _x1, _y1)
        line.set_xy2(ret, _x2, _y2)
        line.set_color(ret, _col)
        line.set_style(ret, _style)
    ret

f_label_get_or_create(_lb, _x, _y, _txt, _col) =>
    label ret = _lb
    if na(ret)
        ret := label.new(_x, _y, _txt, xloc=xloc.bar_index, yloc=yloc.price, style=label.style_none, textcolor=_col, size=size.small, textalign=text.align_left)
    else
        label.set_xy(ret, _x, _y)
        label.set_text(ret, _txt)
        label.set_textcolor(ret, _col)
    ret


//------------------------------------------------------- Key Levels Module -------------------------------------------------------
// Stage 1: PDH/PDL/PDC + Weekly/Monthly Open (Origin-Anchored)

// 1. Data Fetching (O(1))
float d_h = na, float d_l = na, float d_c = na, int d_start = na, int d_end = na
float w_o = na, int w_start = na
float m_o = na, int m_start = na

if eff_key_levels_enabled
    [t_dh, t_dl, t_dc, t_ds, t_de] = request.security(syminfo.tickerid, "D", [high[1], low[1], close[1], time[1], time], lookahead=barmerge.lookahead_off)
    d_h := t_dh, d_l := t_dl, d_c := t_dc, d_start := t_ds, d_end := t_de

    [t_wo, t_ws] = request.security(syminfo.tickerid, "W", [open, time], lookahead=barmerge.lookahead_on)
    w_o := t_wo, w_start := t_ws

    [t_mo, t_ms] = request.security(syminfo.tickerid, "M", [open, time], lookahead=barmerge.lookahead_on)
    m_o := t_mo, m_start := t_ms

    active_sec_calls += 3

// 2. Scan & State Management
var int idx_pdh = na
var int idx_pdl = na
var int idx_pdc = na

// State to detect new day/week/month
var int last_d_start = 0

// Objects
var line l_pdh = na, var label lb_pdh = na
var line l_pdl = na, var label lb_pdl = na
var line l_pdc = na, var label lb_pdc = na
var line l_wo  = na, var label lb_wo  = na
var line l_mo  = na, var label lb_mo  = na

// Helper for Drawing (Global Scope)
f_draw_kl(_l, _lb, _idx, _val, _txt, _col, _en, _style, _ext) =>
    line ret_l = _l
    label ret_lb = _lb

    if _en and not na(_val) and not na(_idx)
        // Line
        if key_style != "Labels"
            ret_l := f_line_get_or_create(ret_l, _idx, _val, bar_index, _val, _col, _style)
            line.set_extend(ret_l, _ext ? extend.right : extend.none)
        else
            line.delete(ret_l)
            ret_l := na

        // Label
        if key_style != "Lines"
            ret_lb := f_label_get_or_create(ret_lb, bar_index + 5, _val, _txt, _col)
        else
            label.delete(ret_lb)
            ret_lb := na
    else
        line.delete(ret_l)
        label.delete(ret_lb)
        ret_l := na
        ret_lb := na

    [ret_l, ret_lb]

f_draw_kl_time(_l, _lb, _t1, _val, _txt, _col, _en, _style, _ext) =>
    line ret_l = _l
    label ret_lb = _lb

    if _en and not na(_val) and not na(_t1)
        // Line
        if key_style != "Labels"
            ret_l := f_line_get_or_create(ret_l, _t1, _val, time_close, _val, _col, _style, xloc.bar_time)
            line.set_extend(ret_l, _ext ? extend.right : extend.none)
        else
            line.delete(ret_l)
            ret_l := na

        // Label
        if key_style != "Lines"
            ret_lb := f_label_get_or_create(ret_lb, bar_index + 5, _val, _txt, _col)
        else
            label.delete(ret_lb)
            ret_lb := na
    else
        line.delete(ret_l)
        label.delete(ret_lb)
        ret_l := na
        ret_lb := na

    [ret_l, ret_lb]

// Scan Limits
int MAX_SCAN = 4000 // Max bars back

if eff_key_levels_enabled and barstate.islast and bar_index > 100
    // Dynamic Scan Limit (Safe)
    int scan_limit = math.min(MAX_SCAN, bar_index)

    // PDH/PDL/PDC Scan
    if d_start != last_d_start
        idx_pdh := na
        idx_pdl := na
        idx_pdc := na

        float scan_max_h = -1.0e10
        int   scan_max_h_idx = na
        float scan_min_l = 1.0e10
        int   scan_min_l_idx = na

        int   scan_last_idx = na
        int   fallback_idx = na

        if scan_limit >= 1
            for i = 1 to scan_limit
                int t = time[i]
                if t < d_start
                    break

                if t >= d_start
                    fallback_idx := bar_index - i

                if t >= d_start and t < d_end
                    // Track High (>= to find earliest/left-most in backward scan)
                    if high[i] >= scan_max_h
                        scan_max_h := high[i]
                        scan_max_h_idx := bar_index - i

                    // Track Low (<= to find earliest/left-most in backward scan)
                    if low[i] <= scan_min_l
                        scan_min_l := low[i]
                        scan_min_l_idx := bar_index - i

                    // Track Close (first encountered going backwards is the latest/close)
                    if na(scan_last_idx)
                        scan_last_idx := bar_index - i

        int fb_final = not na(fallback_idx) ? fallback_idx : (bar_index - scan_limit)
        idx_pdh := not na(scan_max_h_idx) ? scan_max_h_idx : fb_final
        idx_pdl := not na(scan_min_l_idx) ? scan_min_l_idx : fb_final
        idx_pdc := not na(scan_last_idx) ? scan_last_idx : fb_final
        last_d_start := d_start

    // Drawing
    // Execute Draws
    [t_l_pdh, t_lb_pdh] = f_draw_kl(l_pdh, lb_pdh, idx_pdh, d_h, "PDH", color.new(color.red, 30), eff_show_pdh, line.style_dashed, key_extend)
    l_pdh := t_l_pdh, lb_pdh := t_lb_pdh

    [t_l_pdl, t_lb_pdl] = f_draw_kl(l_pdl, lb_pdl, idx_pdl, d_l, "PDL", color.new(color.green, 30), eff_show_pdl, line.style_dashed, key_extend)
    l_pdl := t_l_pdl, lb_pdl := t_lb_pdl

    [t_l_pdc, t_lb_pdc] = f_draw_kl(l_pdc, lb_pdc, idx_pdc, d_c, "PDC", color.new(color.gray, 30), eff_show_pdc, line.style_dotted, key_extend)
    l_pdc := t_l_pdc, lb_pdc := t_lb_pdc

    [t_l_wo, t_lb_wo] = f_draw_kl_time(l_wo, lb_wo, w_start, w_o, "W.Open", color.new(color.orange, 0), eff_show_wopen, line.style_dashed, key_extend)
    l_wo := t_l_wo, lb_wo := t_lb_wo

    [t_l_mo, t_lb_mo] = f_draw_kl_time(l_mo, lb_mo, m_start, m_o, "M.Open", color.new(color.white, 0), eff_show_mopen, line.style_dashed, key_extend)
    l_mo := t_l_mo, lb_mo := t_lb_mo

else
    // Cleanup if disabled
    line.delete(l_pdh)
    label.delete(lb_pdh)
    line.delete(l_pdl)
    label.delete(lb_pdl)
    line.delete(l_pdc)
    label.delete(lb_pdc)
    line.delete(l_wo)
    label.delete(lb_wo)
    line.delete(l_mo)
    label.delete(lb_mo)

    l_pdh:=na
    lb_pdh:=na
    l_pdl:=na
    lb_pdl:=na
    l_pdc:=na
    lb_pdc:=na
    l_wo:=na
    lb_wo:=na
    l_mo:=na
    lb_mo:=na


//------------------------------------------------------- RVOL Module -------------------------------------------------------
// Stage 2: Standard RVOL

float rvol_val = na
string rvol_state = "0"

if eff_rvol_enabled
    // Standard RVOL
    float v_avg = ta.sma(volume, rvol_len)

    if v_avg > 0
        rvol_val := volume / v_avg

    if not na(rvol_val)
        if rvol_val >= rvol_th_3
            rvol_state := "3"
        else if rvol_val >= rvol_th_2
            rvol_state := "2"
        else if rvol_val >= rvol_th_1
            rvol_state := "1"

// Visuals
bool show_rvol_visuals = eff_rvol_enabled and rvol_display != "None" and rvol_state != "0"
color c_rv = rvol_state == "3" ? color.red : rvol_state == "2" ? color.orange : color.yellow
// Marker only for H/E (State 2 or 3) if enabled
bool show_marker = show_rvol_visuals and (rvol_display == "Marker" or rvol_display == "Both") and eff_rvol_points_enabled and (rvol_state == "3" or rvol_state == "2")

plotshape(show_marker, style=shape.circle, location=location.bottom, color=c_rv, size=size.tiny, title="RVOL Marker")

if show_rvol_visuals and (rvol_display == "Label" or rvol_display == "Both")
    string txt = "RVOL " + str.tostring(rvol_val, "#.#")
    var label lb_rvol = na
    label.delete(lb_rvol)
    lb_rvol := label.new(bar_index, low, txt, yloc=yloc.belowbar, color=c_rv, style=label.style_label_up, textcolor=color.black, size=size.small)


//-------------------------------------------------------- williams fractals (Visuals for Chart) --------------------------------------------------------------

up_fr               = ta.pivothigh(2, 2)
dn_fr               = ta.pivotlow(2, 2)

last_up_fr_level    = ta.valuewhen(up_fr, high[2], 0)
last_dn_fr_level    = ta.valuewhen(dn_fr, low[2], 0)

// Plot fractals
plotshape(eff_fractals_plot ? up_fr : na, style=shape.triangleup, location=location.abovebar, offset=-2, color=color.new(color_fr, transp_fr), title='Fractal up')
plotshape(eff_fractals_plot ? dn_fr : na, style=shape.triangledown, location=location.belowbar, offset=-2, color=color.new(color_fr, transp_fr), title='Fractal down')

// Sub Fractals Logic
// Up Sub Fractals
// Pattern A: Peak at [2] (1 Left, 2 Right). Strict check (left 2nd bar must be higher to NOT be a standard fractal) to avoid overlap.
up_sub_a = high[2] > high[3] and high[2] > high[1] and high[2] > high[0]
up_sub_a_strict = up_sub_a and high[2] <= high[4]

// Pattern B: Peak at [2] (2 Left, 1 Right) - Strict: Must NOT be 2 Right (high[2] <= high[0])
up_sub_b = high[2] > high[4] and high[2] > high[3] and high[2] > high[1] and high[2] <= high[0]

// Down Sub Fractals
// Pattern A: Peak at [2] (1 Left, 2 Right)
dn_sub_a = low[2] < low[3] and low[2] < low[1] and low[2] < low[0]
dn_sub_a_strict = dn_sub_a and low[2] >= low[4]

// Pattern B: Peak at [2] (2 Left, 1 Right) - Strict: Must NOT be 2 Right (low[2] >= low[0])
dn_sub_b = low[2] < low[4] and low[2] < low[3] and low[2] < low[1] and low[2] >= low[0]

// Plot Sub Fractals
col_sub_fr = color.new(color.gray, 30)

plotshape(eff_sub_fractals and up_sub_a_strict ? high[2] : na, style=shape.triangleup, location=location.abovebar, offset=-2, color=col_sub_fr, title='Sub Fractal Up A')
plotshape(eff_sub_fractals and up_sub_b ? high[2] : na, style=shape.triangleup, location=location.abovebar, offset=-2, color=col_sub_fr, title='Sub Fractal Up B')

plotshape(eff_sub_fractals and dn_sub_a_strict ? low[2] : na, style=shape.triangledown, location=location.belowbar, offset=-2, color=col_sub_fr, title='Sub Fractal Down A')
plotshape(eff_sub_fractals and dn_sub_b ? low[2] : na, style=shape.triangledown, location=location.belowbar, offset=-2, color=col_sub_fr, title='Sub Fractal Down B')


//------------------------------------------------------- Pro Smart S&R Logic -----------------------------------------------------

// --- 1. Data Fetching (MTF) ---
// Function to get Raw Pivot Data from HTF
// We need to return specific values when a pivot is confirmed
f_get_mtf_pivots(_src_h, _src_l, _l, _r) =>
    _ph = ta.pivothigh(_src_h, _l, _r)
    _pl = ta.pivotlow(_src_l, _l, _r)

    // Values are confirmed at the close of the bar _r bars after the peak
    // We return the Price and the Time of the peak
    // Note: Pivot High was at offset _r
    _ph_val = not na(_ph) ? _ph : na
    _ph_time = not na(_ph) ? time[_r] : na

    _pl_val = not na(_pl) ? _pl : na
    _pl_time = not na(_pl) ? time[_r] : na

    [_ph_val, _ph_time, _pl_val, _pl_time]

// Helper to calculate Auto Timeframe
f_calc_auto_tf() =>
    if timeframe.isseconds
        "30" // Fallback
    else if timeframe.isintraday
        if timeframe.multiplier <= 15
            "120"
        else if timeframe.multiplier <= 240
            "D"
        else
            "W"
    else if timeframe.isdaily
        "W"
    else if timeframe.isweekly
        "3M"
    else if timeframe.ismonthly
        if timeframe.multiplier <= 3
            "12M"
        else
            "12M"
    else
        "12M"

// Determine Effective TF
ps_tf_final = eff_ps_mode == "Auto" ? f_calc_auto_tf() : ps_tf

// Security call to get the data from the selected timeframe
float s_ph_val = na
int s_ph_time = na
float s_pl_val = na
int s_pl_time = na

if ON_PS
    [t_ph, t_pht, t_pl, t_plt] = request.security(syminfo.tickerid, ps_tf_final, f_get_mtf_pivots(high, low, ps_left, ps_right))
    s_ph_val := t_ph
    s_ph_time := t_pht
    s_pl_val := t_pl
    s_pl_time := t_plt
    active_sec_calls += 1

// --- 2. State Management (Arrays) ---
var sr_levels = array.new<SRLevel>()
var int last_ph_t = 0
var int last_pl_t = 0

// Helper to check proximity for Merging
f_is_near(_p1, _p2, _pct) =>
    math.abs(_p1 - _p2) <= (_p1 * (_pct / 100))

// Main Logic Loop (Runs on every bar, but updates state only on new pivots or close)
if ON_PS
    // A. Ingest New High Pivot
    if not na(s_ph_val) and s_ph_time != last_ph_t
        last_ph_t := s_ph_time
        // Check for merge candidate (Iterate backwards to find newest nearby)
        bool merged = false
        if ps_merge_en and array.size(sr_levels) > 0
            for i = array.size(sr_levels) - 1 to 0
                SRLevel lvl = array.get(sr_levels, i)
                // Only merge with same type (Resistance) and active lines
                if lvl.is_res and not lvl.is_broken and f_is_near(lvl.price, s_ph_val, ps_merge_pct)
                    // CONVERT TO ZONE
                    if not lvl.is_zone
                        // Create Box
                        float top = math.max(lvl.price, s_ph_val)
                        float bot = math.min(lvl.price, s_ph_val)
                        lvl.id_box := box.new(lvl.start_time, top, time, bot, xloc=xloc.bar_time, border_color=na, bgcolor=ps_col_zone)
                        lvl.is_zone := true
                        // Delete the old line
                        line.delete(lvl.id_line)
                    else
                        // Extend Zone Price Range
                        float cur_top = box.get_top(lvl.id_box)
                        float cur_bot = box.get_bottom(lvl.id_box)
                        box.set_top(lvl.id_box, math.max(cur_top, s_ph_val))
                        box.set_bottom(lvl.id_box, math.min(cur_bot, s_ph_val))

                    array.set(sr_levels, i, lvl)
                    merged := true
                    break

        if not merged
            // Add New Resistance Line
            line new_l = line.new(s_ph_time, s_ph_val, time, s_ph_val, xloc=xloc.bar_time, color=ps_col_res, style=line.style_solid, width=1)
            SRLevel new_lvl = SRLevel.new(s_ph_val, true, false, s_ph_time, new_l, na, false)
            array.push(sr_levels, new_lvl)

    // B. Ingest New Low Pivot
    if not na(s_pl_val) and s_pl_time != last_pl_t
        last_pl_t := s_pl_time
        // Check for merge candidate
        bool merged = false
        if ps_merge_en and array.size(sr_levels) > 0
            for i = array.size(sr_levels) - 1 to 0
                SRLevel lvl = array.get(sr_levels, i)
                if not lvl.is_res and not lvl.is_broken and f_is_near(lvl.price, s_pl_val, ps_merge_pct)
                    // CONVERT TO ZONE
                    if not lvl.is_zone
                        float top = math.max(lvl.price, s_pl_val)
                        float bot = math.min(lvl.price, s_pl_val)
                        lvl.id_box := box.new(lvl.start_time, top, time, bot, xloc=xloc.bar_time, border_color=na, bgcolor=ps_col_zone)
                        lvl.is_zone := true
                        line.delete(lvl.id_line)
                    else
                        float cur_top = box.get_top(lvl.id_box)
                        float cur_bot = box.get_bottom(lvl.id_box)
                        box.set_top(lvl.id_box, math.max(cur_top, s_pl_val))
                        box.set_bottom(lvl.id_box, math.min(cur_bot, s_pl_val))

                    array.set(sr_levels, i, lvl)
                    merged := true
                    break

        if not merged
            line new_l = line.new(s_pl_time, s_pl_val, time, s_pl_val, xloc=xloc.bar_time, color=ps_col_sup, style=line.style_solid, width=1)
            SRLevel new_lvl = SRLevel.new(s_pl_val, false, false, s_pl_time, new_l, na, false)
            array.push(sr_levels, new_lvl)

    // C. Pruning (FIFO)
    while array.size(sr_levels) > ps_max
        // Remove oldest (Index 0)
        SRLevel old = array.shift(sr_levels)
        line.delete(old.id_line)
        box.delete(old.id_box)

    // D. Update & Break Handling (Loop all active levels)
    // We loop backwards to allow safe removal if "Delete" action is selected
    if array.size(sr_levels) > 0
        for i = array.size(sr_levels) - 1 to 0
            SRLevel lvl = array.get(sr_levels, i)

            // 1. Check Break
            // Use current close to detect break.
            // Resistance Broken: Close > Price
            // Support Broken: Close < Price
            // For Zones: Check against Top/Bottom
            bool broken_now = false

            if not lvl.is_broken
                // Stage 6: Getter Caching (Micro-Opt)
                // Cache top/bottom to avoid double calling get_top/get_bottom in expressions
                float zone_top = na
                float zone_bot = na
                if lvl.is_zone
                    zone_top := box.get_top(lvl.id_box)
                    zone_bot := box.get_bottom(lvl.id_box)

                float check_price = lvl.is_zone ? (lvl.is_res ? zone_top : zone_bot) : lvl.price

                if lvl.is_res and close > check_price
                    broken_now := true
                else if not lvl.is_res and close < check_price
                    broken_now := true

            if broken_now
                lvl.is_broken := true
                if ps_break_act == "Delete"
                    line.delete(lvl.id_line)
                    box.delete(lvl.id_box)
                    array.remove(sr_levels, i)
                    continue // Skip to next iteration

                if ps_break_act == "Role Reversal"
                    // Reset broken status for the new role
                    lvl.is_broken := false
                    // Flip Type
                    lvl.is_res := not lvl.is_res
                    // Update Color
                    color new_c = lvl.is_res ? ps_col_res : ps_col_sup
                    if not lvl.is_zone
                        line.set_color(lvl.id_line, new_c)
                        line.set_style(lvl.id_line, line.style_dashed)

            // 2. Extend visual to current time (Stage 6: Micro-Opt)
            if barstate.islast
                if not lvl.is_zone
                    line.set_x2(lvl.id_line, time)
                else
                    box.set_right(lvl.id_box, time)
else
    // Cleanup when disabled
    if array.size(sr_levels) > 0
        for i = 0 to array.size(sr_levels) - 1
            SRLevel lvl = array.get(sr_levels, i)
            line.delete(lvl.id_line)
            box.delete(lvl.id_box)
        array.clear(sr_levels)


//---------------------------------------------------- macd and rsi divergences (Visuals for Chart) -------------------------------------------------------------

// Stage 3: Divergences Hard-Gating
ON_DIV = eff_plot_div

float rsi_d = na
float macdLine = na
float signalLine = na
float histLine = na
float bar_scr_bear = na
float bar_scr_bull = na
float indi_scr = na

bool c_div_bear = false
bool c_div_bull = false
bool h_div_bear = false
bool h_div_bull = false

if ON_DIV
    ops_div += 1 // Count Ops (at least one block execution)

    rsi_d := ta.rsi(close, rsi_length)

    fast_length     = 12
    slow_length     = 26
    signal_length   = 9
    src             = close

    [t_macd, t_sig, t_hist] = ta.macd(src, fast_length, slow_length, signal_length)
    macdLine := t_macd
    signalLine := t_sig
    histLine := t_hist

    bar_scr_bear := src_div == 'close' ? close : high
    bar_scr_bull := src_div == 'close' ? close : low

    indi_scr := div_indi == 'rsi' ? rsi_d : div_indi == 'macd(fast_line)' ? macdLine : div_indi == 'macd(slow_line)' ? signalLine : na

    //rsi and macd divergence calc
    // Check if indi_scr is valid before calculation
    if not na(indi_scr)
        c_div_bear := bar_scr_bear > ta.highest(bar_scr_bear, bar_div_p)[1] and indi_scr < ta.highest(indi_scr, bar_div_p)[1]
        c_div_bull := bar_scr_bull < ta.lowest(bar_scr_bull, bar_div_p)[1] and indi_scr > ta.lowest(indi_scr, bar_div_p)[1]

        h_div_bear := bar_scr_bear < ta.highest(bar_scr_bear, bar_div_p)[1] and indi_scr > ta.highest(indi_scr, bar_div_p)[1]
        h_div_bull := bar_scr_bull > ta.lowest(bar_scr_bull, bar_div_p)[1] and indi_scr < ta.lowest(indi_scr, bar_div_p)[1]


plot_bear_combined = ON_DIV and (c_div_bear or h_div_bear)
plot_bull_combined = ON_DIV and (c_div_bull or h_div_bull)
if ON_DIV
    sig_div_bull := c_div_bull or h_div_bull
    sig_div_bear := c_div_bear or h_div_bear

plotshape(plot_bear_combined, style=shape.arrowdown, location=location.abovebar, offset=0, size= size.small,  textcolor=color.new(color.red, 0),  color=color.new(color.red, 0), title='Bear divergence')
plotshape(plot_bull_combined, style=shape.arrowup, location=location.belowbar, offset=0, size= size.small,  textcolor=color.new(color.green, 0), color=color.new(color.green, 0), title='Bull divergence')




//----------------------------------------------------------------- ema cloud / hma slope / dmi adx (Visuals for Chart) -------------------------------------------------------------------

ema1                = ta.ema(close, ema_inp1)
ema2                = ta.ema(close, ema_inp2)

// MA 1 Calculation & Logic
ma1_val = switch eff_ma1_type
    "SMA" => ta.sma(close, ma1_len)
    "EMA" => ta.ema(close, ma1_len)
    => na
// MA 1 Color Logic: Checked=Slope(Lime/Red), Unchecked=Red
ma1_col = ma1_slope_c ? (ma1_val >= ma1_val[1] ? color.lime : color.rgb(255, 20, 20)) : color.green
plot(eff_ma1_type != "None" ? ma1_val : na, color=ma1_col, linewidth=1, title="MA 1")

// MA 2 Calculation & Logic
ma2_val = switch eff_ma2_type
    "SMA" => ta.sma(close, ma2_len)
    "EMA" => ta.ema(close, ma2_len)
    => na
// MA 2 Color Logic: Checked=Slope(Lime/Red), Unchecked=Green
ma2_col = ma2_slope_c ? (ma2_val >= ma2_val[1] ? color.lime : color.rgb(255, 20, 20)) : color.red
plot(eff_ma2_type != "None" ? ma2_val : na, color=ma2_col, linewidth=1, title="MA 2")


ema_buy             = eff_en_cloud ? ema1 > ema2 : na
ema_sell            = eff_en_cloud ? ema1 < ema2 : na

if eff_en_cloud
    sig_ema_bull := ema_buy
    sig_ema_bear := ema_sell

ema1_pl             = plot(eff_en_cloud ? ema1 : na, color=color.new(color.blue, 100), title='EMA 1')
ema2_pl             = plot(eff_en_cloud ? ema2 : na, color=color.new(color.blue, 100), title='EMA 2')

fill(ema1_pl, ema2_pl, color=color.new(eff_sig_plot and not ema_buy[1] ? color_ema_sig_dn : eff_sig_plot and not ema_sell[1] ? color_ema_sig_up : color_ema_c, transp_ema_c))


//----------------------------------------------------------------- KAMA Calculation -------------------------------------------------------------------

// Function for KAMA
f_kama(_src, _len, _fast, _slow) =>
    _change = math.abs(_src - _src[_len])
    _volatility = math.sum(math.abs(_src - _src[1]), _len)
    _er = _volatility != 0 ? _change / _volatility : 0
    _sc = math.pow(_er * (2 / (_fast + 1) - 2 / (_slow + 1)) + 2 / (_slow + 1), 2)
    var float _kama = 0.0
    _kama := na(_kama[1]) ? _src : _kama[1] + _sc * (_src - _kama[1])
    _kama

kama_val = f_kama(close, kama_len, kama_fast, kama_slow)

// KAMA Signals (Slope Mode)
// Rising = Bullish, Falling = Bearish
bool kama_bull = kama_val > kama_val[1]
bool kama_bear = kama_val < kama_val[1]

sig_kama_bull := kama_bull
sig_kama_bear := kama_bear


//------------------------------------------------------------ trend lines (Visuals for Chart) ----------------------------------------------------------------

// Determine logic based on input
use_special_trend = fractalBarsPerSide == 0
// Force 2 (5-bar fractal) for special mode to ensure stability
n_tl = use_special_trend ? 2 : fractalBarsPerSide

// --- Detection using Pivot Functions ---
ph_val = ta.pivothigh(high, n_tl, n_tl)
pl_val = ta.pivotlow(low, n_tl, n_tl)

// --- State Variables (Pivot 0 = Newest, Pivot 1 = Old) ---
var float y0_up = na
var int x0_up = na
var float y1_up = na
var int x1_up = na

if not na(ph_val)
    y1_up := y0_up
    x1_up := x0_up
    y0_up := ph_val
    x0_up := bar_index - n_tl

var float y0_dn = na
var int x0_dn = na
var float y1_dn = na
var int x1_dn = na

if not na(pl_val)
    y1_dn := y0_dn
    x1_dn := x0_dn
    y0_dn := pl_val
    x0_dn := bar_index - n_tl

// --- Optimized Anchored Regression (O(1) Running Sums) ---

// Globale Running Sums for Up-Trend
var float sum_xy_up_run = 0.0
var float sum_x2_up_run = 0.0

// Globale Running Sums for Down-Trend
var float sum_xy_dn_run = 0.0
var float sum_x2_dn_run = 0.0

// Variables to track changes in pivots for reset logic
var int last_x0_up = na
var int last_x0_dn = na

// Drawing Objects
var line upper_line = na
var line lower_line = na

// STAGE 1: HYBRID HARD GATING
// We only run the heavy regression and drawing logic if enabled.
if eff_plot_trendline
    // LOGIC for Up-Trend Regression
    if use_special_trend
        // Check if new pivot detected (x0_up changed)
        if x0_up != last_x0_up
            // Reset sums
            sum_xy_up_run := 0.0
            sum_x2_up_run := 0.0

            // Backfill loop (Only runs once per new pivot, for n_tl bars)
            if not na(x0_up) and not na(y0_up)
                int start_idx = x0_up + 1
                int end_idx = bar_index - 1
                if end_idx >= start_idx
                    // Just loop forward conceptually using offset j from current bar
                    int j_max = bar_index - start_idx
                    for j = 1 to j_max
                        ops_trend += 1 // Count Ops
                        // Calculate terms
                        // Real Index: bar_index - j
                        int dx = (bar_index - j) - x0_up
                        float dy = high[j] - y0_up

                        sum_xy_up_run += (dx * dy)
                        sum_x2_up_run += (float(dx) * float(dx))

            last_x0_up := x0_up

        else
            // Incremental Update (Every bar)
            if not na(x0_up) and not na(y0_up)
                int dx = (bar_index - 1) - x0_up
                if dx > 0
                    float dy = high[1] - y0_up
                    sum_xy_up_run += (dx * dy)
                    sum_x2_up_run += (float(dx) * float(dx))

    // Calculate Slope Up
    slope_up = (use_special_trend and sum_x2_up_run != 0) ? sum_xy_up_run / sum_x2_up_run : na


    // LOGIC for Down-Trend Regression
    if use_special_trend
        if x0_dn != last_x0_dn
            // Reset
            sum_xy_dn_run := 0.0
            sum_x2_dn_run := 0.0
            last_x0_dn := x0_dn

            // Backfill
            if not na(x0_dn) and not na(y0_dn)
                int start_idx = x0_dn + 1
                int end_idx = bar_index - 1
                if end_idx >= start_idx
                    int j_max = bar_index - start_idx
                    for j = 1 to j_max
                        ops_trend += 1 // Count Ops
                        int dx = (bar_index - j) - x0_dn
                        float dy = low[j] - y0_dn
                        sum_xy_dn_run += (dx * dy)
                        sum_x2_dn_run += (float(dx) * float(dx))
        else
            // Incremental
            if not na(x0_dn) and not na(y0_dn)
                int dx = (bar_index - 1) - x0_dn
                if dx > 0
                    float dy = low[1] - y0_dn
                    sum_xy_dn_run += (dx * dy)
                    sum_x2_dn_run += (float(dx) * float(dx))

    // Calculate Slope Down
    slope_dn = (use_special_trend and sum_x2_dn_run != 0) ? sum_xy_dn_run / sum_x2_dn_run : na

    // --- Draw Trendlines ---
    // --- UPPER LINE ---
    // Mode 0: Start=Newest(x0), Slope based calculation
    // Mode >0: Start=Old(x1), End=Newest(x0)

    x1_u = use_special_trend ? x0_up : x1_up
    y1_u = use_special_trend ? y0_up : y1_up

    x2_u = use_special_trend ? bar_index - 1 : x0_up
    // Calculate Y2 based on Slope for Mode 0, or plain value for Mode >0
    float y2_u = na
    if use_special_trend
        if not na(slope_up) and not na(x0_up)
            // y = mx + b -> y2 = slope * distance + start_y
            y2_u := y0_up + slope_up * (x2_u - x0_up)
    else
        y2_u := y0_up

    // Draw
    if not na(x1_u) and not na(x2_u) and x1_u != x2_u and not na(y2_u)
        if na(upper_line)
            upper_line := line.new(x1 = x1_u, y1 = y1_u, x2 = x2_u, y2 = y2_u, extend = extend.right, color = color.new(color_tr, transp_tr), style = line.style_solid, width = width_tr)
        else
            line.set_xy1(upper_line, x1_u, y1_u)
            line.set_xy2(upper_line, x2_u, y2_u)
            line.set_color(upper_line, color.new(color_tr, transp_tr))
            line.set_width(upper_line, width_tr)

    // --- LOWER LINE ---
    x1_d = use_special_trend ? x0_dn : x1_dn
    y1_d = use_special_trend ? y0_dn : y1_dn

    x2_d = use_special_trend ? bar_index - 1 : x0_dn
    float y2_d = na
    if use_special_trend
        if not na(slope_dn) and not na(x0_dn)
            y2_d := y0_dn + slope_dn * (x2_d - x0_dn)
    else
        y2_d := y0_dn

    if not na(x1_d) and not na(x2_d) and x1_d != x2_d and not na(y2_d)
        if na(lower_line)
            lower_line := line.new(x1 = x1_d, y1 = y1_d, x2 = x2_d, y2 = y2_d, extend = extend.right, color = color.new(color_tr, transp_tr), style = line.style_solid, width = width_tr)
        else
            line.set_xy1(lower_line, x1_d, y1_d)
            line.set_xy2(lower_line, x2_d, y2_d)
            line.set_color(lower_line, color.new(color_tr, transp_tr))
            line.set_width(lower_line, width_tr)

    // --- Signal Logic for Registry (Trendlines) ---
    // Calculate current projected level
    float cur_y_up = na
    float cur_y_dn = na

    if use_special_trend
        if not na(slope_up) and not na(x0_up)
            cur_y_up := y0_up + slope_up * (bar_index - x0_up)
        if not na(slope_dn) and not na(x0_dn)
            cur_y_dn := y0_dn + slope_dn * (bar_index - x0_dn)
    else
        // Classic
        if not na(x1_u) and not na(x0_up) and x1_u != x0_up
            m_u = (y0_up - y1_u) / (x0_up - x1_u)
            cur_y_up := y1_u + m_u * (bar_index - x1_u)
        if not na(x1_d) and not na(x0_dn) and x1_d != x0_dn
            m_d = (y0_dn - y1_d) / (x0_dn - x1_d)
            cur_y_dn := y1_d + m_d * (bar_index - x1_d)

    // Update Registry
    if not na(cur_y_up) and close > cur_y_up
        sig_tl_bull := true
    if not na(cur_y_dn) and close < cur_y_dn
        sig_tl_bear := true

else
    // Cleanup & State Reset (Crucial for Resuming)
    if not na(last_x0_up)
        last_x0_up := na
        last_x0_dn := na

    if not na(upper_line)
        line.delete(upper_line)
        upper_line := na
    if not na(lower_line)
        line.delete(lower_line)
        lower_line := na


//----------------------------------------------------------- last 12 bar (Visuals for Chart) ----------------------------------------------------------

l12_long = ta.highest(low, L12_input)
l12_short = ta.lowest(high, L12_input)

var bool long_plotted = na
var bool short_plotted = na

// Determine the actual signal trigger point
plot_l12_long = low == l12_long and (na(short_plotted) or short_plotted)
plot_l12_short = high == l12_short and (na(long_plotted) or long_plotted)

if plot_l12_long
    long_plotted := true
    short_plotted := false

if plot_l12_short
    short_plotted := true
    long_plotted := false

plotchar(eff_plot_l12_bar and plot_l12_long ? l12_long : na, char='L', location=location.belowbar, color=color.new(color.blue, 0), title='L12 long bar')
plotchar(eff_plot_l12_bar and plot_l12_short ? l12_short : na, char='L', location=location.abovebar, color=color.new(color.red, 0), title='L12 short bar')


//----------------------------------------------------------- narrow range bar / anticipated fractal (Visuals for Chart)----------------------------------------------------------

// --- Narrow Range Bar (NR7) ---
p_nr_bar = high - low
bar_1 = high[1] - low[1]
bar_2 = high[2] - low[2]
bar_3 = high[3] - low[3]
bar_4 = high[4] - low[4]
bar_5 = high[5] - low[5]
bar_6 = high[6] - low[6]
bar_7 = high[7] - low[7]

nr_bar = p_nr_bar < bar_1 and p_nr_bar < bar_2 and p_nr_bar < bar_3 and p_nr_bar < bar_4 and p_nr_bar < bar_5 and p_nr_bar < bar_6

plotchar(eff_plot_nr_bar and nr_bar, char='n', location=location.belowbar, color=color.new(color.gray, 0), title='NR bar')


// --- Anticipated Fractal Logic ---
af_up = high > high[1] and high > high[2]
af_dn = low < low[1] and low < low[2]

var int last_af_state = 0

bool plot_blue_a_now = false
bool plot_red_a_now = false


if af_up and (last_af_state == 0 or last_af_state == -1)
    plot_blue_a_now := true
    last_af_state := 1

else if af_dn and (last_af_state == 0 or last_af_state == 1)
    plot_red_a_now := true
    last_af_state := -1


//----------------------------------------------- inside bar / outside bar / sandwich bar / pin bar / fakey ---------------------------------------------

i_bar       = high < high[1] and low > low[1]

o_bar       = high > high[1] and low < low[1]

o_bar_color = close > high[1] ? color.new(color.red, 0) : close < low[1] ? color.new(color.green, 0) :color.new(color.gray, 0)

s_bar       = high[1] < high[2] and low[1] > low[2] and high > high[1] and low < low[1]

f_up_e      = i_bar[1] and low < low[1] and close > open[1] and close > open or i_bar[2] and close[1] < low[2] and close > close[1] and high > high[1] or i_bar[1] and low < low[2] and close > close[1] and close > open or i_bar[2] and close[1] < low[3] and close > open and close > open[1]
f_dn_e      = i_bar[1] and high > high[1] and close < open[1] and close < open or i_bar[2] and close[1] > high[2] and close < close[1] and low < low[1] or i_bar[1] and high > high[2] and close < open and close < close[1] or i_bar[2] and close[1] > high[3] and close < open and close < close[1]


i_bar_1 = high[1] < high[2] and low[1] > low[2]
i_bar_2 = high[2] < high[3] and low[2] > low[3]
i_bar_3 = high[3] < high[4] and low[3] > low[4]
i_bar_4 = high[4] < high[5] and low[4] > low[5]

f_up_b = ((i_bar_1 and low < low[1] and close > high[1]) or (i_bar_2 and low < low[2] and close > high[2]) or (i_bar_3 and low < low[3] and close > high[3]) or (i_bar_4 and low < low[4] and close > high[4]))
f_up = f_up_b and not f_up_b[1]

f_dn_b = ((i_bar_1 and high > high[1] and close < low[1]) or (i_bar_2 and high > high[2] and close < low[2]) or (i_bar_3 and high > high[3] and close < low[3]) or (i_bar_4 and high > high[4] and close < low[4]))
f_dn = f_dn_b and not f_dn_b[1]


plotchar(eff_plot_i_bar ? i_bar : na, char='i', location=location.abovebar, color=color.new(color.gray, 0), title='I bar')
plotchar(eff_plot_o_bar ? o_bar : na, char='o', location=location.abovebar, color=o_bar_color, title='O bar')
plotchar(eff_plot_s_bar ? s_bar : na, char='s', location=location.abovebar, color=color.new(color.silver, 0), offset=-1, title='S bar')

plotchar(eff_plot_f_bar ? f_up and (not f_up[1] or not f_up[2] or not f_up[3]) or f_up_e and not f_up : na, char='F', location=location.belowbar, color=color.new(color.blue, 0), title='F bar up')
plotchar(eff_plot_f_bar ? f_dn and (not f_dn[1] or not f_dn[2] or not f_dn[3]) or f_dn_e and not f_dn : na, char='F', location=location.abovebar, color=color.new(color.red, 0), title='F bar down')

// Registry Updates
if eff_plot_l12_bar
    sig_l12_bull := plot_l12_long
    sig_l12_bear := plot_l12_short

if eff_plot_f_bar
    sig_pat_bull := f_up
    sig_pat_bear := f_dn

if eff_plot_o_bar
    // Green O (Long) -> Bullish
    if o_bar and close < low[1]
        sig_o_bull := true
    // Red O (Short) -> Bearish
    if o_bar and close > high[1]
        sig_o_bear := true


//----------------------------------------------------------------- segments (Visuals for Chart) --------------------------------------------------------------

count1_l                    = 0
count2_l                    = 0
segment_1_stat_l            = false
segment_2_stat_l            = false
segment_3_stat_l            = false

var line segment_low_1_l    = na
var line segment_low_2_l    = na
var line segment_low_3_l    = na

count1_s                    = 0
count2_s                    = 0
segment_1_stat_s            = false
segment_2_stat_s            = false
segment_3_stat_s            = false

var line segment_high_1     = na
var line segment_high_2     = na
var line segment_high_3     = na

// Stage 5: Segments Optimization (Bar Close Only)
// Only run the heavy loops when the bar is confirmed (historical bars or realtime bar close)
if eff_plot_segments and barstate.isconfirmed
    // long segments
    for i = 0 to sb by 1
        count1_l := count1_l + 1
        if low[1] > low[i + 2]
            segment_low_1_l := line.new(x1=bar_index[2 + i], y1=low[2 + i], x2=bar_index[1], y2=low[1], color=color.new(color_seg, transp_seg), width=3)
            segment_1_stat_l := true
            break

    for i = count1_l to sb + count1_l by 1
        count2_l := count2_l + 1
        if low[1 + count1_l] > low[i + 2] and segment_1_stat_l
            segment_low_2_l := line.new(x1=bar_index[2 + i], y1=low[2 + i], x2=bar_index[1 + count1_l], y2=low[1 + count1_l], color=color.new(color_seg, transp_seg), width=2)
            segment_2_stat_l := true
            break

    for i = count2_l to sb + count2_l by 1
        if low[1 + count1_l + count2_l] > low[i + 2 + count1_l] and segment_2_stat_l
            segment_low_3_l := line.new(x1=bar_index[i + 2 + count1_l], y1=low[i + 2 + count1_l], x2=bar_index[1 + count1_l + count2_l], y2=low[1 + count1_l + count2_l], color=color.new(color_seg, transp_seg), width=1)
            segment_3_stat_l := true
            break

    line.delete(segment_low_1_l[1])
    line.delete(segment_low_2_l[1])
    line.delete(segment_low_3_l[1])


    // short segments
    for i = 0 to sb by 1
        count1_s := count1_s + 1
        if high[1] < high[i + 2]
            segment_high_1 := line.new(x1=bar_index[2 + i], y1=high[2 + i], x2=bar_index[1], y2=high[1], color=color.new(color_seg, transp_seg), width=3)
            segment_1_stat_s := true
            break

    for i = count1_s to sb + count1_s by 1
        count2_s := count2_s + 1
        if high[1 + count1_s] < high[i + 2] and segment_1_stat_s
            segment_high_2 := line.new(x1=bar_index[2 + i], y1=high[2 + i], x2=bar_index[1 + count1_s], y2=high[1 + count1_s], color=color.new(color_seg, transp_seg), width=2)
            segment_2_stat_s := true
            break

    for i = count2_s to sb + count2_s by 1
        if high[1 + count1_s + count2_s] < high[i + 2 + count1_s] and segment_2_stat_s
            segment_high_3 := line.new(x1=bar_index[i + 2 + count1_s], y1=high[i + 2 + count1_s], x2=bar_index[1 + count1_s + count2_s], y2=high[1 + count1_s + count2_s], color=color.new(color_seg, transp_seg), width=1)
            segment_3_stat_s := true
            break

    line.delete(segment_high_1[1])
    line.delete(segment_high_2[1])
    line.delete(segment_high_3[1])

    // --- Signal Logic for Registry (Segments) ---
    // Segments Signal:
    // Buy: High > High[1] AND 3 Long Segments Active
    // Sell: Low < Low[1] AND 3 Short Segments Active
    // Note: segment_*_stat_* variables are local to this block.
    // We reuse the logic:

    // We need to re-verify state if not already captured.
    // Actually, segment_3_stat_l is only true if we found 3 segments.
    // Buy Signal: high > high[1] and segment_1_stat_l and segment_2_stat_l and segment_3_stat_l

    if high > high[1] and segment_3_stat_l
        sig_seg_bull := true

    if low < low[1] and segment_3_stat_s
        sig_seg_bear := true




//-------------------------------------------------------------------- info panel -------------------------------------------------------------------------

//indicator funktions for 4h, d, w, m

// Helper function for Panel State
f_panel_state() =>
    // FVG Close State
    var int fvg_state = 0
    fvg_state := low > high[2] ? 1 : high < low[2] ? -1 : fvg_state

    // Bill Williams Fractals State
    // Standard 2,2 fractals
    up_fr = ta.pivothigh(2, 2)
    dn_fr = ta.pivotlow(2, 2)

    last_up_lvl = ta.valuewhen(not na(up_fr), high[2], 0)
    last_dn_lvl = ta.valuewhen(not na(dn_fr), low[2], 0)

    var int fr_state = 0
    // Check breaks
    fr_state := ta.crossover(high, last_up_lvl) ? 1 : ta.crossunder(low, last_dn_lvl) ? -1 : fr_state

    bool tf_is_confirmed = barstate.isconfirmed

    [fvg_state, fr_state, tf_is_confirmed]

//colors
color_blue_1    = color.new(color.blue, 30)
color_red_1     = color.new(color.red, 30)
color_gray_1    = color.new(color.gray, 100)

//current tf condition for adx, hama and ema
// RECALC for info panel table to ensure it matches current chart regardless of bg signal

//mtf time frames
Intra           = timeframe.isintraday
Intra_D         = timeframe.isintraday or timeframe.isdaily
Intra_D_W       = timeframe.isintraday or timeframe.isdaily or timeframe.isweekly
Intra_D_W_M     = timeframe.isintraday or timeframe.isdaily or timeframe.isweekly or timeframe.ismonthly

// Stage 6: Info Panel Refactoring (Global Current TF + Gated HTF)

// 1. Always Run Current TF (To prevent warm-up issues)
atr14_val             = ta.atr(14)

// Global Current TF Logic (Additions)
// FVG
var int fvg_state_inf = 0
if low > high[2]
    fvg_state_inf := 1
else if high < low[2]
    fvg_state_inf := -1

// Fractals
up_fr_inf = ta.pivothigh(2, 2)
dn_fr_inf = ta.pivotlow(2, 2)
last_up_lvl_inf = ta.valuewhen(not na(up_fr_inf), high[2], 0)
last_dn_lvl_inf = ta.valuewhen(not na(dn_fr_inf), low[2], 0)
var int fr_state_inf = 0
if ta.crossover(high, last_up_lvl_inf)
    fr_state_inf := 1
else if ta.crossunder(low, last_dn_lvl_inf)
    fr_state_inf := -1

fvg_color_c     = fvg_state_inf == 1 ? color_blue_1 : fvg_state_inf == -1 ? color_red_1 : color_gray_1
fr_color_c      = fr_state_inf == 1 ? color_blue_1 : fr_state_inf == -1 ? color_red_1 : color_gray_1

// Info Panel Table (Declared global to allow deletion)
var table info_panel = na

// Define Variables for HTF colors (Init to default)
// FVG Colors
color fvg_color_5m  = na
color fvg_color_15m = na
color fvg_color_1h  = na
color fvg_color_4h  = na
color fvg_color_d   = na
color fvg_color_w   = na
color fvg_color_m   = na

// FR Colors
color fr_color_5m  = na
color fr_color_15m = na
color fr_color_1h  = na
color fr_color_4h  = na
color fr_color_d   = na
color fr_color_w   = na
color fr_color_m   = na

var int fvg_5m_conf = na
var int fvg_15m_conf = na
var int fvg_1h_conf = na
var int fvg_4h_conf = na
var int fvg_d_conf = na
var int fvg_w_conf = na
var int fvg_m_conf = na

var int fr_5m_conf = na
var int fr_15m_conf = na
var int fr_1h_conf = na
var int fr_4h_conf = na
var int fr_d_conf = na
var int fr_w_conf = na
var int fr_m_conf = na

var int fvg_c_conf = na
var int fr_c_conf = na

// 2. Gated HTF & Table Update
if panel_pos != "None" and barstate.islast // Stage 5: Last-Bar Gating for Security & Logic
    // Optimization: Combine security calls for Info Panel (7 calls)
    // Using global input parameters for all timeframes as requested
    [fvg_5m, fr_5m, conf_5m]   = request.security(syminfo.tickerid, '5',   f_panel_state())
    [fvg_15m, fr_15m, conf_15m] = request.security(syminfo.tickerid, '15',  f_panel_state())
    [fvg_1h, fr_1h, conf_1h]   = request.security(syminfo.tickerid, '60',  f_panel_state())
    [fvg_4h, fr_4h, conf_4h]   = request.security(syminfo.tickerid, '240', f_panel_state())
    [fvg_d, fr_d, conf_d]     = request.security(syminfo.tickerid, 'D',   f_panel_state())
    [fvg_w, fr_w, conf_w]     = request.security(syminfo.tickerid, 'W',   f_panel_state())
    [fvg_m, fr_m, conf_m]     = request.security(syminfo.tickerid, 'M',   f_panel_state())

    // Stage 6: Debug Instrument
    active_sec_calls += 7

    fvg_5m_conf := nz(fvg_5m_conf, fvg_5m)
    fr_5m_conf := nz(fr_5m_conf, fr_5m)
    fvg_15m_conf := nz(fvg_15m_conf, fvg_15m)
    fr_15m_conf := nz(fr_15m_conf, fr_15m)
    fvg_1h_conf := nz(fvg_1h_conf, fvg_1h)
    fr_1h_conf := nz(fr_1h_conf, fr_1h)
    fvg_4h_conf := nz(fvg_4h_conf, fvg_4h)
    fr_4h_conf := nz(fr_4h_conf, fr_4h)
    fvg_d_conf := nz(fvg_d_conf, fvg_d)
    fr_d_conf := nz(fr_d_conf, fr_d)
    fvg_w_conf := nz(fvg_w_conf, fvg_w)
    fr_w_conf := nz(fr_w_conf, fr_w)
    fvg_m_conf := nz(fvg_m_conf, fvg_m)
    fr_m_conf := nz(fr_m_conf, fr_m)

    fvg_5m_conf := conf_5m ? fvg_5m : fvg_5m_conf
    fr_5m_conf := conf_5m ? fr_5m : fr_5m_conf
    fvg_15m_conf := conf_15m ? fvg_15m : fvg_15m_conf
    fr_15m_conf := conf_15m ? fr_15m : fr_15m_conf
    fvg_1h_conf := conf_1h ? fvg_1h : fvg_1h_conf
    fr_1h_conf := conf_1h ? fr_1h : fr_1h_conf
    fvg_4h_conf := conf_4h ? fvg_4h : fvg_4h_conf
    fr_4h_conf := conf_4h ? fr_4h : fr_4h_conf
    fvg_d_conf := conf_d ? fvg_d : fvg_d_conf
    fr_d_conf := conf_d ? fr_d : fr_d_conf
    fvg_w_conf := conf_w ? fvg_w : fvg_w_conf
    fr_w_conf := conf_w ? fr_w : fr_w_conf
    fvg_m_conf := conf_m ? fvg_m : fvg_m_conf
    fr_m_conf := conf_m ? fr_m : fr_m_conf

    fvg_c_conf := nz(fvg_c_conf, fvg_state_inf)
    fr_c_conf := nz(fr_c_conf, fr_state_inf)
    bool ctf_conf = barstate.isconfirmed or not barstate.isrealtime
    fvg_c_conf := ctf_conf ? fvg_state_inf : fvg_c_conf
    fr_c_conf := ctf_conf ? fr_state_inf : fr_c_conf

    string m_5m = f_marker(panel_show_live, conf_5m)
    string m_15m = f_marker(panel_show_live, conf_15m)
    string m_1h = f_marker(panel_show_live, conf_1h)
    string m_4h = f_marker(panel_show_live, conf_4h)
    string m_d = f_marker(panel_show_live, conf_d)
    string m_w = f_marker(panel_show_live, conf_w)
    string m_m = f_marker(panel_show_live, conf_m)
    string m_c = f_marker(panel_show_live and barstate.isrealtime, ctf_conf)

    int fvg_disp_5m = panel_show_live ? fvg_5m : fvg_5m_conf
    int fr_disp_5m = panel_show_live ? fr_5m : fr_5m_conf
    int fvg_disp_15m = panel_show_live ? fvg_15m : fvg_15m_conf
    int fr_disp_15m = panel_show_live ? fr_15m : fr_15m_conf
    int fvg_disp_1h = panel_show_live ? fvg_1h : fvg_1h_conf
    int fr_disp_1h = panel_show_live ? fr_1h : fr_1h_conf
    int fvg_disp_4h = panel_show_live ? fvg_4h : fvg_4h_conf
    int fr_disp_4h = panel_show_live ? fr_4h : fr_4h_conf
    int fvg_disp_d = panel_show_live ? fvg_d : fvg_d_conf
    int fr_disp_d = panel_show_live ? fr_d : fr_d_conf
    int fvg_disp_w = panel_show_live ? fvg_w : fvg_w_conf
    int fr_disp_w = panel_show_live ? fr_w : fr_w_conf
    int fvg_disp_m = panel_show_live ? fvg_m : fvg_m_conf
    int fr_disp_m = panel_show_live ? fr_m : fr_m_conf
    int fvg_disp_c = panel_show_live ? fvg_state_inf : fvg_c_conf
    int fr_disp_c = panel_show_live ? fr_state_inf : fr_c_conf

    // --- Color Logic ---
    // FVG
    fvg_color_5m  := fvg_disp_5m == 1 ? color_blue_1 : fvg_disp_5m == -1 ? color_red_1 : color_gray_1
    fvg_color_15m := fvg_disp_15m == 1 ? color_blue_1 : fvg_disp_15m == -1 ? color_red_1 : color_gray_1
    fvg_color_1h  := fvg_disp_1h == 1 ? color_blue_1 : fvg_disp_1h == -1 ? color_red_1 : color_gray_1
    fvg_color_4h  := fvg_disp_4h == 1 ? color_blue_1 : fvg_disp_4h == -1 ? color_red_1 : color_gray_1
    fvg_color_d   := fvg_disp_d == 1 ? color_blue_1 : fvg_disp_d == -1 ? color_red_1 : color_gray_1
    fvg_color_w   := fvg_disp_w == 1 ? color_blue_1 : fvg_disp_w == -1 ? color_red_1 : color_gray_1
    fvg_color_m   := fvg_disp_m == 1 ? color_blue_1 : fvg_disp_m == -1 ? color_red_1 : color_gray_1

    // FR (Fractals)
    fr_color_5m   := fr_disp_5m == 1 ? color_blue_1 : fr_disp_5m == -1 ? color_red_1 : color_gray_1
    fr_color_15m  := fr_disp_15m == 1 ? color_blue_1 : fr_disp_15m == -1 ? color_red_1 : color_gray_1
    fr_color_1h   := fr_disp_1h == 1 ? color_blue_1 : fr_disp_1h == -1 ? color_red_1 : color_gray_1
    fr_color_4h   := fr_disp_4h == 1 ? color_blue_1 : fr_disp_4h == -1 ? color_red_1 : color_gray_1
    fr_color_d    := fr_disp_d == 1 ? color_blue_1 : fr_disp_d == -1 ? color_red_1 : color_gray_1
    fr_color_w    := fr_disp_w == 1 ? color_blue_1 : fr_disp_w == -1 ? color_red_1 : color_gray_1
    fr_color_m    := fr_disp_m == 1 ? color_blue_1 : fr_disp_m == -1 ? color_red_1 : color_gray_1
    fvg_color_c   := fvg_disp_c == 1 ? color_blue_1 : fvg_disp_c == -1 ? color_red_1 : color_gray_1
    fr_color_c    := fr_disp_c == 1 ? color_blue_1 : fr_disp_c == -1 ? color_red_1 : color_gray_1

    // Stage 7: TF Highlight Logic (Optimized with var)
    var color col_tf_highlight = color.new(color.yellow, 75)
    var int cur_sec = timeframe.in_seconds(timeframe.period)

    // Exact matches (Cached)
    var bool is_5m  = cur_sec == timeframe.in_seconds("5")
    var bool is_15m = cur_sec == timeframe.in_seconds("15")
    var bool is_1h  = cur_sec == timeframe.in_seconds("60")
    var bool is_4h  = cur_sec == timeframe.in_seconds("240")
    var bool is_1d  = cur_sec == timeframe.in_seconds("D")
    var bool is_1w  = cur_sec == timeframe.in_seconds("W")
    var bool is_1m  = cur_sec == timeframe.in_seconds("M")

    // If none match, highlight "Current"
    var bool is_custom_tf = not (is_5m or is_15m or is_1h or is_4h or is_1d or is_1w or is_1m)

    string pos_input = panel_pos == "Top Right" ? position.top_right : panel_pos == "Bottom Right" ? position.bottom_right : position.bottom_left
    info_panel := na(info_panel) ? table.new(position = pos_input, columns = PANEL_COLS, rows = PANEL_ROWS, bgcolor=color.new(color.blue, 95), frame_width=1, border_width=1, frame_color=color.new(color.black, 50), border_color=color.new(color.black, 50)) : info_panel

    // HEADER NAMES (Row 0)
    table.cell(table_id=info_panel, column=0, row=0, text="TF", text_size= size.small, text_color=color.silver)
    table.cell(table_id=info_panel, column=1, row=0, text= "FVG", text_size= size.small, text_color=color.silver)
    table.cell(table_id=info_panel, column=2, row=0, text= "FR", text_size= size.small, text_color=color.silver)

    // 1M (Row 1)
    table.cell(table_id=info_panel, column=0, row=1, text="1M", text_size= size.small, text_color=color.silver, bgcolor=is_1m ? col_tf_highlight : na)
    table.cell(table_id=info_panel, column=1, row=1, text=m_m, text_size=size.small, text_color=MARKER_COLOR, bgcolor=(Intra_D_W_M) ? fvg_color_m : na, width=2)
    table.cell(table_id=info_panel, column=2, row=1, text=m_m, text_size=size.small, text_color=MARKER_COLOR, bgcolor=(Intra_D_W_M) ? fr_color_m : na, width=2)

    // 1W (Row 2)
    table.cell(table_id=info_panel, column=0, row=2, text="1W", text_size= size.small, text_color=color.silver, bgcolor=is_1w ? col_tf_highlight : na)
    table.cell(table_id=info_panel, column=1, row=2, text=m_w, text_size=size.small, text_color=MARKER_COLOR, bgcolor=(Intra_D_W) ? fvg_color_w : na, width=2)
    table.cell(table_id=info_panel, column=2, row=2, text=m_w, text_size=size.small, text_color=MARKER_COLOR, bgcolor=(Intra_D_W) ? fr_color_w : na, width=2)

    // 1D (Row 3)
    table.cell(table_id=info_panel, column=0, row=3, text="1D", text_size= size.small, text_color=color.silver, bgcolor=is_1d ? col_tf_highlight : na)
    table.cell(table_id=info_panel, column=1, row=3, text=m_d, text_size=size.small, text_color=MARKER_COLOR, bgcolor=(Intra_D) ? fvg_color_d : na, width=2)
    table.cell(table_id=info_panel, column=2, row=3, text=m_d, text_size=size.small, text_color=MARKER_COLOR, bgcolor=(Intra_D) ? fr_color_d : na, width=2)

    // 4H (Row 4)
    table.cell(table_id=info_panel, column=0, row=4, text="4H", text_size= size.small, text_color=color.silver, bgcolor=is_4h ? col_tf_highlight : na)
    table.cell(table_id=info_panel, column=1, row=4, text=m_4h, text_size=size.small, text_color=MARKER_COLOR, bgcolor=Intra ? fvg_color_4h : na, width=2)
    table.cell(table_id=info_panel, column=2, row=4, text=m_4h, text_size=size.small, text_color=MARKER_COLOR, bgcolor=Intra ? fr_color_4h : na, width=2)

    // 1H (Row 5)
    table.cell(table_id=info_panel, column=0, row=5, text="1H", text_size= size.small, text_color=color.silver, bgcolor=is_1h ? col_tf_highlight : na)
    table.cell(table_id=info_panel, column=1, row=5, text=m_1h, text_size=size.small, text_color=MARKER_COLOR, bgcolor=Intra ? fvg_color_1h : na, width=2)
    table.cell(table_id=info_panel, column=2, row=5, text=m_1h, text_size=size.small, text_color=MARKER_COLOR, bgcolor=Intra ? fr_color_1h : na, width=2)

    // 15m (Row 6)
    table.cell(table_id=info_panel, column=0, row=6, text="15m", text_size= size.small, text_color=color.silver, bgcolor=is_15m ? col_tf_highlight : na)
    table.cell(table_id=info_panel, column=1, row=6, text=m_15m, text_size=size.small, text_color=MARKER_COLOR, bgcolor=Intra ? fvg_color_15m : na, width=2)
    table.cell(table_id=info_panel, column=2, row=6, text=m_15m, text_size=size.small, text_color=MARKER_COLOR, bgcolor=Intra ? fr_color_15m : na, width=2)

    // 5m (Row 7)
    table.cell(table_id=info_panel, column=0, row=7, text="5m", text_size= size.small, text_color=color.silver, bgcolor=is_5m ? col_tf_highlight : na)
    table.cell(table_id=info_panel, column=1, row=7, text=m_5m, text_size=size.small, text_color=MARKER_COLOR, bgcolor=Intra ? fvg_color_5m : na, width=2)
    table.cell(table_id=info_panel, column=2, row=7, text=m_5m, text_size=size.small, text_color=MARKER_COLOR, bgcolor=Intra ? fr_color_5m : na, width=2)

    // ATR14 (Row 8)
    table.cell(table_id=info_panel, column=0, row=8, text="ATR14 " + str.tostring(atr14_val, "#.#####"), text_size= size.small, text_color=color.silver)
    table.merge_cells(info_panel, 0, 8, 2, 8)

    // ADR% (Row 9) - Initial Placeholder (Filled later)
    table.cell(table_id=info_panel, column=0, row=9, text="ADR%", text_size= size.small, text_color=color.silver)
    table.merge_cells(info_panel, 0, 9, 2, 9)

    // HEADER (Row 10: Current)
    table.cell(table_id=info_panel, column=0, row=10, text="C", text_size= size.small, text_color=color.silver, bgcolor=is_custom_tf ? col_tf_highlight : na)
    table.cell(table_id=info_panel, column=1, row=10, text=m_c, text_size=size.small, text_color=MARKER_COLOR, bgcolor=(Intra_D_W_M) ? fvg_color_c : na, width=2)
    table.cell(table_id=info_panel, column=2, row=10, text=m_c, text_size=size.small, text_color=MARKER_COLOR, bgcolor=(Intra_D_W_M) ? fr_color_c : na, width=2)
else
    if not na(info_panel)
        table.delete(info_panel)
        info_panel := na


// ----------------------------------------------------------- pivot points -----------------------------------------------------------------

// Optimierte Datenabfrage (Tuples), um das "Security Limit" von 40 nicht zu sprengen
// Wir holen High, Low und Close in EINEM Aufruf pro Timeframe statt in drei.

// Stage 1: Pivot Points Optimization
// Strict Gating: request.security only if input is active AND timeframe is valid

// Conditions (Visibility)
cond_h1 = timeframe.isintraday and timeframe.multiplier < 60
cond_h4 = timeframe.isintraday and timeframe.multiplier < 240


// Need Flags
need_h1 = eff_plot_pivots_h1 and cond_h1
need_h4 = eff_plot_pivots_h4 and cond_h4
need_d  = eff_plot_pivots_d  and Intra
need_w  = eff_plot_pivots_w  and Intra_D
need_m  = eff_plot_pivots_m  and Intra_D_W
need_3m = eff_plot_pivots_3m and Intra_D_W_M
need_12m= eff_plot_pivots_12m and Intra_D_W_M

// Data Variables (Initial NA)
float h1_high = na
float h1_low = na
float h1_close = na

float h4_high = na
float h4_low = na
float h4_close = na

float d_high = na
float d_low = na
float d_close = na

float w_high = na
float w_low = na
float w_close = na

float m_high = na
float m_low = na
float m_close = na

float m3_high = na
float m3_low = na
float m3_close = na

float m12_high = na
float m12_low = na
float m12_close = na

// Gated Security Calls - Stage 5: Last Bar Optimization
if barstate.islast
    if need_h1
        [h1_high_t, h1_low_t, h1_close_t] = request.security(syminfo.tickerid, "60", [high[1], low[1], close[1]])
        h1_high := h1_high_t
        h1_low := h1_low_t
        h1_close := h1_close_t
        active_sec_calls += 1

    if need_h4
        [h4_high_t, h4_low_t, h4_close_t] = request.security(syminfo.tickerid, "240", [high[1], low[1], close[1]])
        h4_high := h4_high_t
        h4_low := h4_low_t
        h4_close := h4_close_t
        active_sec_calls += 1

    if need_d
        [d_high_t, d_low_t, d_close_t] = request.security(syminfo.tickerid, "D", [high[1], low[1], close[1]])
        d_high := d_high_t
        d_low := d_low_t
        d_close := d_close_t
        active_sec_calls += 1

    if need_w
        [w_high_t, w_low_t, w_close_t] = request.security(syminfo.tickerid, "W", [high[1], low[1], close[1]])
        w_high := w_high_t
        w_low := w_low_t
        w_close := w_close_t
        active_sec_calls += 1

    if need_m
        [m_high_t, m_low_t, m_close_t] = request.security(syminfo.tickerid, "M", [high[1], low[1], close[1]])
        m_high := m_high_t
        m_low := m_low_t
        m_close := m_close_t
        active_sec_calls += 1

    if need_3m
        [m3_high_t, m3_low_t, m3_close_t] = request.security(syminfo.tickerid, "3M", [high[1], low[1], close[1]])
        m3_high := m3_high_t
        m3_low := m3_low_t
        m3_close := m3_close_t
        active_sec_calls += 1

    if need_12m
        [m12_high_t, m12_low_t, m12_close_t] = request.security(syminfo.tickerid, "12M", [high[1], low[1], close[1]])
        m12_high := m12_high_t
        m12_low := m12_low_t
        m12_close := m12_close_t
        active_sec_calls += 1

// --- Calculations ---

// H1 pivot points
h1_PP           = (h1_high + h1_low + h1_close) / 3
h1_R1           = h1_PP + h1_PP - h1_low
h1_R2           = h1_PP + h1_high - h1_low
h1_R3           = h1_high + 2 * (h1_PP - h1_low)
h1_R4           = h1_PP + 3 * (h1_high - h1_low)
h1_S1           = h1_PP - (h1_high - h1_PP)
h1_S2           = h1_PP - (h1_high - h1_low)
h1_S3           = h1_low - 2 * (h1_high - h1_PP)
h1_S4           = h1_PP - 3 * (h1_high - h1_low)

// H4 pivot points
h4_PP           = (h4_high + h4_low + h4_close) / 3
h4_R1           = h4_PP + h4_PP - h4_low
h4_R2           = h4_PP + h4_high - h4_low
h4_R3           = h4_high + 2 * (h4_PP - h4_low)
h4_R4           = h4_PP + 3 * (h4_high - h4_low)
h4_S1           = h4_PP - (h4_high - h4_PP)
h4_S2           = h4_PP - (h4_high - h4_low)
h4_S3           = h4_low - 2 * (h4_high - h4_PP)
h4_S4           = h4_PP - 3 * (h4_high - h4_low)

// Daily pivot points
d_PP            = (d_high + d_low + d_close) / 3

w_PP            = (w_high + w_low + w_close) / 3
m_PP            = (m_high + m_low + m_close) / 3
m3_PP           = (m3_high + m3_low + m3_close) / 3
m12_PP          = (m12_high + m12_low + m12_close) / 3

// Daily R/S (extended to 4)
d_R1            = d_PP + d_PP - d_low
d_R2            = d_PP + d_high - d_low
d_R3            = d_high + 2 * (d_PP - d_low)
d_R4            = d_PP + 3 * (d_high - d_low)

d_S1            = d_PP - (d_high - d_PP)
d_S2            = d_PP - (d_high - d_low)
d_S3            = d_low - 2 * (d_high - d_PP)
d_S4            = d_PP - 3 * (d_high - d_low)

// weekly R/S pivot points (extended to 4)
w_R1            = w_PP + w_PP - w_low
w_R2            = w_PP + w_high - w_low
w_R3            = w_high + 2 * (w_PP - w_low)
w_R4            = w_PP + 3 * (w_high - w_low)

w_S1            = w_PP - (w_high - w_PP)
w_S2            = w_PP - (w_high - w_low)
w_S3            = w_low - 2 * (w_high - w_PP)
w_S4            = w_PP - 3 * (w_high - w_low)

// monthly R/S pivot points (extended to 4)
m_R1            = m_PP + m_PP - m_low
m_R2            = m_PP + m_high - m_low
m_R3            = m_high + 2 * (m_PP - m_low)
m_R4            = m_PP + 3 * (m_high - m_low)

m_S1            = m_PP - (m_high - m_PP)
m_S2            = m_PP - (m_high - m_low)
m_S3            = m_low - 2 * (m_high - m_PP)
m_S4            = m_PP - 3 * (m_high - m_low)

// 3 month R/S pivot points (extended to 4)
m3_R1           = m3_PP + m3_PP - m3_low
m3_R2           = m3_PP + m3_high - m3_low
m3_R3           = m3_high + 2 * (m3_PP - m3_low)
m3_R4           = m3_PP + 3 * (m3_high - m3_low)

m3_S1           = m3_PP - (m3_high - m3_PP)
m3_S2           = m3_PP - (m3_high - m3_low)
m3_S3           = m3_low - 2 * (m3_high - m3_PP)
m3_S4           = m3_PP - 3 * (m3_high - m3_low)

// 12 month R/S pivot points (extended to 4)
m12_R1          = m12_PP + m12_PP - m12_low
m12_R2          = m12_PP + m12_high - m12_low
m12_R3          = m12_high + 2 * (m12_PP - m12_low)
m12_R4          = m12_PP + 3 * (m12_high - m12_low)

m12_S1          = m12_PP - (m12_high - m12_PP)
m12_S2          = m12_PP - (m12_high - m12_low)
m12_S3          = m12_low - 2 * (m12_high - m12_PP)
m12_S4          = m12_PP - 3 * (m12_high - m12_low)


// --- ALL PIVOTS AS LINES (Visual Update) ---

// 1. Definition of line variables
var line l_h1_pp = na, var line l_h1_r1 = na, var line l_h1_r2 = na, var line l_h1_r3 = na, var line l_h1_r4 = na, var line l_h1_s1 = na, var line l_h1_s2 = na, var line l_h1_s3 = na, var line l_h1_s4 = na
var line l_h4_pp = na, var line l_h4_r1 = na, var line l_h4_r2 = na, var line l_h4_r3 = na, var line l_h4_r4 = na, var line l_h4_s1 = na, var line l_h4_s2 = na, var line l_h4_s3 = na, var line l_h4_s4 = na
var line l_d_pp = na, var line l_d_r1 = na, var line l_d_r2 = na, var line l_d_r3 = na, var line l_d_r4 = na, var line l_d_s1 = na, var line l_d_s2 = na, var line l_d_s3 = na, var line l_d_s4 = na
var line l_w_pp = na, var line l_w_r1 = na, var line l_w_r2 = na, var line l_w_r3 = na, var line l_w_r4 = na, var line l_w_s1 = na, var line l_w_s2 = na, var line l_w_s3 = na, var line l_w_s4 = na
var line l_m_pp = na, var line l_m_r1 = na, var line l_m_r2 = na, var line l_m_r3 = na, var line l_m_r4 = na, var line l_m_s1 = na, var line l_m_s2 = na, var line l_m_s3 = na, var line l_m_s4 = na
var line l_3m_pp = na, var line l_3m_r1 = na, var line l_3m_r2 = na, var line l_3m_r3 = na, var line l_3m_r4 = na, var line l_3m_s1 = na, var line l_3m_s2 = na, var line l_3m_s3 = na, var line l_3m_s4 = na
var line l_12m_pp = na, var line l_12m_r1 = na, var line l_12m_r2 = na, var line l_12m_r3 = na, var line l_12m_r4 = na, var line l_12m_s1 = na, var line l_12m_s2 = na, var line l_12m_s3 = na, var line l_12m_s4 = na

// 2. Drawing function
f_draw_pivot(_line, _val, _col, _width, _offset_start, _show_cond, _input_active) =>
    line ret_line = _line
    if barstate.islast and _input_active and _show_cond and not na(_val)
        if na(ret_line)
            ret_line := line.new(bar_index + _offset_start, _val, bar_index + _offset_start + 1, _val, color=_col, width=_width)
        else
            line.set_xy1(ret_line, bar_index + _offset_start, _val)
            line.set_xy2(ret_line, bar_index + _offset_start + 1, _val)
            line.set_color(ret_line, _col)
            line.set_width(ret_line, _width)
    else
        if not na(ret_line)
            line.delete(ret_line)
            ret_line := na
    ret_line

// 3. Execution (Drawing)

// Bedingungen fÃ¼r Sichtbarkeit

// 1H: Offset 1, Width 1 (Analog zu Daily)
l_h1_pp := f_draw_pivot(l_h1_pp, h1_PP, color.orange, 1, 1, cond_h1, plot_pivots_h1)
l_h1_r1 := f_draw_pivot(l_h1_r1, h1_R1, color.red, 1, 1, cond_h1, plot_pivots_h1)
l_h1_r2 := f_draw_pivot(l_h1_r2, h1_R2, color.red, 1, 1, cond_h1, plot_pivots_h1)
l_h1_r3 := f_draw_pivot(l_h1_r3, h1_R3, color.red, 1, 1, cond_h1, plot_pivots_h1)
l_h1_r4 := f_draw_pivot(l_h1_r4, h1_R4, color.red, 1, 1, cond_h1, plot_pivots_h1)
l_h1_s1 := f_draw_pivot(l_h1_s1, h1_S1, color.green, 1, 1, cond_h1, plot_pivots_h1)
l_h1_s2 := f_draw_pivot(l_h1_s2, h1_S2, color.green, 1, 1, cond_h1, plot_pivots_h1)
l_h1_s3 := f_draw_pivot(l_h1_s3, h1_S3, color.green, 1, 1, cond_h1, plot_pivots_h1)
l_h1_s4 := f_draw_pivot(l_h1_s4, h1_S4, color.green, 1, 1, cond_h1, plot_pivots_h1)

// 4H: Offset 1, Width 1 (Analog zu Daily)
l_h4_pp := f_draw_pivot(l_h4_pp, h4_PP, color.orange, 1, 1, cond_h4, plot_pivots_h4)
l_h4_r1 := f_draw_pivot(l_h4_r1, h4_R1, color.red, 1, 1, cond_h4, plot_pivots_h4)
l_h4_r2 := f_draw_pivot(l_h4_r2, h4_R2, color.red, 1, 1, cond_h4, plot_pivots_h4)
l_h4_r3 := f_draw_pivot(l_h4_r3, h4_R3, color.red, 1, 1, cond_h4, plot_pivots_h4)
l_h4_r4 := f_draw_pivot(l_h4_r4, h4_R4, color.red, 1, 1, cond_h4, plot_pivots_h4)
l_h4_s1 := f_draw_pivot(l_h4_s1, h4_S1, color.green, 1, 1, cond_h4, plot_pivots_h4)
l_h4_s2 := f_draw_pivot(l_h4_s2, h4_S2, color.green, 1, 1, cond_h4, plot_pivots_h4)
l_h4_s3 := f_draw_pivot(l_h4_s3, h4_S3, color.green, 1, 1, cond_h4, plot_pivots_h4)
l_h4_s4 := f_draw_pivot(l_h4_s4, h4_S4, color.green, 1, 1, cond_h4, plot_pivots_h4)

// Daily: Offset 1, Width 1
l_d_pp := f_draw_pivot(l_d_pp, d_PP, color.orange, 2, 1, Intra, plot_pivots_d)
l_d_r1 := f_draw_pivot(l_d_r1, d_R1, color.red, 2, 1, Intra, plot_pivots_d)
l_d_r2 := f_draw_pivot(l_d_r2, d_R2, color.red, 2, 1, Intra, plot_pivots_d)
l_d_r3 := f_draw_pivot(l_d_r3, d_R3, color.red, 2, 1, Intra, plot_pivots_d)
l_d_r4 := f_draw_pivot(l_d_r4, d_R4, color.red, 2, 1, Intra, plot_pivots_d)
l_d_s1 := f_draw_pivot(l_d_s1, d_S1, color.green, 2, 1, Intra, plot_pivots_d)
l_d_s2 := f_draw_pivot(l_d_s2, d_S2, color.green, 2, 1, Intra, plot_pivots_d)
l_d_s3 := f_draw_pivot(l_d_s3, d_S3, color.green, 2, 1, Intra, plot_pivots_d)
l_d_s4 := f_draw_pivot(l_d_s4, d_S4, color.green, 2, 1, Intra, plot_pivots_d)

// Weekly: Offset 3, Width 3
l_w_pp := f_draw_pivot(l_w_pp, w_PP, color.yellow, 3, 3, Intra_D, plot_pivots_w)
l_w_r1 := f_draw_pivot(l_w_r1, w_R1, color.red, 3, 3, Intra_D, plot_pivots_w)
l_w_r2 := f_draw_pivot(l_w_r2, w_R2, color.red, 3, 3, Intra_D, plot_pivots_w)
l_w_r3 := f_draw_pivot(l_w_r3, w_R3, color.red, 3, 3, Intra_D, plot_pivots_w)
l_w_r4 := f_draw_pivot(l_w_r4, w_R4, color.red, 3, 3, Intra_D, plot_pivots_w)
l_w_s1 := f_draw_pivot(l_w_s1, w_S1, color.green, 3, 3, Intra_D, plot_pivots_w)
l_w_s2 := f_draw_pivot(l_w_s2, w_S2, color.green, 3, 3, Intra_D, plot_pivots_w)
l_w_s3 := f_draw_pivot(l_w_s3, w_S3, color.green, 3, 3, Intra_D, plot_pivots_w)
l_w_s4 := f_draw_pivot(l_w_s4, w_S4, color.green, 3, 3, Intra_D, plot_pivots_w)

// Monthly: Offset 5, Width 4
l_m_pp := f_draw_pivot(l_m_pp, m_PP, color.yellow, 4, 5, Intra_D_W, plot_pivots_m)
l_m_r1 := f_draw_pivot(l_m_r1, m_R1, color.red, 4, 5, Intra_D_W, plot_pivots_m)
l_m_r2 := f_draw_pivot(l_m_r2, m_R2, color.red, 4, 5, Intra_D_W, plot_pivots_m)
l_m_r3 := f_draw_pivot(l_m_r3, m_R3, color.red, 4, 5, Intra_D_W, plot_pivots_m)
l_m_r4 := f_draw_pivot(l_m_r4, m_R4, color.red, 4, 5, Intra_D_W, plot_pivots_m)
l_m_s1 := f_draw_pivot(l_m_s1, m_S1, color.green, 4, 5, Intra_D_W, plot_pivots_m)
l_m_s2 := f_draw_pivot(l_m_s2, m_S2, color.green, 4, 5, Intra_D_W, plot_pivots_m)
l_m_s3 := f_draw_pivot(l_m_s3, m_S3, color.green, 4, 5, Intra_D_W, plot_pivots_m)
l_m_s4 := f_draw_pivot(l_m_s4, m_S4, color.green, 4, 5, Intra_D_W, plot_pivots_m)

// 3 Month: Offset 7, Width 5
l_3m_pp := f_draw_pivot(l_3m_pp, m3_PP, color.yellow, 5, 7, Intra_D_W_M, plot_pivots_3m)
l_3m_r1 := f_draw_pivot(l_3m_r1, m3_R1, color.red, 5, 7, Intra_D_W_M, plot_pivots_3m)
l_3m_r2 := f_draw_pivot(l_3m_r2, m3_R2, color.red, 5, 7, Intra_D_W_M, plot_pivots_3m)
l_3m_r3 := f_draw_pivot(l_3m_r3, m3_R3, color.red, 5, 7, Intra_D_W_M, plot_pivots_3m)
l_3m_r4 := f_draw_pivot(l_3m_r4, m3_R4, color.red, 5, 7, Intra_D_W_M, plot_pivots_3m)
l_3m_s1 := f_draw_pivot(l_3m_s1, m3_S1, color.green, 5, 7, Intra_D_W_M, plot_pivots_3m)
l_3m_s2 := f_draw_pivot(l_3m_s2, m3_S2, color.green, 5, 7, Intra_D_W_M, plot_pivots_3m)
l_3m_s3 := f_draw_pivot(l_3m_s3, m3_S3, color.green, 5, 7, Intra_D_W_M, plot_pivots_3m)
l_3m_s4 := f_draw_pivot(l_3m_s4, m3_S4, color.green, 5, 7, Intra_D_W_M, plot_pivots_3m)

// 12 Month: Offset 9, Width 6
l_12m_pp := f_draw_pivot(l_12m_pp, m12_PP, color.yellow, 6, 9, Intra_D_W_M, plot_pivots_12m)
l_12m_r1 := f_draw_pivot(l_12m_r1, m12_R1, color.red, 6, 9, Intra_D_W_M, plot_pivots_12m)
l_12m_r2 := f_draw_pivot(l_12m_r2, m12_R2, color.red, 6, 9, Intra_D_W_M, plot_pivots_12m)
l_12m_r3 := f_draw_pivot(l_12m_r3, m12_R3, color.red, 6, 9, Intra_D_W_M, plot_pivots_12m)
l_12m_r4 := f_draw_pivot(l_12m_r4, m12_R4, color.red, 6, 9, Intra_D_W_M, plot_pivots_12m)
l_12m_s1 := f_draw_pivot(l_12m_s1, m12_S1, color.green, 6, 9, Intra_D_W_M, plot_pivots_12m)
l_12m_s2 := f_draw_pivot(l_12m_s2, m12_S2, color.green, 6, 9, Intra_D_W_M, plot_pivots_12m)
l_12m_s3 := f_draw_pivot(l_12m_s3, m12_S3, color.green, 6, 9, Intra_D_W_M, plot_pivots_12m)
l_12m_s4 := f_draw_pivot(l_12m_s4, m12_S4, color.green, 6, 9, Intra_D_W_M, plot_pivots_12m)


//----------------------------------- Bollinger Bands ------------------------------------

f_stdev(_bb_len) => ta.stdev(close, _bb_len)
f_sma(_sma_len) => ta.sma(close, _sma_len)

f_bb_basis(_sma_len) => f_sma(_sma_len)

f_bb_dev(_sma_len) => f_stdev(_sma_len)

// Stage 4: Bollinger Bands Hard-Gating
float basis = na
float dev_1 = na
float upper_1 = na
float lower_1 = na
float dev_3 = na
float upper_3 = na
float lower_3 = na
bool approach_up = false
bool approach_dn = false

if eff_BB_plot
    ops_bb += 1 // Count Ops

    //bb1
    basis := f_bb_basis(eff_bb_len)
    dev_1 := eff_bb_mult * f_bb_dev(eff_bb_len)
    upper_1 := basis + dev_1
    lower_1 := basis - dev_1

    //bb3
    dev_3 := BB_sdev_3 * f_bb_dev(eff_bb_len)
    upper_3 := basis + dev_3
    lower_3 := basis - dev_3

    approach_up := near_bb ? high > upper_1 : true
    approach_dn := near_bb ? low < lower_1 : true

bup_1 = plot(eff_BB_plot and approach_up ? upper_1 : na, title='Upper BB1', color=color.new(color.gray, 100), linewidth=1)
bdn_1 = plot(eff_BB_plot and approach_dn ? lower_1 : na, title='Lower BB1', color=color.new(color.gray, 100), linewidth=1)

bup_3 = plot(eff_BB_plot and approach_up ? upper_3 : na, title='Upper BB3', color=color.new(color.gray, 100), linewidth=1)
bdn_3 = plot(eff_BB_plot and approach_dn ? lower_3 : na, title='Lower BB3', color=color.new(color.gray, 100), linewidth=1)

fill(bup_1, bup_3, color=color.new(color.red, 80))
fill(bdn_1, bdn_3, color=color.new(color.green, 80))


//----------------- Trading Sessions Logic -----------------

// Global FIFO Array for Session Lines
var line[] sess_lines = array.new_line()

// Function to calculate state and draw Session Boxes or Lines
// UPDATED: Added FIFO Logic
f_draw_session(_show, _sess, _tz, _col, _style, _box, _high, _low, _start_t_state, _restrict, _restrict_time, _lines_array, _limit) =>
    is_weekend = dayofweek == dayofweek.saturday or dayofweek == dayofweek.sunday

    // Calculate if session is active (Raw)
    bool is_sess_raw = _show and not is_weekend and not na(time(timeframe.period, _sess, _tz))
    bool is_start = is_sess_raw and not is_sess_raw[1]

    // Update Start Time State
    int start_t_cur = _start_t_state
    if is_start
        start_t_cur := time

    // Calculate Restriction (Effective Session)
    bool is_sess = is_sess_raw
    if _restrict and is_sess_raw and not na(start_t_cur)
        // Convert restricted time (minutes) to ms
        ms_limit = _restrict_time * 60 * 1000
        if (time - start_t_cur) >= ms_limit
            is_sess := false

    // Vertical Line Logic (FIFO)
    if _style == "Vertical Line" and is_start
        line new_l = line.new(x1=bar_index, y1=low, x2=bar_index, y2=high, extend=extend.both, color=color.new(_col, 70), style=line.style_solid, width=1)
        array.push(_lines_array, new_l)
        if array.size(_lines_array) > _limit
            line.delete(array.shift(_lines_array))

    // Box Logic
    box b_cur = _box
    float h_cur = _high
    float l_cur = _low

    if _style == "Box" and is_sess
        if is_start // Session Start
            h_cur := high
            l_cur := low
            b_cur := box.new(left=bar_index, top=h_cur, right=bar_index, bottom=l_cur, border_color=_col, bgcolor=_col)
        else // Session Ongoing
            h_cur := math.max(h_cur, high)
            l_cur := math.min(l_cur, low)
            box.set_top(b_cur, h_cur)
            box.set_bottom(b_cur, l_cur)
            box.set_right(b_cur, bar_index + 1)

    [is_sess, b_cur, h_cur, l_cur, start_t_cur]

// Check TF Constraint (Visible only if TF <= 1 Hour)
show_sess_on_tf = timeframe.isintraday and timeframe.multiplier <= 60

// Define Global State Variables for each Session
var box b_lon = na, var float h_lon = na, var float l_lon = na, var int st_lon = na
var box b_ny = na, var float h_ny = na, var float l_ny = na, var int st_ny = na
var box b_tok = na, var float h_tok = na, var float l_tok = na, var int st_tok = na
var box b_syd = na, var float h_syd = na, var float l_syd = na, var int st_syd = na

// Execute Function
[lon_active, t_b_lon, t_h_lon, t_l_lon, t_st_lon] = f_draw_session(eff_london_show and show_sess_on_tf, london_sess, sess_timezone, london_col, sess_style, b_lon, h_lon, l_lon, st_lon, use_sess_rest, sess_rest_time, sess_lines, sess_line_limit)
b_lon := t_b_lon
h_lon := t_h_lon
l_lon := t_l_lon
st_lon := t_st_lon

[ny_active, t_b_ny, t_h_ny, t_l_ny, t_st_ny] = f_draw_session(eff_ny_show and show_sess_on_tf, ny_sess, sess_timezone, ny_col, sess_style, b_ny, h_ny, l_ny, st_ny, use_sess_rest, sess_rest_time, sess_lines, sess_line_limit)
b_ny := t_b_ny
h_ny := t_h_ny
l_ny := t_l_ny
st_ny := t_st_ny

// --- ZUSATZ: Zweite Linie um 19:30 Uhr fÃ¼r New York (nur bei Vertical Line) ---
if eff_ny_show and show_sess_on_tf and sess_style == "Vertical Line"
    // PrÃ¼fen, ob wir Wochenende haben (um Linie zu verhindern)
    is_weekend_ny = dayofweek == dayofweek.saturday or dayofweek == dayofweek.sunday
    // Wir prÃ¼fen auf Startzeit 19:30 in der gewÃ¤hlten Zeitzone
    // "1930-2359" stellt sicher, dass wir den Beginn auch auf hÃ¶heren Timeframes (z.B. 1h) erwischen
    is_1930_sess  = not is_weekend_ny and not na(time(timeframe.period, "1930-2359", sess_timezone))
    is_1930_start = is_1930_sess and not is_1930_sess[1]

    if is_1930_start
        line l = line.new(x1=bar_index, y1=low, x2=bar_index, y2=high, extend=extend.both, color=color.new(ny_col, 70), style=line.style_dashed, width=1)
        array.push(sess_lines, l)
        if array.size(sess_lines) > sess_line_limit
            line.delete(array.shift(sess_lines))
// -------------------------------------------------------------------------------

[tok_active, t_b_tok, t_h_tok, t_l_tok, t_st_tok] = f_draw_session(eff_tokyo_show and show_sess_on_tf, tokyo_sess, sess_timezone, tokyo_col, sess_style, b_tok, h_tok, l_tok, st_tok, use_sess_rest, sess_rest_time, sess_lines, sess_line_limit)
b_tok := t_b_tok
h_tok := t_h_tok
l_tok := t_l_tok
st_tok := t_st_tok

[syd_active, t_b_syd, t_h_syd, t_l_syd, t_st_syd] = f_draw_session(eff_sydney_show and show_sess_on_tf, sydney_sess, sess_timezone, sydney_col, sess_style, b_syd, h_syd, l_syd, st_syd, use_sess_rest, sess_rest_time, sess_lines, sess_line_limit)
b_syd := t_b_syd
h_syd := t_h_syd
l_syd := t_l_syd
st_syd := t_st_syd

// Draw Backgrounds - COMBINED
// Priority: NY > London > Tokyo > Sydney (in case of overlapping times)
// For Inv. Background: Unified Blue 50% if sessions enabled but NOT active.
bool any_sess_configured = eff_london_show or eff_ny_show or eff_tokyo_show or eff_sydney_show
bool any_sess_active     = lon_active or ny_active or tok_active or syd_active

color bg_sess_color = na

if show_sess_on_tf
    if sess_style == "Background"
        bg_sess_color := ny_active ? ny_col : lon_active ? london_col : tok_active ? tokyo_col : syd_active ? sydney_col : na
    else if sess_style == "Inv. Background"
        if any_sess_configured
            bg_sess_color := any_sess_active ? na : color.new(color.blue, 85)


//------------------------------------------------------- VWAP Core & Bands -------------------------------------------------------
// Stage 3 & 4: VWAP Core + Bands + Z-Score

var VwapState vs = VwapState.new(0.0, 0.0, na)
var WelfordState ws = WelfordState.new(0, 0.0, 0.0)

// Anchor Logic
bool new_anchor = false
if eff_vwap_anchor == "Session (Daily Reset)"
    new_anchor := ta.change(time("D"))
else if eff_vwap_anchor == "Weekly"
    new_anchor := ta.change(time("W"))

// Session Filter
bool in_calc_window = true
if vwap_only_sess
    // any_sess_active is defined in Trading Sessions Logic
    in_calc_window := any_sess_active

// Update Logic
float vwap_val = na
float sigma_val = na
float z_val = na
string stretch_state = "NORMAL"

if eff_vwap_enabled
    // Anchor Reset
    if new_anchor
        vs.cumVol := 0.0
        vs.cumPV := 0.0
        vs.vwap := na
        ws.n := 0
        ws.mean := 0.0
        ws.m2 := 0.0

    // Core Calc
    // Source Mapping
    float src = vwap_src_opt == "HL2" ? hl2 : vwap_src_opt == "Close" ? close : vwap_src_opt == "OHLC4" ? ohlc4 : hlc3

    if in_calc_window
        vs.cumVol += volume
        vs.cumPV += (volume * src)

    if vs.cumVol > 0
        vwap_val := vs.cumPV / vs.cumVol
        vs.vwap := vwap_val

    // Bands / Sigma Calc
    if not na(vwap_val) and (eff_vwap_bands or eff_vwap_z)
        float dev = close - vwap_val

        if vwap_sigma_mode == "Rolling (ta.stdev)"
            sigma_val := ta.stdev(dev, vwap_stdev_len)
        else // Session (Welford)
            if in_calc_window
                ws.n += 1
                float delta = dev - ws.mean
                ws.mean += delta / ws.n
                ws.m2 += delta * (dev - ws.mean)

            float variance = ws.n > 1 ? ws.m2 / (ws.n - 1) : 0.0
            sigma_val := math.sqrt(variance)

        // Z-Score
        if eff_vwap_z and not na(sigma_val) and sigma_val > 0
            z_val := dev / sigma_val

            // State
            if z_val >= z_th_ext
                stretch_state := "EXTREME UP"
            else if z_val >= z_th_tp
                stretch_state := "TP UP"
            else if z_val >= z_th_entry
                stretch_state := "ENTRY UP"
            else if z_val <= -z_th_ext
                stretch_state := "EXTREME DN"
            else if z_val <= -z_th_tp
                stretch_state := "TP DN"
            else if z_val <= -z_th_entry
                stretch_state := "ENTRY DN"

// Plotting
plot(vwap_show_line ? vwap_val : na, color=color.new(color.orange, 0), title="VWAP")

// Bands
plot(eff_vwap_bands and not na(sigma_val) ? vwap_val + band_k1 * sigma_val : na, "B1 Up", color.new(color.gray, 80))
plot(eff_vwap_bands and not na(sigma_val) ? vwap_val - band_k1 * sigma_val : na, "B1 Dn", color.new(color.gray, 80))
plot(eff_vwap_bands and not na(sigma_val) ? vwap_val + band_k2 * sigma_val : na, "B2 Up", color.new(color.gray, 60))
plot(eff_vwap_bands and not na(sigma_val) ? vwap_val - band_k2 * sigma_val : na, "B2 Dn", color.new(color.gray, 60))
plot(eff_vwap_bands and not na(sigma_val) ? vwap_val + band_k3 * sigma_val : na, "B3 Up", color.new(color.gray, 40))
plot(eff_vwap_bands and not na(sigma_val) ? vwap_val - band_k3 * sigma_val : na, "B3 Dn", color.new(color.gray, 40))

// Label for Z
var label lb_vwap_z = na
if eff_vwap_z and stretch_state != "NORMAL" and barstate.islast
    label.delete(lb_vwap_z)
    color c_z = str.contains(stretch_state, "EXTREME") ? color.red : color.orange
    lb_vwap_z := label.new(bar_index, high, "Z: " + str.tostring(z_val, "#.##") + "\n" + stretch_state, color=c_z, style=label.style_label_down, textcolor=color.white, size=size.small)
else
    label.delete(lb_vwap_z)
    lb_vwap_z := na


//------------------------------------------------------- Opening Range / Initial Balance -------------------------------------------------------
// Stage 5: OR/IB Module

var OrState ors = OrState.new(na, na, na, false, false, na, na, na)

// Session Determination
string or_s_str = na
if or_sess == "London"
    or_s_str := london_sess
else if or_sess == "New York"
    or_s_str := ny_sess
else
    or_s_str := or_cust

bool in_or_sess = false
if eff_or_enabled
    in_or_sess := not na(time(timeframe.period, or_s_str, sess_timezone))

bool or_start = in_or_sess and not in_or_sess[1]

// Events
bool or_break_up = false
bool or_break_dn = false

if eff_or_enabled
    // Reset / Start
    if or_start
        ors.start_bar := bar_index
        ors.hi := high
        ors.lo := low
        ors.building := true
        ors.locked := false

        // Colors
        color c_or_border = color.new(color.blue, 30)
        color c_or_bg = color.new(color.blue, 92)
        color c_or_hi = color.new(color.green, 30)
        color c_or_lo = color.new(color.red, 30)

        // Visibility
        bool show_box = or_display == "Box+Lines" or or_display == "Box"
        bool show_lines = or_display == "Box+Lines" or or_display == "Lines"

        // Init/Reset Objects (reuse)
        if na(ors.id_box)
            ors.id_box := box.new(bar_index, high, bar_index, low, border_color=show_box ? c_or_border : na, bgcolor=show_box ? c_or_bg : na)
            ors.l_hi := line.new(bar_index, high, bar_index, high, color=show_lines ? c_or_hi : na)
            ors.l_lo := line.new(bar_index, low, bar_index, low, color=show_lines ? c_or_lo : na)
        else
            box.set_left(ors.id_box, bar_index)
            box.set_right(ors.id_box, bar_index)
            box.set_top(ors.id_box, high)
            box.set_bottom(ors.id_box, low)
            box.set_border_color(ors.id_box, show_box ? c_or_border : na)
            box.set_bgcolor(ors.id_box, show_box ? c_or_bg : na)

            line.set_xy1(ors.l_hi, bar_index, high)
            line.set_xy2(ors.l_hi, bar_index, high)
            line.set_color(ors.l_hi, show_lines ? c_or_hi : na)

            line.set_xy1(ors.l_lo, bar_index, low)
            line.set_xy2(ors.l_lo, bar_index, low)
            line.set_color(ors.l_lo, show_lines ? c_or_lo : na)

    else if ors.building
        // Check Duration
        int eff_min = or_type == "Initial Balance" ? 60 : or_min
        float dur_sec = eff_min * 60
        float elapsed_sec = (bar_index - ors.start_bar + 1) * tf_sec // Estimation via bars, simpler

        if elapsed_sec <= dur_sec
            // Update
            ors.hi := math.max(ors.hi, high)
            ors.lo := math.min(ors.lo, low)

            box.set_top(ors.id_box, ors.hi)
            box.set_bottom(ors.id_box, ors.lo)
            box.set_right(ors.id_box, bar_index + 1)

            line.set_y1(ors.l_hi, ors.hi)
            line.set_xy2(ors.l_hi, bar_index + 1, ors.hi)

            line.set_y1(ors.l_lo, ors.lo)
            line.set_xy2(ors.l_lo, bar_index + 1, ors.lo)
        else
            // Finish
            ors.building := false
            if or_lock
                ors.locked := true
                // Freeze
                box.set_right(ors.id_box, bar_index + 5)
                line.set_x2(ors.l_hi, bar_index + 5)
                line.set_x2(ors.l_lo, bar_index + 5)

    else if ors.locked
        // Extension
        if barstate.islast
            box.set_right(ors.id_box, bar_index + 5)
            line.set_x2(ors.l_hi, bar_index + 5)
            line.set_x2(ors.l_lo, bar_index + 5)

        // Break Logic (Events)
        if close > ors.hi and close[1] <= ors.hi
            or_break_up := true
        if close < ors.lo and close[1] >= ors.lo
            or_break_dn := true

//----------------- MTF Candle Overlay Logic -----------------

// Map string selection
mtf_tf = switch mtf_tf_sel
    "5m" => "5"
    "15m" => "15"
    "30m" => "30"
    "1h" => "60"
    "2h" => "120"
    "4h" => "240"
    "6h" => "360"
    "12h" => "720"
    "1d" => "D"
    "1w" => "W"
    "1M" => "M"
    "3M" => "3M"
    => "240"

// Check logic
is_higher_tf = timeframe.in_seconds(mtf_tf) > timeframe.in_seconds(timeframe.period)

// Variables (Stage 2: Hard Gating)
float mtf_o = na
float mtf_h = na
float mtf_l = na
float mtf_c = na

if ON_MTF_OV and is_higher_tf
    [t_o, t_h, t_l, t_c] = request.security(syminfo.tickerid, mtf_tf, [open, high, low, close], lookahead=barmerge.lookahead_on)
    mtf_o := t_o
    mtf_h := t_h
    mtf_l := t_l
    mtf_c := t_c
    active_sec_calls += 1

new_mtf_bar = timeframe.change(mtf_tf)

// Colors
t_val = 100 - mtf_opacity
col_bull = color.new(color.green, t_val)
col_bear = color.new(color.red, t_val)
col_border_bull = color.new(color.green, 80)
col_border_bear = color.new(color.red, 80)

// Persistent Variables (Stage 4: Array FIFO)
var box[] mtf_boxes = array.new_box()
var box mtf_body = na

if ON_MTF_OV and is_higher_tf

    // Determine Bull/Bear state
    is_up = mtf_c >= mtf_o
    cur_fill = is_up ? col_bull : col_bear
    cur_border = is_up ? col_border_bull : col_border_bear

    // Geometry: Always High to Low
    float body_top = mtf_h
    float body_bot = mtf_l

    // --- Logic ---
    if new_mtf_bar
        // Create NEW object to avoid overlap
        mtf_body := box.new(bar_index, body_top, bar_index, body_bot, border_color=cur_border, border_width=1, bgcolor=cur_fill)
        array.push(mtf_boxes, mtf_body)

        // FIFO Limit (e.g., 50)
        if array.size(mtf_boxes) > 50
            box.delete(array.shift(mtf_boxes))

    else
        // Update Existing Object (Last one created)
        // If mtf_body is maintained, we can use it directly, but getting from array is safer if logic was complex
        // Here we just reuse mtf_body var which holds the current active box
        if not na(mtf_body)
            box.set_right(mtf_body, bar_index)
            box.set_top(mtf_body, body_top)
            box.set_bottom(mtf_body, body_bot)
            box.set_bgcolor(mtf_body, cur_fill)
            box.set_border_color(mtf_body, cur_border)
else
    // Cleanup if disabled
    if array.size(mtf_boxes) > 0
        for i = 0 to array.size(mtf_boxes) - 1
            box.delete(array.get(mtf_boxes, i))
        array.clear(mtf_boxes)


//--------------------------------------------------------- Fair Value Gaps (FVG) ---------------------------------------------------------

// --- Variables to track boxes for limit ---
var box[] boxes_fvg1 = array.new_box()
var box[] boxes_fvg2 = array.new_box()

// --- FVG 1 LOGIC ---

// Helper: Timeframe Duration
tf_ms1 = (fvg1_tf_sel == "" ? timeframe.in_seconds(timeframe.period) : timeframe.in_seconds(fvg1_tf_sel)) * 1000

// Variable to track the last drawn FVG time
var int last_fvg_time1 = 0

// Stage 3: Refactored FVG1 (No security if Current TF)
float h1_mtf1 = na, float l1_mtf1 = na, float h3_mtf1 = na, float l3_mtf1 = na, int t2_mtf1 = na

// Only fetch MTF data if valid TF selection AND enabled
if ON_FVG1 and fvg1_tf_sel != ""
    [t_h1, t_l1, t_h3, t_l3, t_t2] = request.security(syminfo.tickerid, fvg1_tf_sel, [high[1], low[1], high[3], low[3], time[2]], lookahead=barmerge.lookahead_off)
    h1_mtf1 := t_h1, l1_mtf1 := t_l1, h3_mtf1 := t_h3, l3_mtf1 := t_l3, t2_mtf1 := t_t2
    active_sec_calls += 1

if ON_FVG1
    box b_new = na
    // CASE A: Current Timeframe (Direct Source)
    if fvg1_tf_sel == ""
        if low > high[2] // Bullish
            _border_bull = color.new(color.green, 90)
            b_new := box.new(left=bar_index[2], top=low, right=bar_index + (fvg1_len - 1), bottom=high[2], border_color=_border_bull, bgcolor=col_fvg1_bull)

        if high < low[2] // Bearish
            _border_bear = color.new(color.red, 90)
            b_new := box.new(left=bar_index[2], top=low[2], right=bar_index + (fvg1_len - 1), bottom=high, border_color=_border_bear, bgcolor=col_fvg1_bear)

        // Registry
        sig_fvg_bull := low > high[2]
        sig_fvg_bear := high < low[2]

    // CASE B: Higher Timeframe (Security Source)
    else
        if t2_mtf1 != last_fvg_time1 and not na(t2_mtf1)
            t_left = t2_mtf1 - tf_ms1
            t_right = t2_mtf1 + (tf_ms1 * fvg1_len)

            if l1_mtf1 > h3_mtf1 // Bullish
                _border_bull = color.new(color.green, 90)
                b_new := box.new(left=t_left, top=l1_mtf1, right=t_right, bottom=h3_mtf1, xloc=xloc.bar_time, border_color=_border_bull, bgcolor=col_fvg1_bull)

            if h1_mtf1 < l3_mtf1 // Bearish
                _border_bear = color.new(color.red, 90)
                b_new := box.new(left=t_left, top=l3_mtf1, right=t_right, bottom=h1_mtf1, xloc=xloc.bar_time, border_color=_border_bear, bgcolor=col_fvg1_bear)

            last_fvg_time1 := t2_mtf1

    // Manage Box Limit
    if not na(b_new)
        array.push(boxes_fvg1, b_new)
        if array.size(boxes_fvg1) > fvg1_limit
            box.delete(array.shift(boxes_fvg1))
else
    // Cleanup
    if array.size(boxes_fvg1) > 0
        for i = 0 to array.size(boxes_fvg1) - 1
            box.delete(array.get(boxes_fvg1, i))
        array.clear(boxes_fvg1)


// --- FVG 2 LOGIC ---

// Helper: Timeframe Duration
tf_ms2 = (fvg2_tf_sel == "" ? timeframe.in_seconds(timeframe.period) : timeframe.in_seconds(fvg2_tf_sel)) * 1000

// Variable to track the last drawn FVG time
var int last_fvg_time2 = 0

// Stage 3: Refactored FVG2 (No security if Current TF)
float h1_mtf2 = na, float l1_mtf2 = na, float h3_mtf2 = na, float l3_mtf2 = na, int t2_mtf2 = na

if ON_FVG2 and fvg2_tf_sel != ""
    [t_h1, t_l1, t_h3, t_l3, t_t2] = request.security(syminfo.tickerid, fvg2_tf_sel, [high[1], low[1], high[3], low[3], time[2]], lookahead=barmerge.lookahead_off)
    h1_mtf2 := t_h1, l1_mtf2 := t_l1, h3_mtf2 := t_h3, l3_mtf2 := t_l3, t2_mtf2 := t_t2
    active_sec_calls += 1

if ON_FVG2
    box b_new = na
    // CASE A: Current Timeframe (Direct Source)
    if fvg2_tf_sel == ""
        if low > high[2] // Bullish
            _border_bull = color.new(color.green, 90)
            b_new := box.new(left=bar_index[2], top=low, right=bar_index + (fvg2_len - 1), bottom=high[2], border_color=_border_bull, bgcolor=col_fvg2_bull)

        if high < low[2] // Bearish
            _border_bear = color.new(color.red, 90)
            b_new := box.new(left=bar_index[2], top=low[2], right=bar_index + (fvg2_len - 1), bottom=high, border_color=_border_bear, bgcolor=col_fvg2_bear)

    // CASE B: Higher Timeframe
    else
        if t2_mtf2 != last_fvg_time2 and not na(t2_mtf2)
            t_left = t2_mtf2 - tf_ms2
            t_right = t2_mtf2 + (tf_ms2 * fvg2_len)

            if l1_mtf2 > h3_mtf2 // Bullish
                _border_bull = color.new(color.green, 90)
                b_new := box.new(left=t_left, top=l1_mtf2, right=t_right, bottom=h3_mtf2, xloc=xloc.bar_time, border_color=_border_bull, bgcolor=col_fvg2_bull)

            if h1_mtf2 < l3_mtf2 // Bearish
                _border_bear = color.new(color.red, 90)
                b_new := box.new(left=t_left, top=l3_mtf2, right=t_right, bottom=h1_mtf2, xloc=xloc.bar_time, border_color=_border_bear, bgcolor=col_fvg2_bear)

            last_fvg_time2 := t2_mtf2

    // Manage Box Limit
    if not na(b_new)
        array.push(boxes_fvg2, b_new)
        if array.size(boxes_fvg2) > fvg2_limit
            box.delete(array.shift(boxes_fvg2))
else
    // Cleanup
    if array.size(boxes_fvg2) > 0
        for i = 0 to array.size(boxes_fvg2) - 1
            box.delete(array.get(boxes_fvg2, i))
        array.clear(boxes_fvg2)


//--------------------------------------------------------- Real-time Fractal Alert ---------------------------------------------------------

// --- Logic Calculation ---
// We cannot use ta.pivothigh/low for the realtime bar effectively, so we check the structure manually.
// Structure: [Left2][Left1][Pivot][Right1][Current(Right2)]
// Indices:    [4]    [3]    [2]     [1]       [0]

// Check if bars 4, 3, 2, and 1 form a valid pre-fractal structure
valid_up_structure = high[2] > high[3] and high[2] > high[4] and high[2] > high[1]
valid_dn_structure = low[2] < low[3] and low[2] < low[4] and low[2] < low[1]

// Check if the current running bar (0) respects the fractal rule
// Up Fractal: Current High must be lower than Pivot High
rt_up_frac = valid_up_structure and high < high[2]

// Down Fractal: Current Low must be higher than Pivot Low
rt_dn_frac = valid_dn_structure and low > low[2]

// --- Trigger Alert ---
// Trigger only if enabled, in realtime, and condition is met.
// freq_once_per_bar avoids spamming the sound on every tick.
if use_rt_alert and barstate.isrealtime and (rt_up_frac or rt_dn_frac)
    alert("Potential Fractal Forming (5th Candle Running)", alert.freq_once_per_bar)


//--------------------------------------------------------- Additional Context (No Plot-Limit Usage) ---------------------------------------------------------

// Helper to check session start (Used by both functionalities)
f_is_sess_start(_show, _sess) =>
    _show and not na(time(timeframe.period, _sess, sess_timezone)) and na(time(timeframe.period, _sess, sess_timezone)[1])

/// --- 1. 1st Session Candle (Separate Logic) ---
// Function to run on the target timeframe
f_calc_sess_1st() =>
    // Check all sessions using global inputs
    bool s_lon_s = f_is_sess_start(london_show, london_sess)
    bool s_ny_s  = f_is_sess_start(ny_show, ny_sess)
    bool s_tok_s = f_is_sess_start(tokyo_show, tokyo_sess)
    bool s_syd_s = f_is_sess_start(sydney_show, sydney_sess)
    bool s_nypm_s = f_is_sess_start(ny_show, "1930-2359")

    // Store latest session start values
    var float saved_h = na
    var float saved_l = na
    var int saved_t = na

    if s_lon_s or s_ny_s or s_tok_s or s_syd_s or s_nypm_s
        saved_h := high
        saved_l := low
        saved_t := time

    [saved_h, saved_l, saved_t]

// Retrieve from selected timeframe
float s1_h_val = na
float s1_l_val = na
int s1_t_val = na

if ON_SESS_1ST
    [t_h, t_l, t_t] = request.security(syminfo.tickerid, sess_1st_tf, f_calc_sess_1st(), lookahead=barmerge.lookahead_on)
    s1_h_val := t_h
    s1_l_val := t_l
    s1_t_val := t_t
    active_sec_calls += 1

// Variables for 1st Session Lines/Labels
var line l_s1_h = na
var line l_s1_l = na
var label lb_s1_h = na
var label lb_s1_l = na

// Stage 3: 1st Session Candle & Last Fractal S/R (Reuse)

if barstate.islast
    // Check Visibility
    is_valid_s1_tf = timeframe.in_seconds(timeframe.period) <= timeframe.in_seconds(sess_1st_tf)

    if ON_SESS_1ST and is_valid_s1_tf
        if not na(s1_h_val) and not na(s1_t_val)
            l_s1_h := f_line_get_or_create(l_s1_h, s1_t_val, s1_h_val, time, s1_h_val, color.new(color.gray, 50), line.style_solid, xloc.bar_time)
            lb_s1_h := f_label_get_or_create(lb_s1_h, bar_index + 4, s1_h_val, "1st High", color.new(color.gray, 30))

        if not na(s1_l_val) and not na(s1_t_val)
            l_s1_l := f_line_get_or_create(l_s1_l, s1_t_val, s1_l_val, time, s1_l_val, color.new(color.gray, 50), line.style_solid, xloc.bar_time)
            lb_s1_l := f_label_get_or_create(lb_s1_l, bar_index + 4, s1_l_val, "1st Low", color.new(color.gray, 30))

    else
        line.delete(l_s1_h)
        l_s1_h := na
        line.delete(l_s1_l)
        l_s1_l := na
        label.delete(lb_s1_h)
        lb_s1_h := na
        label.delete(lb_s1_l)
        lb_s1_l := na
else
    // Cleanup if disabled (Hard Gating)
    line.delete(l_s1_h)
    l_s1_h := na
    line.delete(l_s1_l)
    l_s1_l := na
    label.delete(lb_s1_h)
    lb_s1_h := na
    label.delete(lb_s1_l)
    lb_s1_l := na




// --- 2. Last Fractal S/R (Lines & Labels) ---

// Function to get last confirmed fractal price and time
f_get_last_fractal_data() =>
    ph = ta.pivothigh(high, 2, 2)
    pl = ta.pivotlow(low, 2, 2)
    // When ph is detected, the fractal apex is at [2]
    p_h_val = ta.valuewhen(not na(ph), high[2], 0)
    p_h_time = ta.valuewhen(not na(ph), time[2], 0)
    p_l_val = ta.valuewhen(not na(pl), low[2], 0)
    p_l_time = ta.valuewhen(not na(pl), time[2], 0)
    [p_h_val, p_h_time, p_l_val, p_l_time]

float frac_h_val = na
int frac_h_time = na
float frac_l_val = na
int frac_l_time = na

if ON_LAST_FR
    [t_fh, t_fht, t_fl, t_flt] = request.security(syminfo.tickerid, last_frac_tf, f_get_last_fractal_data())
    frac_h_val := t_fh
    frac_h_time := t_fht
    frac_l_val := t_fl
    frac_l_time := t_flt
    active_sec_calls += 1

var line l_last_fh = na
var line l_last_fl = na
var label lb_last_fh = na
var label lb_last_fl = na

if barstate.islast
    // Check Visibility
    is_valid_frac_tf = timeframe.in_seconds(timeframe.period) <= timeframe.in_seconds(last_frac_tf)

    if ON_LAST_FR and is_valid_frac_tf
        if not na(frac_h_val)
            l_last_fh := f_line_get_or_create(l_last_fh, frac_h_time, frac_h_val, time, frac_h_val, color.new(color.gray, 50), line.style_dashed, xloc.bar_time)
            lb_last_fh := f_label_get_or_create(lb_last_fh, bar_index + 8, frac_h_val, "Frac High", color.new(color.gray, 30))

        if not na(frac_l_val)
            l_last_fl := f_line_get_or_create(l_last_fl, frac_l_time, frac_l_val, time, frac_l_val, color.new(color.gray, 50), line.style_dashed, xloc.bar_time)
            lb_last_fl := f_label_get_or_create(lb_last_fl, bar_index + 8, frac_l_val, "Frac Low", color.new(color.gray, 30))
    else
        line.delete(l_last_fh)
        l_last_fh := na
        line.delete(l_last_fl)
        l_last_fl := na
        label.delete(lb_last_fh)
        lb_last_fh := na
        label.delete(lb_last_fl)
        lb_last_fl := na
else
    // Cleanup if disabled (Hard Gating)
    line.delete(l_last_fh)
    l_last_fh := na
    line.delete(l_last_fl)
    l_last_fl := na
    label.delete(lb_last_fh)
    lb_last_fh := na
    label.delete(lb_last_fl)
    lb_last_fl := na


// --- 3. Volume Spikes (Char) ---
// Calculates if Volume is x-times larger than the SMA(20) of Volume
avg_vol = ta.sma(volume, 20)
is_vol_spike = volume > (avg_vol * vol_mult)

// Uses plotchar (Symbol 'V' in bold RED)
plotchar(eff_show_vol ? is_vol_spike : na, char='v', location=location.bottom, color=color.new(color.red, 30), size=size.tiny, title="High Volume Spike")
sig_vol_spike := eff_show_vol and is_vol_spike


// ------------------------------------------- Gradient Volume Profile ----------------------------------------------

// Mode flag
bool vp_is_full = (vp_mode == "Full TF")
bool vp_is_bars = (vp_style == "Bars")

// Full TF Data Structures (range-independent bins)
int vp_full_band_ticks = 10
var map<int, float> vp_map = map.new<int, float>()
var int full_min_k = na
var int full_max_k = na

// Arrays / draw objects
var float[] vp_volArray = array.new_float(vp_rows, 0.0)
var float[] vp_smtArray = array.new_float(vp_rows, 0.0)
var float[] vp_bars_render = array.new_float(0)
var line[]  vp_lines    = array.new_line()
var box[]   vp_boxes    = array.new_box()

// Dirty tracking
var int last_left  = na
var int last_right = na
var int last_full_bar = na
var string last_vp_mode = na
var string last_vp_style = na
var bool vp_dirty = true

// Helper: safe map add
f_vp_map_add(int k, float addv) =>
    float prev = nz(map.get(vp_map, k), 0.0)
    map.put(vp_map, k, prev + addv)

// --- Full TF incremental build (ONLY on confirmed bars to avoid double counting) ---
if eff_vp_enable and vp_is_full and barstate.isconfirmed
    float band_f = syminfo.mintick * vp_full_band_ticks
    float v3 = volume / 3.0

    int k_low  = int(math.floor(low  / band_f))
    int k_mid  = int(math.floor(hlc3 / band_f))
    int k_high = int(math.floor(high / band_f))

    f_vp_map_add(k_low,  v3)
    f_vp_map_add(k_mid,  v3)
    f_vp_map_add(k_high, v3)

    if na(full_min_k) or k_low < full_min_k
        full_min_k := k_low
    if na(full_max_k) or k_high > full_max_k
        full_max_k := k_high

if barstate.islast
    // --- DIRTY LOGIC ---
    bool mode_changed = (vp_mode != last_vp_mode)
    bool style_changed = (vp_style != last_vp_style)

    if mode_changed or style_changed
        vp_dirty := true
    else if vp_is_full
        // Full mode: redraw only when a new bar arrives (bar_index changes)
        if na(last_full_bar) or bar_index != last_full_bar
            vp_dirty := true
    else
        // Visible mode: redraw only when viewport changed
        if (chart.left_visible_bar_time != last_left) or (chart.right_visible_bar_time != last_right)
            vp_dirty := true

    // 1) CLEANUP (Only if dirty or disabled)
    if (vp_dirty and eff_vp_enable) or (not eff_vp_enable and (array.size(vp_lines) > 0 or array.size(vp_boxes) > 0))
        if array.size(vp_lines) > 0
            for i = 0 to array.size(vp_lines) - 1
                line.delete(array.get(vp_lines, i))
            array.clear(vp_lines)
        if array.size(vp_boxes) > 0
            for i = 0 to array.size(vp_boxes) - 1
                box.delete(array.get(vp_boxes, i))
            array.clear(vp_boxes)

    // 2) CALCULATION
    if eff_vp_enable and vp_dirty
        array.fill(vp_volArray, 0.0)

        float lMin = na
        float step = na

        if not vp_is_full
            // =======================
            // VISIBLE MODE (exact legacy window) + faster distribution
            // =======================

            int vStart = chart.left_visible_bar_time
            int vEnd   = chart.right_visible_bar_time

            float hMax_vis = na
            float lMin_vis = na
            bool  found = false

            int LOOKBACK_CAP = 3999
            int loopLimit = math.min(bar_index, LOOKBACK_CAP)

            // SCAN 1: price range over visible window (legacy logic)
            for ii = 0 to loopLimit
                ops_vp_scan += 1
                int t = time[ii]
                if t < vStart
                    break
                if t <= vEnd
                    if not found
                        hMax_vis := high[ii]
                        lMin_vis := low[ii]
                        found := true
                    else
                        hMax_vis := math.max(hMax_vis, high[ii])
                        lMin_vis := math.min(lMin_vis, low[ii])

            if not found
                hMax_vis := high
                lMin_vis := low

            // IMPORTANT: assign to OUTER lMin/step (no redeclare!)
            lMin := lMin_vis
            float rng_vis = hMax_vis - lMin_vis
            if rng_vis == 0
                rng_vis := syminfo.mintick * 100
            step := rng_vis / vp_rows

            array.fill(vp_volArray, 0.0)

            // SCAN 2: distribution (same look as legacy for normal candles; bounded for huge spans)
            int BIN_CAP    = 64
            int SAMPLE_CAP = 64

            for ii = 0 to loopLimit
                int t = time[ii]
                if t < vStart
                    break
                if t <= vEnd
                    float h = high[ii]
                    float l = low[ii]
                    float v = volume[ii]

                    int iH = int(math.floor((h - lMin) / step))
                    int iL = int(math.floor((l - lMin) / step))

                    if iH >= vp_rows
                        iH := vp_rows - 1
                    if iL < 0
                        iL := 0

                    int bins = (iH - iL) + 1
                    if bins > 0
                        if bins <= BIN_CAP
                            float vBin = v / bins
                            for k = iL to iH
                                array.set(vp_volArray, k, array.get(vp_volArray, k) + vBin)
                        else
                            float span = h - l
                            int samples = SAMPLE_CAP
                            float vS = v / samples
                            for s = 0 to samples - 1
                                float tt = (samples == 1) ? 0.0 : (float(s) / float(samples - 1))
                                float p  = l + span * tt
                                int r = int(math.floor((p - lMin) / step))
                                r := r < 0 ? 0 : r >= vp_rows ? (vp_rows - 1) : r
                                array.set(vp_volArray, r, array.get(vp_volArray, r) + vS)

        else
            // ---------------- Full TF (complete) ----------------
            if not na(full_min_k) and not na(full_max_k)
                float band_f = syminfo.mintick * vp_full_band_ticks

                float f_min_p = full_min_k * band_f
                float f_max_p = (full_max_k + 1) * band_f

                lMin := f_min_p
                float rng = f_max_p - f_min_p
                if rng == 0
                    rng := syminfo.mintick * 100
                step := rng / vp_rows

                float band_to_row = band_f / step

                int[] keys = map.keys(vp_map)
                if array.size(keys) > 0
                    for ii = 0 to array.size(keys) - 1
                        ops_vp_scan += 1
                        int k = array.get(keys, ii)
                        float vol = nz(map.get(vp_map, k), 0.0)

                        int r_idx = int(math.floor((k - full_min_k) * band_to_row))
                        r_idx := r_idx < 0 ? 0 : r_idx >= vp_rows ? vp_rows - 1 : r_idx
                        array.set(vp_volArray, r_idx, array.get(vp_volArray, r_idx) + vol)

        // If mapping failed, do nothing (avoid NaNs in draw)
        if not na(lMin) and not na(step)
            // 3) Smoothing
            array.fill(vp_smtArray, 0.0)
            float maxV = 0.0
            float sumV = 0.0
            int actB   = 0

            for j = 0 to vp_rows - 1
                float s = 0.0
                int c = 0
                for x = -vp_smooth to vp_smooth
                    int idx = j + x
                    if idx >= 0 and idx < vp_rows
                        s += array.get(vp_volArray, idx)
                        c += 1

                float val = (c > 0) ? s / c : 0.0
                array.set(vp_smtArray, j, val)

                if val > 0
                    sumV += val
                    actB += 1
                    if val > maxV
                        maxV := val

            // 4) Threshold
            float avgV = (actB > 0) ? sumV / actB : 0.0
            float thres = maxV

            if eff_vp_smart and avgV > 0
                thres := avgV * vp_clip
                if thres == 0
                    thres := maxV

            // 5) Drawing
            int xLoc = bar_index + vp_offset
            int xBarsStart = bar_index + vp_pivot_offset + vp_bars_shift

            if maxV > 0
                if vp_is_bars
                    int vp_render_rows = math.min(VP_BOX_BUDGET, vp_rows * 2)
                    vp_render_rows := math.max(vp_rows, vp_render_rows)
                    if array.size(vp_bars_render) != vp_render_rows
                        vp_bars_render := array.new_float(vp_render_rows, 0.0)

                    if vp_render_rows == vp_rows
                        for r = 0 to vp_rows - 1
                            array.set(vp_bars_render, r, array.get(vp_smtArray, r))
                    else
                        float denom = float(vp_render_rows - 1)
                        float scale = float(vp_rows - 1) / denom
                        for r = 0 to vp_render_rows - 1
                            float u = float(r) * scale
                            int a = int(math.floor(u))
                            int b = math.min(a + 1, vp_rows - 1)
                            float f = u - float(a)
                            float va = array.get(vp_smtArray, a)
                            float vb = array.get(vp_smtArray, b)
                            array.set(vp_bars_render, r, va * (1.0 - f) + vb * f)

                    float maxV_r = 0.0
                    float sumV_r = 0.0
                    int actB_r = 0
                    for r = 0 to vp_render_rows - 1
                        float vv = array.get(vp_bars_render, r)
                        if vv > 0
                            sumV_r += vv
                            actB_r += 1
                            if vv > maxV_r
                                maxV_r := vv

                    float avgV_r = (actB_r > 0) ? (sumV_r / actB_r) : 0.0
                    float thres_r = maxV_r
                    if eff_vp_smart and avgV_r > 0
                        thres_r := avgV_r * vp_clip
                        if thres_r == 0
                            thres_r := maxV_r

                    float step_render = (step * vp_rows) / vp_render_rows
                    float min_intens = vp_is_full ? 0.006 : 0.0015

                    if maxV_r > 0
                        for r = 0 to vp_render_rows - 1
                            float valr = array.get(vp_bars_render, r)
                            if valr > 0
                                float intens = valr / thres_r
                                if intens > 1.0
                                    intens := 1.0
                                float intens_c = math.pow(intens, 0.65)
                                if intens_c > min_intens
                                    ops_vp_draw += 1
                                    int len_bi = int(math.round(intens_c * vp_bars_w))
                                    if len_bi < 2
                                        len_bi := 2
                                    float y1 = lMin + (r * step_render)
                                    float y2 = lMin + ((r + 1) * step_render)
                                    int alpha = 85 - int(math.round(intens_c * 75))
                                    alpha := alpha < 0 ? 0 : alpha > 95 ? 95 : alpha
                                    color fill_col = color.new(vp_color, alpha)
                                    color border_col = color.new(vp_color, 92)
                                    box bx = box.new(xBarsStart - len_bi, y2, xBarsStart, y1, xloc=xloc.bar_index, bgcolor=fill_col, border_color=border_col)
                                    array.push(vp_boxes, bx)
                else
                    for j = 0 to vp_rows - 1
                        float val = array.get(vp_smtArray, j)
                        if val > 0
                            float y1 = lMin + (j * step)
                            float y2 = lMin + ((j + 1) * step)

                            float intens = val / thres
                            if intens > 1.0
                                intens := 1.0

                            float min_intens = vp_is_full ? 0.01 : 0.003
                            if intens > min_intens
                                ops_vp_draw += 1
                                color col = color.from_gradient(intens, 0, 1, color.new(vp_color, 100), color.new(vp_color, 0))
                                line ln = line.new(x1=xLoc, y1=y1, x2=xLoc, y2=y2, xloc=xloc.bar_index, color=col, width=vp_width)
                                array.push(vp_lines, ln)

    // --- Update trackers ---
    last_vp_mode := vp_mode
    last_vp_style := vp_style
    last_left    := chart.left_visible_bar_time
    last_right   := chart.right_visible_bar_time
    if vp_is_full
        last_full_bar := bar_index
    vp_dirty := false


// -------------------------------------------------------------------------
// DEBUG PANEL (Stage 0)
// -------------------------------------------------------------------------
// Update Peaks
if ops_trend > peak_ops_trend
    peak_ops_trend := ops_trend
if (ops_vp_scan + ops_vp_draw) > peak_ops_vp
    peak_ops_vp := (ops_vp_scan + ops_vp_draw)

if debug_on and barstate.islast
    if na(tbl_dbg)
        tbl_dbg := table.new(position.bottom_right, 2, 15, bgcolor=color.new(color.black, 50), frame_width=1, frame_color=color.gray)

    // Header
    table.cell(tbl_dbg, 0, 0, "Metric", text_color=color.white, text_size=size.small)
    table.cell(tbl_dbg, 1, 0, "Value", text_color=color.white, text_size=size.small)

    // Security Calls
    table.cell(tbl_dbg, 0, 1, "Sec Calls", text_color=color.white, text_size=size.small)
    table.cell(tbl_dbg, 1, 1, str.tostring(active_sec_calls), text_color=color.yellow, text_size=size.small)

    // Heavy Ops
    table.cell(tbl_dbg, 0, 2, "Ops Trend (Peak)", text_color=color.white, text_size=size.small)
    table.cell(tbl_dbg, 1, 2, str.tostring(ops_trend) + " (" + str.tostring(peak_ops_trend) + ")", text_color=ops_trend > 0 ? color.orange : color.green, text_size=size.small)

    table.cell(tbl_dbg, 0, 4, "Ops VP (Peak)", text_color=color.white, text_size=size.small)
    table.cell(tbl_dbg, 1, 4, str.tostring(ops_vp_scan + ops_vp_draw) + " (" + str.tostring(peak_ops_vp) + ")", text_color=(ops_vp_scan + ops_vp_draw) > 1000 ? color.red : color.green, text_size=size.small)

    table.cell(tbl_dbg, 0, 5, "Ops DIV", text_color=color.white, text_size=size.small)
    table.cell(tbl_dbg, 1, 5, str.tostring(ops_div), text_color=ops_div > 0 ? color.orange : color.green, text_size=size.small)

    table.cell(tbl_dbg, 0, 6, "Ops BB", text_color=color.white, text_size=size.small)
    table.cell(tbl_dbg, 1, 6, str.tostring(ops_bb), text_color=ops_bb > 0 ? color.orange : color.green, text_size=size.small)

    // Flags Status
    table.cell(tbl_dbg, 0, 8, "ON_PS", text_color=color.white, text_size=size.small)
    table.cell(tbl_dbg, 1, 8, str.tostring(ON_PS), text_color=ON_PS ? color.green : color.red, text_size=size.small)

    table.cell(tbl_dbg, 0, 9, "ON_MTF_OV", text_color=color.white, text_size=size.small)
    table.cell(tbl_dbg, 1, 9, str.tostring(ON_MTF_OV), text_color=ON_MTF_OV ? color.green : color.red, text_size=size.small)

    table.cell(tbl_dbg, 0, 10, "ON_FVG1", text_color=color.white, text_size=size.small)
    table.cell(tbl_dbg, 1, 10, str.tostring(ON_FVG1), text_color=ON_FVG1 ? color.green : color.red, text_size=size.small)

    table.cell(tbl_dbg, 0, 11, "ON_SESS_1ST", text_color=color.white, text_size=size.small)
    table.cell(tbl_dbg, 1, 11, str.tostring(ON_SESS_1ST), text_color=ON_SESS_1ST ? color.green : color.red, text_size=size.small)
else
    if not na(tbl_dbg)
        table.delete(tbl_dbg)
        tbl_dbg := na


// --- Stage 2: ADR/Today Range Calculation ---
float d_range = na
float adr = na
float adr_pct = na

// 1. Daily Range (Developing) - Uses lookahead to capture current developing range on intraday
d_range := request.security(syminfo.tickerid, "D", high - low, lookahead=barmerge.lookahead_on)

// 2. ADR (Historical/Stable)
adr := request.security(syminfo.tickerid, "D", ta.sma(high - low, eff_adr_len))
active_sec_calls += 2

// 3. ADR %
if not na(d_range) and not na(adr) and adr > 0
    adr_pct := (d_range / adr) * 100

// Optional Debug Info
plot(adr_pct, title="ADR %", color=color.new(color.white, 100), display=display.data_window + display.status_line)

// ADR Label removed as per design requirements (Panel only)
var label lbl_adr = na
label.delete(lbl_adr)

// Update Panel Row 9 (ADR%)
if not na(info_panel) and barstate.islast
    string adr_txt = "ADR% " + (not na(adr_pct) ? str.tostring(adr_pct, "#.#") + "%" : "n/a")
    table.cell(table_id=info_panel, column=0, row=9, text=adr_txt, text_size=size.small, text_color=color.silver, tooltip="ADR% = progress within Average Daily Range; helps avoid entering near exhaustion.")
    table.merge_cells(info_panel, 0, 9, 2, 9)


// --- Stage 3: ATR Expansion Logic ---
float calc_atr = ta.atr(eff_atr_len)
float atr_ref  = ta.sma(calc_atr, eff_atr_norm)
float atr_norm = (not na(atr_ref) and atr_ref > 0) ? (calc_atr / atr_ref) : 1.0

bool atr_is_low  = atr_norm < eff_atr_low
bool atr_is_high = atr_norm > eff_atr_high


// --- Stage 4: Keltner Channel & Squeeze Detector ---
// KC Calc
float kc_mid = ta.ema(close, eff_kc_len)
float kc_range = ta.atr(eff_kc_len)
float kc_up = kc_mid + (kc_range * eff_kc_mult)
float kc_dn = kc_mid - (kc_range * eff_kc_mult)

// BB Calc (Specific for Squeeze - Standard 20/2.0 per Regime defaults)
[s_bb_mid, s_bb_up, s_bb_dn] = ta.bb(close, eff_bb_len, eff_bb_mult)

// KC Squeeze: BB is fully INSIDE KC
bool squeeze_kc = (s_bb_up < kc_up) and (s_bb_dn > kc_dn)


// --- Stage 5 (Regime Upgrade): Squeeze Integration ---
// Trend / Range / Squeeze

var string regime_state = "Range"
var color regime_bg = na

// Calculate Regime regardless of display for history
// Calc BBW (Standard 20, 2.0) - Reusing Stage 4 values
bbw = (s_bb_up - s_bb_dn) / s_bb_mid
avg_bbw = ta.sma(bbw, 50)

// 1. BBW Squeeze (Original Logic)
bool is_squeeze_bbw = bbw < (avg_bbw * 0.7)

// 2. Combine with KC Squeeze (Stage 4)
bool is_squeeze = is_squeeze_bbw // Default
if eff_use_kc_squeeze
    if squeeze_strict
        is_squeeze := is_squeeze_bbw and squeeze_kc
    else
        is_squeeze := is_squeeze_bbw or squeeze_kc

// Calc ADX
[_, _, adx_r] = ta.dmi(eff_adx_len, eff_adx_len)
is_trend = adx_r > eff_adx_th

// Logic
if is_squeeze
    regime_state := "SQUEEZE"
    regime_bg := color.new(color.yellow, 90)
else if is_trend
    regime_state := "TREND"
    regime_bg := color.new(color.blue, 92)
else
    regime_state := "RANGE"
    regime_bg := na

// Update Panel (Moved Up)
var string reg_conf = "RANGE"
var color reg_bg_conf = color.new(color.gray, 100)
var string rvol_conf = ""
var color rvol_bg_conf = color.new(color.gray, 100)
var string z_conf = ""
var color z_bg_conf = color.new(color.gray, 100)
if eff_regime_panel and not na(info_panel) and barstate.islast
    color c_reg_bg_live = regime_state == "SQUEEZE" ? color.new(color.yellow, 30) : regime_state == "TREND" ? color.new(color.blue, 30) : color.new(color.gray, 100)
    string m_reg = f_marker(panel_show_live and barstate.isrealtime, barstate.isconfirmed)
    bool reg_upd = barstate.isconfirmed or not barstate.isrealtime
    reg_conf := reg_upd ? regime_state : reg_conf
    reg_bg_conf := reg_upd ? c_reg_bg_live : reg_bg_conf

    string reg_disp = panel_show_live ? regime_state : reg_conf
    color reg_bg_disp = panel_show_live ? c_reg_bg_live : reg_bg_conf
    table.cell(info_panel, 0, 12, "REG", text_size=size.small, text_color=color.silver)
    table.cell(info_panel, 1, 12, reg_disp, text_size=size.small, text_color=color.white, bgcolor=reg_bg_disp)
    table.cell(info_panel, 2, 12, m_reg, text_size=size.normal, text_color=MARKER_COLOR, bgcolor=reg_bg_disp, width=1)

    // Row 13: RVOL
    if eff_rvol_enabled
        string rv_code = rvol_val < rvol_th_1 ? "L" : rvol_val < rvol_th_2 ? "M" : rvol_val < rvol_th_3 ? "H" : "E"
        string rvol_txt_live = str.tostring(rvol_val, "#.##") + "x " + rv_code
        color c_rv_p_live = rvol_state == "3" ? color.new(color.red, 30) : rvol_state == "2" ? color.new(color.orange, 30) : color.new(color.gray, 100)

        bool rvol_init = rvol_conf == ""
        rvol_conf := rvol_init ? rvol_txt_live : rvol_conf
        rvol_bg_conf := rvol_init ? c_rv_p_live : rvol_bg_conf
        bool rvol_upd = barstate.isconfirmed or not barstate.isrealtime
        rvol_conf := rvol_upd ? rvol_txt_live : rvol_conf
        rvol_bg_conf := rvol_upd ? c_rv_p_live : rvol_bg_conf

        string rvol_disp = panel_show_live ? rvol_txt_live : rvol_conf
        color rvol_bg_disp = panel_show_live ? c_rv_p_live : rvol_bg_conf
        table.cell(info_panel, 0, 13, "VOL", text_size=size.small, text_color=color.silver)
        table.cell(info_panel, 1, 13, rvol_disp, text_size=size.small, text_color=color.white, bgcolor=rvol_bg_disp)
        table.cell(info_panel, 2, 13, m_reg, text_size=size.normal, text_color=MARKER_COLOR, bgcolor=rvol_bg_disp, width=1)

    // Row 14: VWAP Z
    if eff_vwap_enabled and eff_vwap_z and not na(z_val)
        float abs_z = math.abs(z_val)
        string z_code = abs_z < z_th_entry ? "N" : abs_z < z_th_tp ? "S" : abs_z < z_th_ext ? "T" : "E"
        string z_txt_live = str.tostring(z_val, "#.1") + "Ïƒ " + z_code

        color c_z_p_live = str.contains(stretch_state, "EXTREME") ? color.new(color.red, 30) : str.contains(stretch_state, "TP") ? color.new(color.orange, 30) : color.new(color.gray, 100)

        bool z_init = z_conf == ""
        z_conf := z_init ? z_txt_live : z_conf
        z_bg_conf := z_init ? c_z_p_live : z_bg_conf
        bool z_upd = barstate.isconfirmed or not barstate.isrealtime
        z_conf := z_upd ? z_txt_live : z_conf
        z_bg_conf := z_upd ? c_z_p_live : z_bg_conf

        string z_disp = panel_show_live ? z_txt_live : z_conf
        color z_bg_disp = panel_show_live ? c_z_p_live : z_bg_conf
        table.cell(info_panel, 0, 14, "VWP", text_size=size.small, text_color=color.silver)
        table.cell(info_panel, 1, 14, z_disp, text_size=size.small, text_color=color.white, bgcolor=z_bg_disp)
        table.cell(info_panel, 2, 14, m_reg, text_size=size.normal, text_color=MARKER_COLOR, bgcolor=z_bg_disp, width=1)


//------------------------------------------------------- Squeeze Box Module -------------------------------------------------------
// Stage 6: Squeeze Box logic

var SqState sqs = SqState.new(na, na, false, false, na)

// Condition
bool in_sq_condition = (regime_state == "SQUEEZE")

bool sq_start = in_sq_condition and not in_sq_condition[1]
bool sq_end = not in_sq_condition and in_sq_condition[1]

// Events
bool sq_break_up = false
bool sq_break_dn = false

if eff_sq_box_enabled
    if sq_start
        sqs.hi := high
        sqs.lo := low
        sqs.active := true
        sqs.locked := false

        // Init/Reset (Single Object Recycle)
        if na(sqs.id_box)
            sqs.id_box := box.new(bar_index, high, bar_index, low, border_color=color.new(color.yellow, 30), bgcolor=color.new(color.yellow, 90))
        else
            box.set_left(sqs.id_box, bar_index)
            box.set_right(sqs.id_box, bar_index)
            box.set_top(sqs.id_box, high)
            box.set_bottom(sqs.id_box, low)
            box.set_border_style(sqs.id_box, line.style_solid)

    else if sqs.active
        // Update H/L
        sqs.hi := math.max(sqs.hi, high)
        sqs.lo := math.min(sqs.lo, low)

        box.set_top(sqs.id_box, sqs.hi)
        box.set_bottom(sqs.id_box, sqs.lo)
        box.set_right(sqs.id_box, bar_index + 1)

        if sq_end
            sqs.active := false
            if sq_lock
                sqs.locked := true
                box.set_right(sqs.id_box, bar_index + 5)
                box.set_border_style(sqs.id_box, line.style_dashed)

    else if sqs.locked
        if barstate.islast
            box.set_right(sqs.id_box, bar_index + 5)

        // Break Events
        if close > sqs.hi and close[1] <= sqs.hi
            sq_break_up := true
        if close < sqs.lo and close[1] >= sqs.lo
            sq_break_dn := true


//--------------------------------------------------------- CONF VWAP (Lightweight) ---------------------------------------------------------
float conf_vwap_val = na
float conf_z_val = na

if conf_use_vwap_quality
    bool use_sess = (conf_vwap_mode == "Session VWAP") or (conf_vwap_mode == "Auto" and tf_sec <= 3600)

    // Session VWAP
    var float vs_c_cumVol = 0.0
    var float vs_c_cumPV  = 0.0
    var float vwap_c_sess = na
    bool c_new_day = ta.change(time("D"))

    if use_sess
        if c_new_day
            vs_c_cumVol := 0.0
            vs_c_cumPV  := 0.0

        vs_c_cumVol += volume
        vs_c_cumPV  += volume * hlc3

        if vs_c_cumVol > 0
            vwap_c_sess := vs_c_cumPV / vs_c_cumVol
            conf_vwap_val := vwap_c_sess

    // Weekly VWAP
    var float vw_c_cumVol = 0.0
    var float vw_c_cumPV  = 0.0
    var float vwap_c_week = na
    bool c_new_week = ta.change(time("W"))

    if not use_sess
        if c_new_week
            vw_c_cumVol := 0.0
            vw_c_cumPV  := 0.0

        vw_c_cumVol += volume
        vw_c_cumPV  += volume * hlc3

        if vw_c_cumVol > 0
            vwap_c_week := vw_c_cumPV / vw_c_cumVol
            conf_vwap_val := vwap_c_week

    // Z-Score Calculation
    bool reuse_z = false
    if eff_vwap_enabled and eff_vwap_z and not na(z_val)
        if (use_sess and eff_vwap_anchor == "Session (Daily Reset)") or (not use_sess and eff_vwap_anchor == "Weekly")
            reuse_z := true

    if reuse_z
        conf_z_val := z_val
    else if not na(conf_vwap_val)
        // Independent Calculation
        // Reuse vwap_stdev_len (Default 100)
        float dev_c = close - conf_vwap_val
        float sigma_c = ta.stdev(dev_c, vwap_stdev_len)
        if sigma_c > 0
            conf_z_val := dev_c / sigma_c


//--------------------------------------------------------- CONF Engine v2: Core + Confirm + Regime Gate ---------------------------------------------------------

float conf_score = 50.0
string conf_bias = "Neutral"
float final_raw = 0.0 // Exposed for Alerts

eff_calc_conf = eff_show_conf_meter or show_conf_bg

// Core Weights
float W_FR_CORE = 4.0
float W_FVG_CORE = 4.0
float W_KAMA_CORE = 2.0

// Variables for Smoothing & State
var int conf_state_engine = 0 // 0=Neut, 1=Bull, -1=Bear

if eff_calc_conf
    // --- 1. Core Score Calculation ---
    float core_w_sum = 0.0
    float core_raw_sum = 0.0

    // Fractals (Core)
    if eff_fractals_plot
        core_w_sum += W_FR_CORE
        core_raw_sum += (fr_state_inf * W_FR_CORE)

    // FVG (Core + Regime Gate)
    // Gate: Dampen FVG in SQUEEZE
    float w_fvg_effective = W_FVG_CORE
    if regime_state == "SQUEEZE"
        w_fvg_effective := W_FVG_CORE * 0.35

    // Always available (Core). FVG State is calculated globally on Current TF.
    core_w_sum += w_fvg_effective
    core_raw_sum += (fvg_state_inf * w_fvg_effective)

    // KAMA (Core)
    float kama_val_score = 0.0
    if sig_kama_bull
        kama_val_score := 1.0
    else if sig_kama_bear
        kama_val_score := -1.0

    core_w_sum += W_KAMA_CORE
    core_raw_sum += (kama_val_score * W_KAMA_CORE)

    // Calculate Core Raw (-1.0 to 1.0)
    float core_raw = (core_w_sum > 0) ? (core_raw_sum / core_w_sum) : 0.0

    // --- 2. Smoothing & Hysteresis (AUTO SCALED) ---
    float core_smooth = ta.ema(core_raw, eff_core_ema_len)

    // Volatility-Scaled Thresholds
    float core_vol = ta.stdev(core_raw, eff_vol_len)
    // Default safe values if vol is 0 (early bars)
    float enter_th = eff_enter_k * (core_vol > 0 ? core_vol : 0.1)
    float exit_th  = eff_exit_k  * (core_vol > 0 ? core_vol : 0.1)

    // State Machine
    bool enter_bull = core_smooth > enter_th
    bool enter_bear = core_smooth < -enter_th

    // Persistence Check
    float bull_persist_count = math.sum(enter_bull ? 1 : 0, eff_persist_bars)
    bool enter_bull_p = bull_persist_count == eff_persist_bars

    float bear_persist_count = math.sum(enter_bear ? 1 : 0, eff_persist_bars)
    bool enter_bear_p = bear_persist_count == eff_persist_bars

    if conf_state_engine == 0 // Neutral
        if enter_bull_p
            conf_state_engine := 1
        else if enter_bear_p
            conf_state_engine := -1
    else if conf_state_engine == 1 // Bull
        if core_smooth < exit_th
            conf_state_engine := 0
    else if conf_state_engine == -1 // Bear
        if core_smooth > -exit_th
            conf_state_engine := 0

    // --- 3. Confirm-Events (Overlay) ---
    // Trendlines & Segments with Decay
    var float ov_tl = 0.0
    var float ov_seg = 0.0

    // Update Overlay States
    if sig_tl_bull
        ov_tl := 1.0
    else if sig_tl_bear
        ov_tl := -1.0
    else
        ov_tl := ov_tl * eff_ov_decay

    if sig_seg_bull
        ov_seg := 1.0
    else if sig_seg_bear
        ov_seg := -1.0
    else
        ov_seg := ov_seg * eff_ov_decay

    // Calculate Overlay Contribution
    // Weighted Average of active overlays
    float ov_w_sum = 0.0
    float ov_raw_sum = 0.0

    if eff_plot_trendline
        ov_w_sum += 1.0
        ov_raw_sum += ov_tl

    if eff_plot_segments
        ov_w_sum += 1.0
        ov_raw_sum += ov_seg

    float overlay_raw = (ov_w_sum > 0) ? (ov_raw_sum / ov_w_sum) : 0.0

    // --- Stage 8: Confirm-Events Upgrade (ATR Filter) ---
    float ov_scale = 1.0
    if atr_is_low
        ov_scale := 0.60
    else if atr_is_high
        ov_scale := 1.00

    // Clamp Overlay (Anti-Flip)
    float overlay_clamped = math.max(-eff_ov_clamp, math.min(eff_ov_clamp, overlay_raw)) * ov_scale

    // --- 6.1 ADR Exhaustion Flags (Stage 6) ---
    bool adr_warn = eff_use_adr_gate and not na(adr_pct) and adr_pct >= eff_adr_warn
    bool adr_hard = eff_use_adr_gate and not na(adr_pct) and adr_pct >= eff_adr_hard

    // --- 4. Final Calculation & Confidence Gate ---
    final_raw := core_smooth + overlay_clamped
    // Clamp Final
    final_raw := math.max(-1.0, math.min(1.0, final_raw))

    // Regime Confidence Gate (Dampen the Score magnitude, but preserve direction/state)
    float conf_gate = 1.0
    if regime_state == "SQUEEZE"
        conf_gate := 0.40
    else if regime_state == "RANGE"
        conf_gate := 0.70

    // ADR Gate Add-on (Confidence Dampening)
    if adr_warn
        conf_gate := conf_gate * 0.85
    if adr_hard
        conf_gate := conf_gate * 0.70

    // Apply Gate to Magnitude relative to 50
    // Score 0-100. Center 50.
    // 50 + (50 * final_raw * gate)
    conf_score := 50 + (50 * final_raw * conf_gate)

    // Determine Display Bias based on ENGINE STATE, not just score
    conf_bias := conf_state_engine == 1 ? "BULL" : conf_state_engine == -1 ? "BEAR" : "NEUT"

    // --- 5. Quality Tag (H/M/L) ---
    // Agreement: How many cores match the state?
    // Cores: FR, FVG, KAMA
    float aligned_core = 0.0
    float active_core = 0.0
    int state_sign = conf_state_engine // 1, -1, 0

    // Helper for sign match (0 matches nothing)
    // FR
    if eff_fractals_plot
        active_core += 1.0
        if state_sign != 0 and math.sign(fr_state_inf) == state_sign
            aligned_core += 1.0

    // FVG (Use effective weight presence)
    if eff_plot_fvg1 or eff_plot_fvg2
        active_core += 1.0
        if state_sign != 0 and math.sign(fvg_state_inf) == state_sign
            aligned_core += 1.0

    // KAMA
    active_core += 1.0
    float kama_sign = sig_kama_bull ? 1.0 : sig_kama_bear ? -1.0 : 0.0
    if state_sign != 0 and kama_sign == state_sign
        aligned_core += 1.0

    float agreement = (active_core > 0) ? (aligned_core / active_core) : 0.0
    float magnitude = math.abs(final_raw)

    string quality = "L"
    if magnitude >= 0.35 and agreement >= 0.66 and regime_state != "SQUEEZE"
        quality := "H"
    else if magnitude >= 0.20 and agreement >= 0.50
        quality := "M"
    else
        quality := "L"

    // --- Stage 9: Quality Degrade (ADR/ATR) ---
    if adr_warn
        if quality == "H"
            quality := "M"
        else if quality == "M"
            quality := "L"

    if adr_hard
        quality := "L"

    // Optional: Low ATR in Non-Trend degrade
    if atr_is_low and regime_state != "TREND" and quality == "H"
        quality := "M"

    // --- Stage 10: VWAP Quality Gate (Option A) ---
    string align_flag = ""
    if conf_use_vwap_quality and not na(conf_vwap_val)
        // 1. Map to Numeric (0=L, 1=M, 2=H, 3=E)
        int q_num = quality == "H" ? 2 : quality == "M" ? 1 : 0

        // 2. Alignment Logic (Bias != NEUT)
        if conf_state_engine != 0
            bool is_aligned = (conf_state_engine == 1 and close > conf_vwap_val) or (conf_state_engine == -1 and close < conf_vwap_val)

            if is_aligned
                q_num := math.min(q_num + 1, 3) // Cap at 3 (E)
                align_flag := "A"
            else
                q_num := math.max(q_num - 1, 0) // Floor at 0 (L)
                align_flag := "X"

        // 3. Stretch Penalty (Anti-Chase via |Z|)
        if not na(conf_z_val)
            float abs_z = math.abs(conf_z_val)
            int penalty = 0

            // Thresholds: z_th_entry, z_th_tp, z_th_ext (Global Inputs)
            if conf_z_penalty_mode == "Aggressive"
                if abs_z >= z_th_ext
                    penalty := -1
                else if abs_z >= z_th_tp
                    penalty := -1
            else if conf_z_penalty_mode == "Conservative"
                if abs_z >= z_th_ext
                    penalty := -3
                else if abs_z >= z_th_tp
                    penalty := -2
                else if abs_z >= z_th_entry
                    penalty := -1
            else // Default
                if abs_z >= z_th_ext
                    penalty := -2
                else if abs_z >= z_th_tp
                    penalty := -1

            q_num := math.max(q_num + penalty, 0)

        // 4. Backmap to L/M/H/E
        quality := q_num == 3 ? "E" : q_num == 2 ? "H" : q_num == 1 ? "M" : "L"

    // --- 6. Visualization (Panel) ---
    // BULL 72 H / NEUT 50 L
    if barstate.islast and eff_show_conf_meter and not na(info_panel)
        string panel_txt_live = conf_bias + " " + str.tostring(math.round(conf_score)) + " " + quality
        if align_flag != ""
            panel_txt_live := panel_txt_live + " " + align_flag

        color c_conf_live = conf_state_engine == 1 ? color.new(color.green, 30) : conf_state_engine == -1 ? color.new(color.red, 30) : color.new(color.gray, 100)

        // Neutral remains transparent
        var string conf_txt_conf = ""
        var color conf_bg_conf = color.new(color.gray, 100)
        bool conf_init = conf_txt_conf == ""
        conf_txt_conf := conf_init ? panel_txt_live : conf_txt_conf
        conf_bg_conf := conf_init ? c_conf_live : conf_bg_conf
        bool conf_upd = barstate.isconfirmed or not barstate.isrealtime
        conf_txt_conf := conf_upd ? panel_txt_live : conf_txt_conf
        conf_bg_conf := conf_upd ? c_conf_live : conf_bg_conf

        string conf_txt_disp = panel_show_live ? panel_txt_live : conf_txt_conf
        color conf_bg_disp = panel_show_live ? c_conf_live : conf_bg_conf
        string m_conf = f_marker(panel_show_live and barstate.isrealtime, barstate.isconfirmed)

        table.cell(info_panel, 0, 11, "CONF", text_size=size.small, text_color=color.silver)
        table.cell(info_panel, 1, 11, conf_txt_disp, text_size=size.small, text_color=color.white, bgcolor=conf_bg_disp)
        table.cell(info_panel, 2, 11, m_conf, text_size=size.normal, text_color=MARKER_COLOR, bgcolor=conf_bg_disp, width=1)

// --- CENTRALIZED BACKGROUND ROUTING (Fix Bug #2) ---
color bg_final = na

// Logic to filter regime_bg based on mode
color regime_bg_filtered = na
if eff_regime_bg_mode == "Squeeze BG" and regime_state == "SQUEEZE"
    regime_bg_filtered := regime_bg
else if eff_regime_bg_mode == "Trend BG" and regime_state == "TREND"
    regime_bg_filtered := regime_bg
else if eff_regime_bg_mode == "Both"
    regime_bg_filtered := regime_bg

// Logic for Confluence BG (New)
color conf_bg_color = na
if show_conf_bg
    if conf_score > 55
        conf_bg_color := color.new(color.green, transp_bg)
    else if conf_score < 45
        conf_bg_color := color.new(color.red, transp_bg)
    else
        conf_bg_color := color.new(color.gray, 100) // Transparent Neutral

// Priority 1: Session (Highest)
if eff_sess_bg_enable and not na(bg_sess_color)
    bg_final := bg_sess_color
// Priority 2: Confluence BG (New)
else if show_conf_bg
    bg_final := conf_bg_color
// Priority 3: Regime
else if not na(regime_bg_filtered)
    bg_final := regime_bg_filtered

// Single Output
bgcolor(bg_final, title="MCCS Master Background")


// --- Stage 5: Alerts (Centralized) ---
// alert_profile: Minimal, Normal, Moderate
// Events based on registry

// 1. Prepare Conditions
bool al_tl_break = (sig_tl_bull and not sig_tl_bull[1]) or (sig_tl_bear and not sig_tl_bear[1])
bool al_div      = (sig_div_bull and not sig_div_bull[1]) or (sig_div_bear and not sig_div_bear[1])
bool al_conf_cross = ta.crossover(conf_score, 75) or ta.crossunder(conf_score, 25) // Tighter Thresholds for Alerts
bool al_regime_chg = regime_state != regime_state[1]

// 2. Cooldown Logic
var int last_alert_time_tl = 0
var int last_alert_time_div = 0
var int last_alert_time_reg = 0
var int last_alert_time_conf = 0

// 3. Execution
if alert_profile != "Off"
    // TL Break (Minimal+)
    if (alert_profile == "Minimal" or alert_profile == "Normal" or alert_profile == "Moderate")
        if al_tl_break and (bar_index - last_alert_time_tl > alert_cooldown)
            alert("MCCS: Trendline Breakout Detected", alert.freq_once_per_bar_close)
            last_alert_time_tl := bar_index

    // Normal + Moderate
    if (alert_profile == "Normal" or alert_profile == "Moderate")
        if al_div and (bar_index - last_alert_time_div > alert_cooldown)
            alert("MCCS: Divergence Detected", alert.freq_once_per_bar_close)
            last_alert_time_div := bar_index

    // Moderate Only
    if alert_profile == "Moderate"
        if al_regime_chg and (bar_index - last_alert_time_reg > alert_cooldown)
            alert("MCCS: Regime Change to " + regime_state, alert.freq_once_per_bar_close)
            last_alert_time_reg := bar_index

        if al_conf_cross and (bar_index - last_alert_time_conf > alert_cooldown)
            alert("MCCS: High Confluence Event (Score: " + str.tostring(conf_score) + ")", alert.freq_once_per_bar_close)
            last_alert_time_conf := bar_index

// Alert Conditions (For TradingView Setup)
// Consolidated for easy selection
alertcondition(al_tl_break, "Trendline Breakout", "Fractal Trendline Breakout")
alertcondition(al_div, "Divergence", "Divergence Detected")
alertcondition(al_regime_chg, "Regime Change", "Market Regime Changed")
alertcondition(al_conf_cross, "Confluence Extreme", "Confluence Score Extreme (75/25)")

// --- Extended Alerts (New Modules) ---
// VWAP
bool al_vwap_cross_up = eff_vwap_enabled and ta.crossover(close, vwap_val)
bool al_vwap_cross_dn = eff_vwap_enabled and ta.crossunder(close, vwap_val)
bool al_z_ext_up      = eff_vwap_enabled and eff_vwap_z and not na(z_val) and z_val >= z_th_ext and z_val[1] < z_th_ext
bool al_z_ext_dn      = eff_vwap_enabled and eff_vwap_z and not na(z_val) and z_val <= -z_th_ext and z_val[1] > -z_th_ext

alertcondition(al_vwap_cross_up, "VWAP Reclaim Up", "Price reclaimed VWAP (Bullish)")
alertcondition(al_vwap_cross_dn, "VWAP Reclaim Down", "Price lost VWAP (Bearish)")
alertcondition(al_z_ext_up, "VWAP Z-Score Extreme High", "Price is extended above VWAP (Extreme)")
alertcondition(al_z_ext_dn, "VWAP Z-Score Extreme Low", "Price is extended below VWAP (Extreme)")

// OR/IB
alertcondition(or_break_up, "OR Breakout Up", "Opening Range Breakout Up")
alertcondition(or_break_dn, "OR Breakout Down", "Opening Range Breakout Down")

// RVOL
bool al_rvol_spike = eff_rvol_enabled and not na(rvol_val) and rvol_val >= 3.0 and rvol_val[1] < 3.0
alertcondition(al_rvol_spike, "RVOL Spike (3x)", "Relative Volume > 3.0 detected")

// Squeeze
alertcondition(sq_start, "Squeeze Start", "Market entered Squeeze Regime")
alertcondition(sq_end, "Squeeze Release", "Market left Squeeze Regime")
alertcondition(sq_break_up, "Squeeze Box Break Up", "Price broke Squeeze Box Up")
alertcondition(sq_break_dn, "Squeeze Box Break Down", "Price broke Squeeze Box Down")
