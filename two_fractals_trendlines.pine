//@version=5

indicator('Two Fractals Trendlines', overlay=true, shorttitle='fr lines', max_bars_back=2000, max_lines_count=500)

general_info        = input.bool(title='General Description', defval=false, tooltip='Use the signals in confluence and as an indication of market tension, which will discharged in higher volatility or trend continuation. 
                     ... context matters.')

//adx, hma and ema1 x ema2 mtf trend info panel
adx_trend           = input.bool(title='MTF Info Panel', defval=false, 
                     tooltip='Provides an overview of multi time frame trends as DMI ADX, HMA slope and EMA1 cross EMA2 (down(red), consolidation(gray), up(blue)) for the current 
                     (C = current tf, these parameters are optimizable) and the supported higher time frames (4H, D, W, M, these indicator parameters are fixed and optimized for Bitcoin).')

//fractals input
fracals_plot        = input.bool(title='Bill Williams Fractals', defval=true, tooltip='Symbol: white triangle. Works as support and resistance level.')
plot_af_bar         = input.bool(false, title='Anticipated Fractal', tooltip='Letter: a. An anticipated Fractal (two bar breakout). Very early trend indication.')

selected_bg_signal  = input.string("None", title="Background Color Signal", options=
                     ["None", "Bill Williams Fractals BG", "Anticipated Fractal BG", "Last 12 Bar BG", "DMI ADX BG", "HMA Slope BG", "MACD Slow Slope BG", "MACD Slope/Fractal Break BG (OR)", "Trend Line/Fractal Break BG (OR)", "Segments BG",
                     "Segments/Fractals BG (OR)", "Segments/Trend Line BG (OR)", "Segments/Fractals/Trend Line BG (OR)",
                     "Segments/Fractals BG (AND)", "Segments/Trend Line BG (AND)", "Segments/Fractals/Trend Line BG (AND)", "Segments/MACD Slope BG (AND)", "MACD Slope/Fractals Break BG (AND)"],
                     group="Background Color Signals:", tooltip="Signals that are alternatively displayed as a background color as a quick verification and a kind of 'backtest'.")


//Bollinger Bands
BB_plot             = input.bool(true, title='Bollinger Bands', group='Bollinger Bands:', tooltip='Works as support and resistence, as reversal zone and as squeeze indicator.')
BB_calc_tog         = input.bool(true, title='Toggle BB Calculation (Standard/Exponential)', group='Bollinger Bands:', tooltip='Works as support and resistence, as reversal zone and as squeeze indicator.
                     Standard -> checked')
near_bb             = input.bool(true, title='Touched BBs only', group='Bollinger Bands:', tooltip='This maintains a better chart overview and works as reversal zone indicator.')
BB_length_1         = input.int(20, minval=1, title='BB Length', group='Bollinger Bands:', tooltip='')
BB_sdev_1           = input.float(2.0, minval=0.001, maxval=3.8, step= 0.2, title='BB 1 StdDev', group='Bollinger Bands:', tooltip='')
BB_sdev_2           = 3//input.float(3.0, minval=0.001, title='BB 2 StdDev', group='Bollinger Bands:', tooltip='')
BB_sdev_3           = 4//input.float(4.0, minval=0.001, title='BB 3 StdDev', group='Bollinger Bands:', tooltip='')
BB_sdev_4           = 5//input.float(5.0, minval=0.001, title='BB 4 StdDev', group='Bollinger Bands:', tooltip='')

//sr lines inputs
plot_sr_lines       = input.bool(false, title='SR Lines', tooltip='Plot horizontal support and resistance levels.', group='SR lines:')
auto_adaption       = input.bool(true, title='Auto Adaption', tooltip='Automatically adapt the Fractal Size and Time Frame based on the current chart timeframe.', group='SR lines:')
extend              = input.bool(false, title='Toggle Line Extention', tooltip='Toggle line extention both/right. To the right = default = not selected', group='SR lines:')
fr_size             = input.int(1, title='Fractal Size', minval=1, step=1, tooltip='The Size of fractals used to plot the SR-levels. The lower the value the more line are drawn.', group='SR lines:')
sr_tf               = input.timeframe('W', title='Time Frame Of Fractals', options=['60', '120', '240', '480', 'D', 'W', 'M', '3M', '6M'], tooltip='The time frame of fractals used to plot the SR-levels.
                     Select always: \'Time Frame Of Fractals\' >= current time frame', group='SR lines:')
fr_source           = input.string('high/low', title='Fractal Source', options=['high/low', 'close'], tooltip='The source of fractals used to plot the SR-levels.', group='SR lines:')

//ema cloud, hma, dmi adx inputs
en_cloud            = input.bool(true, title='EMA Cloud', group='MA cloud, HMA slope, DMI ADX:', tooltip='This EMA cloud works as dynamic support and resistance and as trend indication.
                     A wide cloud indicates high volatility, a narrow cloud indicates low volatility and breakout potential.')
sig_plot            = input.bool(true, title='EMA Cloud Color Signal', group='MA cloud, HMA slope, DMI ADX:', tooltip='EMA1 cross EMA2 color signal')
sma1_plot           = input.bool(true, title='SMA', group='MA cloud, HMA slope, DMI ADX:', tooltip='SMA with slope color')

ema_inp1            = input.int(8, title='EMA1 Length', minval=1, group='MA cloud, HMA slope, DMI ADX:', tooltip="Value for current time frame. Also affects 'Entry Direction' -> 'auto'")
ema_inp2            = input.int(21, title='EMA2 Length', minval=1, group='MA cloud, HMA slope, DMI ADX:', tooltip="Value for current time frame. Also affects 'Entry Direction' -> 'auto'")
sma1_inp            = input.int(50, title='SMA', minval=1, group='MA cloud, HMA slope, DMI ADX:', tooltip="SMA with slope color")
di_len              = input.int(7, title='ADX DI Length', minval=1, group='MA cloud, HMA slope, DMI ADX:', tooltip="Value for current time frame. Also affects 'Entry Direction' -> 'auto'")
len_smo             = input.int(7, title='ADX Smoothing', minval=1, group='MA cloud, HMA slope, DMI ADX:', tooltip="Value for current time frame. Also affects 'Entry Direction' -> 'auto'")
hma_inp             = input.int(15, title='HMA Length', minval=1, group='MA cloud, HMA slope, DMI ADX:', tooltip="Value for current time frame. Also affects 'Entry Direction' -> 'auto'")

//two fractals trendlines inputs
plot_trendline      = input.bool(false, title='Fractal Trend Lines', group='Trend lines:', tooltip='The trend lines connect two up- and two down-Bill-Williams-Fractals. Works as price action/pattern breakout signal.')
//plot_tl_fr_sig      = input.bool(false, title='Trend Line Or Farctal Break Signal', tooltip='A signal is plotted when a line or a fractal is crossed. Letter: ls = sell, lb = buy', group='Trend lines:')
fractalBarsPerSide  = input.int(2, title="Fractal Size: Bars Per Side", minval=1, maxval=10, group='Trend lines:',
                     tooltip="Number of bars to the left and right of the fractal bar for trendlines. Total size = 2*n + 1. Default is 2 (5-bar fractal). Min=1 (3 bars), Max=10 (21 bars).")

//divergence signal inputs
plot_div            = input.bool(true, title='Divergence Signal Arrow', group='Divergences:',
                     tooltip='These divergences are very early signals and must be used in confluence with other signals. hd = hidden divergence, cd = classic divergence')
div_indi            = input.string('rsi', title='Divergence Indicator', options=['rsi', 'macd(fast_line)', 'macd(slow_line)'], tooltip='Select an Indicators for divergence calculation.', group='Divergences:')
rsi_length          = input.int(14, title='RSI Length', minval=1, step=2, group='Divergences:')
bar_div_p           = input.int(25, title='Bar Period', minval=1, step=1, tooltip='The number of bars in which divergences are detected.', group='Divergences:')
src_div             = input.string('high/low', title='Bar Divergence Source', options=['high/low', 'close'], tooltip='The bar source for divergence calculation.', group='Divergences:')


//bar signals inputs
plot_l12_bar        = input.bool(true, title='Last 12 Bar (L12)', tooltip='Letter: L, L12 => highest low of last 12 bars -> long. Lowest high of last 12 bars -> short. Indicates a new trend.', group='Bar signals:')
L12_input           = input.int(12, minval=1, title='"Last 12"', group='Bar signals:', tooltip='"Last 12 Bar" Bar count.')
plot_nr_bar         = input.bool(true, title='Narrow Range Bar (NR7)', tooltip='Letter: n, NR7 = narrowest range of a bar of the last seven bars. Indicates market tension.', group='Bar signals:')
plot_i_bar          = input.bool(true, title='Inside Bar', tooltip='Letter: i. An inside bar is a triangle formation on smaller time frame.', group='Bar signals:')
plot_o_bar          = input.bool(true, title='Outside Bar', tooltip='Letter: o. An outside bar is an opening funnel formation on smaller time frames.
                     gray-> normal outside bar, valid for the next bar: red-> short, green-> long', group='Bar signals:')
plot_s_bar          = input.bool(true, title='Sandwich Bar', tooltip='Letter: s. Indicates market tension.', group='Bar signals:')
plot_f_bar          = input.bool(true, title='Fakey', tooltip='Letter: F. An inside bar false breakout.', group='Bar signals:')
//plot_ef_bar         = input.bool(true, title='Early Fakey', tooltip='Letter: f. A possible inside bar false breakout', group='Bar signals:')
//plot_p_bar          = input.bool(false, title='Pin Bar', tooltip='Letter: p. Market rejects a price level. A pin bar is a V formation on smaller time frame.', group='Bar signals:')
//plot_r_fractal      = input.bool(false, title='Reverse Fractal', tooltip='Letter: r. A bottom fishing signal.', group='Bar signals:')
//p_bar_sens_1        = input.float(0.6, title='Pin bar sensitivity 1', step=0.02, tooltip='Condition: candle wick > candle body * \'Pin bar sensitivity\' .
//                     The smaller the factor, the more wicks are detected as part of a pin bar.', group='Bar signals:')
//p_bar_sens_2        = input.int(1, title='Pin bar sensitivity 2', step=1, minval=0, tooltip='Defines the amount of candles that must be higher or lower to the left of the pin bar.', group='Bar signals:')


//segments inputs
plot_segments       = input.bool(false, title='Segments', tooltip='Gray lines that follow the highest highs and lowest lows. This is a subtle way to detect a new trend.
                     The higher the timeframe the more reliable the signal.', group='Segment signal:')
sb                  = input.int(10 ,title='Max Segment Bars', minval=0, step=1, tooltip='Max bars between two segment highs or segment lows.', group='Segment signal:')

//pivot points inputs
//plot_pivots_d       = input.bool(false, title= "1 day classic pivot points", group= "Pivot points:",
//                     tooltip= "1 day classic pivot points are plotted (P, R1, R2, R3, S1, S2, S3). Pivot points are used as support and resistance levels. Watch out for clusters.")
plot_pivots_w       = input.bool(true, title= "1 Week Classic Pivot Points", group= "Pivot points:",
                     tooltip= "1 week classic Pivot points are plotted (P, R1, R2, R3, S1, S2, S3). Pivot points are used as support and resistance levels. Watch out for clusters.")
plot_pivots_m       = input.bool(true, title='1 Month Classic Pivot Points', group='Pivot points:',
                     tooltip='1 month classic pivot points are plotted (P, R1, R2, R3, S1, S2, S3). Pivot points are used as support and resistance levels. Watch out for clusters.')
plot_pivots_3m      = input.bool(true, title='3 Month Classic Pivot Points', group='Pivot points:',
                     tooltip='3 month classic pivot points are plotted (P, R1, R2, R3, S1, S2, S3). Pivot points are used as support and resistance levels. Watch out for clusters.')
plot_pivots_6m      = input.bool(true, title='6 Month Classic Pivot Points', group='Pivot points:',
                     tooltip='6 month classic pivot points are plotted (P, R1, R2, R3, S1, S2, S3). Pivot points are used as support and resistance levels. Watch out for clusters.')
plot_pivots_12m     = input.bool(true, title='12 Month Classic Pivot Points', group='Pivot points:',
                     tooltip='12 month classic pivot points are plotted (P, R1, R2, R3, S1, S2, S3). Pivot points are used as support and resistance levels. Watch out for clusters.')


//attributes inputs
color_fr            = input.color(color.white, "Fractal Color", group= "Attributes of drawn objects:")
transp_fr           = input.int(40, "Fractal Transparency", minval=1, maxval= 100, group= "Attributes of drawn objects:")

//color_sr            = input.color(color.blue, 'SR line color', group='Attributes of drawn objects:')
width_sr            = input.int(1, 'SR Line Width', minval=1, group='Attributes of drawn objects:')
transp_sr           = input.int(50, 'SR Line Transparency', minval=1, maxval= 100, group='Attributes of drawn objects:')

color_ema_c         = input.color(color.blue, 'EMA Cloud Color', group='Attributes of drawn objects:')
color_ema_sig_up    = input.color(color.green, 'EMA Signal Up Cloud Color', group='Attributes of drawn objects:')
color_ema_sig_dn    = input.color(color.red, 'EMA Signal Down Cloud Color', group='Attributes of drawn objects:')
transp_ema_c        = input.int(65, 'EMA Cloud Transparency', minval=1, maxval= 100, group='Attributes of drawn objects:')

color_tr            = input.color(color.blue, 'Trend Line Color', group='Attributes of drawn objects:')
width_tr            = input.int(2, 'Trend Line Width', minval=1, group='Attributes of drawn objects:')
transp_tr           = input.int(50, 'Trend Line Transparency', minval=1, maxval= 100, group='Attributes of drawn objects:')

color_seg           = input.color(color.white, 'Segment Line Color', group='Attributes of drawn objects:')
transp_seg          = input.int(65, 'Segment Line Transparency', minval=1, maxval= 100, group='Attributes of drawn objects:')

transp_bg           = input.int(85, 'Background Color Transparency', minval=1, maxval= 100, group='Attributes of drawn objects:')


//-------------------------------------------------------- williams fractals --------------------------------------------------------------

up_fr               = ta.pivothigh(2, 2)
dn_fr               = ta.pivotlow(2, 2)

last_up_fr_level    = ta.valuewhen(up_fr, high[2], 0)
last_dn_fr_level    = ta.valuewhen(dn_fr, low[2], 0)

// Plot fractals
plotshape(fracals_plot ? up_fr : na, style=shape.triangleup, location=location.abovebar, offset=-2, color=color.new(color_fr, transp_fr), title='Fractal up')
plotshape(fracals_plot ? dn_fr : na, style=shape.triangledown, location=location.belowbar, offset=-2, color=color.new(color_fr, transp_fr), title='Fractal down')

// --- Define Bill Williams Fractal BREAKOUT Conditions ---
bw_fr_buy_break  = ta.crossover(high, last_up_fr_level)
bw_fr_sell_break = ta.crossunder(low, last_dn_fr_level)


//---------------------------------------------------- macd and rsi divergences -------------------------------------------------------------

rsi_d               = ta.rsi(close, rsi_length)

fast_length         = 12  //input(title="Fast Length", type=input.integer, defval=12, group= "Divergence signal:")
slow_length         = 26  //input(title="Slow Length", type=input.integer, defval=26, group= "Divergence signal:")
signal_length       = 9  //input(title="Signal Smoothing", type=input.integer, minval = 1, maxval = 50, defval = 9, group= "Divergence signal:")
src                 = close  //input(title="Source", type=input.source, defval=close, group= "Divergence signal:")

[macdLine, signalLine, histLine] = ta.macd(src, fast_length, slow_length, signal_length)
// MACD Slow Line Slope
macd_slow_slope     = ta.change(signalLine)
macd_slow_up        = macd_slow_slope > 0
macd_slow_dn        = macd_slow_slope < 0
// MACD Slow Slope *events* (edge-only)
macd_slow_up_evt    = ta.crossover(macd_slow_slope, 0)
macd_slow_dn_evt    = ta.crossunder(macd_slow_slope, 0)



bar_scr_bear        = src_div == 'close' ? close : high
bar_scr_bull        = src_div == 'close' ? close : low

indi_scr            = div_indi == 'rsi' ? rsi_d : div_indi == 'macd(fast_line)' ? macdLine : div_indi == 'macd(slow_line)' ? signalLine : na


//rsi and macd divergence calc
c_div_bear          = bar_scr_bear > ta.highest(bar_scr_bear, bar_div_p)[1] and indi_scr < ta.highest(indi_scr, bar_div_p)[1]
c_div_bull          = bar_scr_bull < ta.lowest(bar_scr_bull, bar_div_p)[1] and indi_scr > ta.lowest(indi_scr, bar_div_p)[1]

h_div_bear          = bar_scr_bear < ta.highest(bar_scr_bear, bar_div_p)[1] and indi_scr > ta.highest(indi_scr, bar_div_p)[1]
h_div_bull          = bar_scr_bull > ta.lowest(bar_scr_bull, bar_div_p)[1] and indi_scr < ta.lowest(indi_scr, bar_div_p)[1]


plotshape(plot_div ? c_div_bear : na, style=shape.arrowdown, location=location.abovebar, offset=0, size= size.small,
 textcolor=color.new(color.red, 0),  color=color.new(color.red, 0), title='Classic bear divergence')  // text='cd',

plotshape(plot_div ? c_div_bull : na, style=shape.arrowup, location=location.belowbar, offset=0, size= size.small,
 textcolor=color.new(color.green, 0), color=color.new(color.green, 0), title='Classic bull divergence')  // text='cd',

plotshape(plot_div ? h_div_bear : na, style=shape.arrowdown, location=location.abovebar, offset=0, size= size.small,
 textcolor=color.new(color.red, 0), color=color.new(color.red, 0), title='Hidden bear divergence')  // text='hd',

plotshape(plot_div ? h_div_bull : na, style=shape.arrowup, location=location.belowbar, offset=0, size= size.small,
 textcolor=color.new(color.green, 0), color=color.new(color.green, 0), title='Hidden bull divergence')  // text='hd',


//------------------------------------------------------- plot horizontal sr levels/lines -----------------------------------------------------

// Auto Adaption logic for SR lines
auto_fr_size = 2

// Determine appropriate timeframe based on current chart timeframe
auto_sr_tf = timeframe.isintraday and timeframe.multiplier <= 15 ? '60' :
             timeframe.isintraday and timeframe.multiplier <= 60 ? '240' :
             timeframe.isintraday and timeframe.multiplier <= 240 ? 'D' :
             timeframe.isdaily ? 'W' :
             timeframe.isweekly ? 'M' :
             timeframe.ismonthly and timeframe.multiplier == 1 ? '3M' :
             timeframe.ismonthly and timeframe.multiplier == 3 ? '6M' :
             sr_tf  // default to user selection

// Use auto-adapted values if enabled
fractal_size = auto_adaption ? auto_fr_size : fr_size
fractal_tf = auto_adaption ? auto_sr_tf : sr_tf

fr_src              = fr_source == 'high/low' ? high : close

up_fr_sr            = request.security(syminfo.tickerid, fractal_tf, ta.pivothigh(fr_source == 'high/low' ? high : close, fractal_size, fractal_size))
dn_fr_sr            = request.security(syminfo.tickerid, fractal_tf, ta.pivotlow(fr_source == 'high/low' ? low : close, fractal_size, fractal_size))

fr_up               = request.security(syminfo.tickerid, fractal_tf, ta.valuewhen(up_fr_sr, high[fractal_size], 0))
fr_dn               = request.security(syminfo.tickerid, fractal_tf, ta.valuewhen(dn_fr_sr, low[fractal_size], 0))


up_fr_line          = plot_sr_lines ? line.new(x1=bar_index[2], x2=bar_index[1], y1=fr_up, y2=fr_up, extend= not extend ? extend.right : extend.both, color=color.new(color.blue, transp_sr),
                     style=line.style_solid, width=width_sr) : na

dn_fr_line          = plot_sr_lines ? line.new(x1=bar_index[2], x2=bar_index[1], y1=fr_dn, y2=fr_dn, extend= not extend ? extend.right : extend.both, color=color.new(color.blue, transp_sr),
                     style=line.style_solid, width=width_sr) : na


// Calculation All Time High
// Rolling All-Time High/Low
var float all_time_high = na
var float all_time_low  = na

all_time_high := na(all_time_high[1]) ? high : math.max(all_time_high[1], high)
all_time_low  := na(all_time_low[1])  ? low  : math.min(all_time_low[1],  low)

// --- ATH/ATL Lines (alte Linien sicher lÃ¶schen, dann neu zeichnen) ---
var line ath_line = na

if plot_sr_lines and bar_index > 0
    if not na(ath_line)
        line.delete(ath_line)

    ath_line := line.new(x1=bar_index[1], y1=all_time_high, x2=bar_index,   y2=all_time_high, extend = not extend ? extend.right : extend.both,
         color  = color.new(color.blue, transp_sr), style  = line.style_solid, width=width_sr)


//----------------------------------------------------------------- ema cloud / hma slope / dmi adx -------------------------------------------------------------------

//dmi adx indicator current tf
[diplus, diminus, adx]  = ta.dmi(di_len, len_smo)
//adx_slope_up            = ta.rising(adx, 1)

//dmi adx signal current tf
adx_up_c            = diplus > diminus //and adx_slope_up
adx_dn_c            = diplus < diminus //and not adx_slope_up

//ema x up current tf
ema1                = ta.ema(close, ema_inp1)
ema2                = ta.ema(close, ema_inp2)

// sma1
sma1                = ta.sma(close, sma1_inp)
sma1_slope          = sma1 - sma1[1]
sma1_color          = sma1_slope >= 0 ? color.lime : color.rgb(255, 20, 20)


ema_x_up            = ema1 > ema2

//hma slope current tf
hma                 = ta.hma(close, hma_inp)
hma_slo_up          = ta.rising(hma, 1)

// plots
ema1_pl             = plot(en_cloud ? ema1 : na, color=color.new(color.blue, 100), title='EMA 1')
ema2_pl             = plot(en_cloud ? ema2 : na, color=color.new(color.blue, 100), title='EMA 2')

sma1_pl             = plot(sma1_plot ? sma1 : na, color=sma1_color, linewidth= 1, title='SMA')

ema_buy             = en_cloud ? ema1 > ema2 : na
ema_sell            = en_cloud ? ema1 < ema2 : na



fill(ema1_pl, ema2_pl, color=color.new(sig_plot and not ema_buy[1] ? color_ema_sig_dn : sig_plot and not ema_sell[1] ? color_ema_sig_up : color_ema_c, transp_ema_c))

//------------------------------------------------------------ trend lines ----------------------------------------------------------------

// --- Fractal Logic for Trendlines (Uses 'fractalBarsPerSide' input) ---
n_tl = fractalBarsPerSide // Number of bars on each side for trendline fractals

// Condition for an Up-Fractal for Trendline (highest high in 2*n_tl+1 bars, with the high in the middle [n_tl])
up_fr_tl = high[n_tl] == ta.highest(high, 2 * n_tl + 1)

// Condition for a Down-Fractal for Trendline (lowest low in 2*n_tl+1 bars, with the low in the middle [n_tl])
dn_fr_tl = low[n_tl] == ta.lowest(low, 2 * n_tl + 1)

// Up-Fractals
y1_frup_1 = ta.valuewhen(up_fr_tl, high[n_tl], 1)      // Y-value (high of pivot bar)
y0_frup_0 = ta.valuewhen(up_fr_tl, high[n_tl], 0)      // Y-value (high of pivot bar)
x1_up_idx_pivot = ta.valuewhen(up_fr_tl, bar_index[n_tl], 1) // X-value (bar_index of pivot bar)
x0_up_idx_pivot = ta.valuewhen(up_fr_tl, bar_index[n_tl], 0) // X-value (bar_index of pivot bar)

// Down-Fractals
y1_frdn_1 = ta.valuewhen(dn_fr_tl, low[n_tl], 1)       // Y-value (low of pivot bar)
y0_frdn_0 = ta.valuewhen(dn_fr_tl, low[n_tl], 0)       // Y-value (low of pivot bar)
x1_dn_idx_pivot = ta.valuewhen(dn_fr_tl, bar_index[n_tl], 1) // X-value (bar_index of pivot bar)
x0_dn_idx_pivot = ta.valuewhen(dn_fr_tl, bar_index[n_tl], 0) // X-value (bar_index of pivot bar)

// --- Draw Trendlines ---
var line upper_line = na
var line lower_line = na

if (plot_trendline)
    // Upper Trendline (connects the pivot points of the last two Up-Fractals)
    if not na(x1_up_idx_pivot) and not na(x0_up_idx_pivot) and x1_up_idx_pivot != x0_up_idx_pivot
        line.delete(upper_line[1]) // Delete the previous line
        upper_line := line.new(x1 = x1_up_idx_pivot, y1 = y1_frup_1,
                               x2 = x0_up_idx_pivot, y2 = y0_frup_0,
                               extend = extend.right, color = color.new(color_tr, transp_tr),
                               style = line.style_solid, width = width_tr)

    // Lower Trendline (connects the pivot points of the last two Dn-Fractals)
    if not na(x1_dn_idx_pivot) and not na(x0_dn_idx_pivot) and x1_dn_idx_pivot != x0_dn_idx_pivot
        line.delete(lower_line[1]) // Delete the previous line
        lower_line := line.new(x1 = x1_dn_idx_pivot, y1 = y1_frdn_1,
                               x2 = x0_dn_idx_pivot, y2 = y0_frdn_0,
                               extend = extend.right, color = color.new(color_tr, transp_tr),
                               style = line.style_solid, width = width_tr)

// --- Calculate Y-values of Trendlines at the Current Bar (Extrapolation) ---
var float y_up_lvl = na
var float y_dn_lvl = na

// Calculation for upper line using pivot indices
if not na(x1_up_idx_pivot) and not na(x0_up_idx_pivot) and x1_up_idx_pivot != x0_up_idx_pivot
    delta_idx_up = x0_up_idx_pivot - x1_up_idx_pivot
    // Prevent division by zero if indices are somehow the same
    slope_up = delta_idx_up == 0 ? na : (y0_frup_0 - y1_frup_1) / delta_idx_up
    y_up_lvl := na(slope_up) ? na : slope_up * (bar_index - x0_up_idx_pivot) + y0_frup_0

// Calculation for lower line using pivot indices
if not na(x1_dn_idx_pivot) and not na(x0_dn_idx_pivot) and x1_dn_idx_pivot != x0_dn_idx_pivot
    delta_idx_dn = x0_dn_idx_pivot - x1_dn_idx_pivot
    // Prevent division by zero
    slope_dn = delta_idx_dn == 0 ? na : (y0_frdn_0 - y1_frdn_1) / delta_idx_dn
    y_dn_lvl := na(slope_dn) ? na : slope_dn * (bar_index - x0_dn_idx_pivot) + y0_frdn_0


// --- Breakout Signals based on Trendline Fractals ---

// Fractal Break Signal (break of the last fractal level used for the trendline)
frup_buy     = ta.crossover(high, y0_frup_0)
frdn_sell    = ta.crossunder(low, y0_frdn_0)

// Fractals Trendline Break Signal (break of the extrapolated trendline value)
buy_up_line  = ta.crossover(high, y_up_lvl)
sell_dn_line = ta.crossunder(low, y_dn_lvl)

// Combined Signal (Fractal break OR Trendline break)
fr_tl_buy    = buy_up_line or frup_buy
fr_tl_sell   = sell_dn_line or frdn_sell

// --- Conflict handling for "MACD Slope/Fractal Break (OR)" ---
// If one bar breaks BOTH fractals, prefer the *other* component (MACD slope direction).
fr_conflict      = frup_buy and frdn_sell
frup_buy_eff     = frup_buy and not frdn_sell            // only up-break without down-break
frdn_sell_eff    = frdn_sell and not frup_buy            // only down-break without up-break
tie_buy_pref     = fr_conflict and macd_slow_up          // conflict resolved by MACD slope up
tie_sell_pref    = fr_conflict and macd_slow_dn          // conflict resolved by MACD slope down

// Filter conditions for trend line signals ('auto' entry direction)
//auto_long    = (adx_up_c and hma_slo_up) or (adx_up_c and ema_x_up) or (hma_slo_up and ema_x_up)
//auto_short   = (adx_dn_c and not hma_slo_up) or (adx_dn_c and not ema_x_up) or (not hma_slo_up and not ema_x_up)


//----------------------------------------------------------- last 12 bar ----------------------------------------------------------

l12_long = ta.highest(low, L12_input)
l12_short = ta.lowest(high, L12_input)

var bool long_plotted = na
var bool short_plotted = na

//plot_l12_long = not long_plotted and (low == l12_long)
//plot_l12_short = not short_plotted and (high == l12_short)


// Determine the actual signal trigger point (the bar where the condition is met *for the first time* since the opposite signal)
plot_l12_long = low == l12_long and (na(short_plotted) or short_plotted) // Trigger long if condition met AND not already in long state (short_plotted is true or na)
plot_l12_short = high == l12_short and (na(long_plotted) or long_plotted) // Trigger short if condition met AND not already in short state (long_plotted is true or na)


if plot_l12_long
    long_plotted := true
    short_plotted := false

if plot_l12_short
    short_plotted := true
    long_plotted := false

plotchar(plot_l12_bar and plot_l12_long ? l12_long : na, char='L', location=location.belowbar, color=color.new(color.blue, 0), title='L12 long bar')
plotchar(plot_l12_bar and plot_l12_short ? l12_short : na, char='L', location=location.abovebar, color=color.new(color.red, 0), title='L12 short bar')


//----------------------------------------------------------- narrow range bar / anticipated fractal----------------------------------------------------------

// --- Narrow Range Bar (NR7) ---
p_nr_bar = high - low
bar_1 = high[1] - low[1]
bar_2 = high[2] - low[2]
bar_3 = high[3] - low[3]
bar_4 = high[4] - low[4]
bar_5 = high[5] - low[5]
bar_6 = high[6] - low[6]
bar_7 = high[7] - low[7]

nr_bar = p_nr_bar < bar_1 and p_nr_bar < bar_2 and p_nr_bar < bar_3 and p_nr_bar < bar_4 and p_nr_bar < bar_5 and p_nr_bar < bar_6 //and p_nr_bar < bar_7

// Plot NR7 ('n') if toggled on (plot_nr_bar) and condition is met (GRAY)
plotchar(plot_nr_bar and nr_bar, char='n', location=location.belowbar, color=color.new(color.gray, 0), title='NR bar')


// --- Anticipated Fractal Logic ---
af_up = high > high[1] and high > high[2]
af_dn = low < low[1] and low < low[2]

var int last_af_state = 0

// --- Plotting Logic ---
bool plot_blue_a_now = false
bool plot_red_a_now = false

if plot_af_bar
    if af_up and (last_af_state == 0 or last_af_state == -1)
        plot_blue_a_now := true
        last_af_state := 1

    else if af_dn and (last_af_state == 0 or last_af_state == 1)
        plot_red_a_now := true
        last_af_state := -1

// --- Plotting ---
plotchar(plot_blue_a_now, char='a', location=location.belowbar, size=size.auto, color=color.new(color.blue, 0), title="Anticipated Fractal Up")

plotchar(plot_red_a_now, char='a', location=location.abovebar, size=size.auto, color=color.new(color.red, 0), title="Anticipated Fractal Down")


//----------------------------------------------- inside bar / outside bar / sandwich bar / pin bar / fakey ---------------------------------------------

i_bar       = high < high[1] and low > low[1]

o_bar       = high > high[1] and low < low[1]

o_bar_color = close > high[1] ? color.new(color.red, 0) : close < low[1] ? color.new(color.green, 0) :color.new(color.gray, 0)

s_bar       = high[1] < high[2] and low[1] > low[2] and high > high[1] and low < low[1]


// major fakey (old logic)
//f_up_b      = i_bar[2] and low[1] < low[3] and close > high[3] or i_bar[3] and low[2] < low[4] and close > high[4] or i_bar[4] and low[3] < low[5] and close > high[5] or i_bar[2] and close[1] < low[3] and
//             close > high[3] or i_bar[3] and close[2] < low[4] and close > high[4] or i_bar[4] and close[3] < low[5] and close > high[5]

//f_up        = f_up_b and not f_up_b[1] and not f_up_b[2] and not f_up_b[3] and not f_up_b[4]

//f_dn_b      = i_bar[2] and high[1] > high[3] and close < low[3] or i_bar[3] and high[2] > high[4] and close < low[4] or i_bar[4] and high[3] > high[5] and close < low[5] or i_bar[2] and close[1] > high[3] and
//             close < low[3] or i_bar[3] and close[2] > high[4] and close < low[4] or i_bar[4] and close[3] > high[5] and close < low[5]

//f_dn        = f_dn_b and not f_dn_b[1] and not f_dn_b[2] and not f_dn_b[3] and not f_dn_b[4]


// early fakey
f_up_e      = i_bar[1] and low < low[1] and close > open[1] and close > open or i_bar[2] and close[1] < low[2] and close > close[1] and high > high[1] or i_bar[1] and
     low < low[2] and close > close[1] and
             close > open or i_bar[2] and close[1] < low[3] and close > open and close > open[1]

f_dn_e      = i_bar[1] and high > high[1] and close < open[1] and close < open or i_bar[2] and close[1] > high[2] and close < close[1] and low < low[1] or i_bar[1] and
     high > high[2] and close < open and
             close < close[1] or i_bar[2] and close[1] > high[3] and close < open and close < close[1]


i_bar_1 = high[1] < high[2] and low[1] > low[2]
i_bar_2 = high[2] < high[3] and low[2] > low[3]
i_bar_3 = high[3] < high[4] and low[3] > low[4]
i_bar_4 = high[4] < high[5] and low[4] > low[5]

f_up_b = ((i_bar_1 and low < low[1] and close > high[1]) or (i_bar_2 and low < low[2] and close > high[2]) or (i_bar_3 and low < low[3] and close > high[3]) or
     (i_bar_4 and low < low[4] and close > high[4]))

f_up = f_up_b and not f_up_b[1]

f_dn_b = ((i_bar_1 and high > high[1] and close < low[1]) or (i_bar_2 and high > high[2] and close < low[2]) or (i_bar_3 and high > high[3] and close < low[3]) or
     (i_bar_4 and high > high[4] and close < low[4]))

f_dn = f_dn_b and not f_dn_b[1]



// pinbar
//candle_body     = math.abs(open - close)

//pivot_up        = ta.pivothigh(high, p_bar_sens_2, 0)
//pivot_dn        = ta.pivotlow(low, p_bar_sens_2, 0)

//up_wick         = close > open ? high - close : high - open
//dn_wick         = close > open ? open - low : close - low

//pin_up_def      = high - open > p_bar_sens_1 * candle_body and close < open or high - close > p_bar_sens_1 * candle_body and close > open

//pin_dn_def      = open - low > p_bar_sens_1 * candle_body and close > open or close - low > p_bar_sens_1 * candle_body and close < open

//pin_bar_up      = pin_up_def and pivot_up and up_wick > dn_wick
//pin_bar_dn      = pin_dn_def and pivot_dn and up_wick < dn_wick


plotchar(plot_i_bar ? i_bar : na, char='i', location=location.abovebar, color=color.new(color.gray, 0), title='I bar')
plotchar(plot_o_bar ? o_bar : na, char='o', location=location.abovebar, color=o_bar_color, title='O bar')
plotchar(plot_s_bar ? s_bar : na, char='s', location=location.abovebar, color=color.new(color.silver, 0), offset=-1, title='S bar')
//plotchar(plot_p_bar ? pin_bar_up : na, char='p', location=location.abovebar, color=color.new(color.silver, 0), title='P bar up')
//plotchar(plot_p_bar ? pin_bar_dn : na, char='p', location=location.belowbar, color=color.new(color.silver, 0), title='P bar down')

plotchar(plot_f_bar ? f_up and (not f_up[1] or not f_up[2] or not f_up[3]) or f_up_e and not f_up : na, char='F', location=location.belowbar, color=color.new(color.blue, 0), title='F bar up')
plotchar(plot_f_bar ? f_dn and (not f_dn[1] or not f_dn[2] or not f_dn[3]) or f_dn_e and not f_dn : na, char='F', location=location.abovebar, color=color.new(color.red, 0), title='F bar down')

//plotchar(plot_ef_bar ? f_up_e and not f_up : na, char='f', location=location.belowbar, color=color.new(color.blue, 0), title='EF bar up')
//plotchar(plot_ef_bar ? f_dn_e and not f_dn : na, char='f', location=location.abovebar, color=color.new(color.red, 0), title='EF bar down')


//---------------------------------------------------------------- smash days (larry williams) Placeholder for the "holy grail" ------------------------------------------------------

// Smash Days Logic (Larry Williams)
//smash_day_buy  = close[2] < low[3] and high[1] > high[2]
//smash_day_sell = close[2] > high[3] and low[1] < low[2]


//------------------------------------------------------------- reverse fractal --------------------------------------------------------------------

//rev_up_fr       = ta.pivothigh(2, 1) and close < open

//rev_dn_fr       = ta.pivotlow(2, 1) and close > open

//plotchar(plot_r_fractal ? rev_up_fr : na, char='r', location=location.abovebar, color=color.new(color.red, 0), title='R bar up')
//plotchar(plot_r_fractal ? rev_dn_fr : na, char='r', location=location.belowbar, color=color.new(color.blue, 0), title='R bar down')


//----------------------------------------------------------------- segments --------------------------------------------------------------

count1_l                    = 0
count2_l                    = 0
segment_1_stat_l            = false
segment_2_stat_l            = false
segment_3_stat_l            = false

higher_low                  = low[0] > low[1]

var line segment_low_1_l    = na
var line segment_low_2_l    = na
var line segment_low_3_l    = na

// long segments
for i = 0 to sb by 1
    count1_l := count1_l + 1
    if low[1] > low[i + 2]  //and higher_low
        segment_low_1_l := line.new(x1=bar_index[2 + i], y1=low[2 + i], x2=bar_index[1], y2=low[1], color=color.new(color_seg, transp_seg), width=3)
        segment_1_stat_l := true
        break

for i = count1_l to sb + count1_l by 1
    count2_l := count2_l + 1
    if low[1 + count1_l] > low[i + 2] and segment_1_stat_l
        segment_low_2_l := line.new(x1=bar_index[2 + i], y1=low[2 + i], x2=bar_index[1 + count1_l], y2=low[1 + count1_l], color=color.new(color_seg, transp_seg), width=2)
        segment_2_stat_l := true
        break

for i = count2_l to sb + count2_l by 1
    if low[1 + count1_l + count2_l] > low[i + 2 + count1_l] and segment_2_stat_l
        segment_low_3_l := line.new(x1=bar_index[i + 2 + count1_l], y1=low[i + 2 + count1_l], x2=bar_index[1 + count1_l + count2_l], y2=low[1 + count1_l + count2_l], color=color.new(color_seg, transp_seg), width=1)
        segment_3_stat_l := true
        break

line.delete(plot_segments ? segment_low_1_l[1] : segment_low_1_l[0])
line.delete(plot_segments ? segment_low_2_l[1] : segment_low_2_l[0])
line.delete(plot_segments ? segment_low_3_l[1] : segment_low_3_l[0])


// short segments
count1_s                = 0
count2_s                = 0
segment_1_stat_s        = false
segment_2_stat_s        = false
segment_3_stat_s        = false

lower_high              = high[0] < high[1]

var line segment_high_1 = na
var line segment_high_2 = na
var line segment_high_3 = na

for i = 0 to sb by 1
    count1_s := count1_s + 1
    if high[1] < high[i + 2]  //and lower_high
        segment_high_1 := line.new(x1=bar_index[2 + i], y1=high[2 + i], x2=bar_index[1], y2=high[1], color=color.new(color_seg, transp_seg), width=3)
        segment_1_stat_s := true
        break

for i = count1_s to sb + count1_s by 1
    count2_s := count2_s + 1
    if high[1 + count1_s] < high[i + 2] and segment_1_stat_s
        segment_high_2 := line.new(x1=bar_index[2 + i], y1=high[2 + i], x2=bar_index[1 + count1_s], y2=high[1 + count1_s], color=color.new(color_seg, transp_seg), width=2)
        segment_2_stat_s := true
        break

for i = count2_s to sb + count2_s by 1
    if high[1 + count1_s + count2_s] < high[i + 2 + count1_s] and segment_2_stat_s
        segment_high_3 := line.new(x1=bar_index[i + 2 + count1_s], y1=high[i + 2 + count1_s], x2=bar_index[1 + count1_s + count2_s], y2=high[1 + count1_s + count2_s], color=color.new(color_seg, transp_seg), width=1)
        segment_3_stat_s := true
        break

line.delete(plot_segments ? segment_high_1[1] : segment_high_1[0])
line.delete(plot_segments ? segment_high_2[1] : segment_high_2[0])
line.delete(plot_segments ? segment_high_3[1] : segment_high_3[0])


// OR signals
segments_buy                        = high > high[1] and segment_1_stat_l and segment_2_stat_l and segment_3_stat_l
segments_sell                       = low < low[1] and segment_1_stat_s and segment_2_stat_s and segment_3_stat_s

segments_fractals_buy               = segments_buy or high >= y0_frup_0
segments_fractals_sell              = segments_sell or low <= y0_frdn_0

segments_fr_trend_buy               = segments_buy or buy_up_line
segments_fr_trend_sell              = segments_sell or sell_dn_line

segments_fractals_fr_trend_buy      = segments_fractals_buy or buy_up_line
segments_fractals_fr_trend_sell     = segments_fractals_sell or sell_dn_line


// --- Define component signal conditions ---
// Explicit definition of fractal break signals used for trendlines
fractal_break_buy = high >= y0_frup_0 and not na(y0_frup_0)
fractal_break_sell = low <= y0_frdn_0 and not na(y0_frdn_0)
// Segment signals (segments_buy, segments_sell) and Trendline break signals (buy_up_line, sell_dn_line)
bool trendline_buy_signal = buy_up_line and not na(y_up_lvl)
bool trendline_sell_signal = sell_dn_line and not na(y_dn_lvl)


//------------------------------------------------------------------------ State Variables for Time-Delayed AND Signals ------------------------------------
// These variables store whether a component's buy signal has occurred since the last sell flip (and vice-versa)
// 'var' makes them persistent across bars. Initialize with 'false'.
var bool seg_buy_occurred = false     // Has segment buy occurred since last sell flip?
var bool seg_sell_occurred = false    // Has segment sell occurred since last buy flip?
var bool frac_buy_occurred = false    // Has fractal break buy occurred since last sell flip?
var bool frac_sell_occurred = false   // Has fractal break sell occurred since last buy flip?
var bool tl_buy_occurred = false      // Has trendline break buy occurred since last sell flip?
var bool tl_sell_occurred = false     // Has trendline break sell occurred since last buy flip?
var bool macd_up_occurred = false     // Has MACD slope up-event occurred since last sell flip?
var bool macd_dn_occurred = false     // Has MACD slope down-event occurred since last buy flip?


//------------------------------------------------------------------------ Update Component State Variables -----------------------------------------------------------
// Update on each bar if a component signal occurs. They only get reset upon a background flip.

// Segment state update
if segments_buy
    seg_buy_occurred := true
if segments_sell
    seg_sell_occurred := true

// Fractal break state update (using trendline fractals)
if fractal_break_buy
    frac_buy_occurred := true
if fractal_break_sell
    frac_sell_occurred := true

// Trendline break state update
if trendline_buy_signal
    tl_buy_occurred := true
if trendline_sell_signal
    tl_sell_occurred := true

// MACD slope event state update
if macd_slow_up_evt
    macd_up_occurred := true
if macd_slow_dn_evt
    macd_dn_occurred := true

//------------------------------------------------------------------------ Background Color Logic ------------------------------------------------------------------

// These variables determine if the *conditions* for a flip are met on the current bar.
// BUY Flip Condition: Met if a standard OR/single signal triggers, OR if an AND signal is selected and all its components have occurred.
buy_flip_condition_met = (selected_bg_signal == "Bill Williams Fractals BG" and bw_fr_buy_break) or
                         (selected_bg_signal == "Anticipated Fractal BG" and af_up) or
                         (selected_bg_signal == "Last 12 Bar BG" and plot_l12_long) or
                         (selected_bg_signal == "MACD Slope/Fractal Break BG (OR)" and (macd_slow_up_evt or frup_buy_eff or tie_buy_pref)) or
                         (selected_bg_signal == "Trend Line/Fractal Break BG (OR)" and fr_tl_buy) or
                         (selected_bg_signal == "Segments BG" and segments_buy) or
                         (selected_bg_signal == "Segments/Fractals BG (OR)" and segments_fractals_buy) or
                         (selected_bg_signal == "Segments/Trend Line BG (OR)" and segments_fr_trend_buy) or
                         (selected_bg_signal == "Segments/Fractals/Trend Line BG (OR)" and segments_fractals_fr_trend_buy) or
                         (selected_bg_signal == "Segments/Fractals BG (AND)" and seg_buy_occurred and frac_buy_occurred) or
                         (selected_bg_signal == "Segments/Trend Line BG (AND)" and seg_buy_occurred and tl_buy_occurred) or
                         (selected_bg_signal == "Segments/Fractals/Trend Line BG (AND)" and seg_buy_occurred and frac_buy_occurred and tl_buy_occurred) or
                         (selected_bg_signal == "Segments/MACD Slope BG (AND)" and seg_buy_occurred and macd_up_occurred) or
                         (selected_bg_signal == "MACD Slope/Fractals Break BG (AND)" and macd_up_occurred and frac_buy_occurred)

// SELL Flip Condition: Met if a standard OR/single signal triggers, OR if an AND signal is selected and all its components have occurred.
sell_flip_condition_met = (selected_bg_signal == "Bill Williams Fractals BG" and bw_fr_sell_break) or
                          (selected_bg_signal == "Anticipated Fractal BG" and af_dn) or
                          (selected_bg_signal == "Last 12 Bar BG" and plot_l12_short) or
                          (selected_bg_signal == "MACD Slope/Fractal Break BG (OR)" and (macd_slow_dn_evt or frdn_sell_eff or tie_sell_pref)) or
                          (selected_bg_signal == "Trend Line/Fractal Break BG (OR)" and fr_tl_sell) or
                          (selected_bg_signal == "Segments BG" and segments_sell) or
                          (selected_bg_signal == "Segments/Fractals BG (OR)" and segments_fractals_sell) or
                          (selected_bg_signal == "Segments/Trend Line BG (OR)" and segments_fr_trend_sell) or
                          (selected_bg_signal == "Segments/Fractals/Trend Line BG (OR)" and segments_fractals_fr_trend_sell) or
                          (selected_bg_signal == "Segments/Fractals BG (AND)" and seg_sell_occurred and frac_sell_occurred) or
                          (selected_bg_signal == "Segments/Trend Line BG (AND)" and seg_sell_occurred and tl_sell_occurred) or
                          (selected_bg_signal == "Segments/Fractals/Trend Line BG (AND)" and seg_sell_occurred and frac_sell_occurred and tl_sell_occurred) or
                          (selected_bg_signal == "Segments/MACD Slope BG (AND)" and seg_sell_occurred and macd_dn_occurred) or
                          (selected_bg_signal == "MACD Slope/Fractals Break BG (AND)" and macd_dn_occurred and frac_sell_occurred)


// --- State Change and Component Reset Logic ---
// This section determines if the background *actually* flips and resets the opposite component flags.

var bool bg_state_is_green = na // Main background state (Green=Buy, Red=Sell, NA=Initial/Neutral)

// Check if a BUY flip should happen
if buy_flip_condition_met and (na(bg_state_is_green) or not bg_state_is_green[1]) // Check previous state to avoid rapid flipping on same bar
    // Condition met AND state was previously Red or NA -> Flip to Green
    bg_state_is_green := true
    // Reset the SELL component flags because we are now entering a Buy state
    seg_sell_occurred := false
    frac_sell_occurred := false
    tl_sell_occurred := false
    macd_dn_occurred := false
    // Optionally reset buy flags too, if a signal should only trigger once per sequence
    // seg_buy_occurred := false
    // frac_buy_occurred := false
    // tl_buy_occurred := false

// Check if a SELL flip should happen
else if sell_flip_condition_met and (na(bg_state_is_green) or bg_state_is_green[1]) // Check previous state
    // Condition met AND state was previously Green or NA -> Flip to Red
    bg_state_is_green := false
    // Reset the BUY component flags because we are now entering a Sell state
    seg_buy_occurred := false
    frac_buy_occurred := false
    tl_buy_occurred := false
    macd_up_occurred := false
    // Optionally reset sell flags too
    // seg_sell_occurred := false
    // frac_sell_occurred := false
    // tl_sell_occurred := false
else
    // If no flip condition is met, maintain the previous state
    bg_state_is_green := bg_state_is_green[1]


// --- Final Color Determination ---
// Determine the final background color based on the selected signal type and the current state.

bg_final_color = if selected_bg_signal == "None"
    na // No background color
else if selected_bg_signal == "DMI ADX BG" // Non-stateful signal (color determined directly by current condition)
    adx_up_c ? color.new(color.green, transp_bg) : adx_dn_c ? color.new(color.red, transp_bg) : color.new(color.gray, transp_bg) // Added gray for neutral
else if selected_bg_signal == "HMA Slope BG" // Non-stateful signal (color determined directly by current condition)
    hma_slo_up ? color.new(color.green, transp_bg) : not hma_slo_up ? color.new(color.red, transp_bg) : na // HMA slope is usually either up or down
else if selected_bg_signal == "MACD Slow Slope BG" // Non-stateful signal (color determined directly by current condition)
    macd_slow_up ? color.new(color.green, transp_bg) : macd_slow_dn ? color.new(color.red, transp_bg) : color.new(color.gray, transp_bg)
else // Stateful signals (OR and time-delayed AND) use the tracked bg_state_is_green
    // Ensure bg_state_is_green is not na before coloring
    is_green = na(bg_state_is_green) ? false : bg_state_is_green // Default to false (red) if na initially? Or handle na explicitly
    is_red = na(bg_state_is_green) ? false : not bg_state_is_green

    na(bg_state_is_green) ? na : bg_state_is_green ? color.new(color.green, transp_bg) : color.new(color.red, transp_bg)
    // Alternative: Default to gray if state is na
    // na(bg_state_is_green) ? color.new(color.gray, transp_bg) : bg_state_is_green ? color.new(color.green, transp_bg) : color.new(color.red, transp_bg)


// Apply the calculated background color
bgcolor(bg_final_color, title="Selected Background Signal")


//-------------------------------------------------------------------- info panel -------------------------------------------------------------------------

//indicator funktions for 4h, d, w, m 

f_dmi(_di_len, _len_smo)            => [_diplus_p, _diminus_p, _adx_p] =  ta.dmi(_di_len, _len_smo) 

f_rising(_src, _len)                => ta.rising(_src, _len)

f_ema(_ema_len)                     => ta.ema(close, _ema_len)

f_hma(_hma_len)                     => ta.hma(close, _hma_len) 


//------------------------ 4h, d, w, m indicators signals -----------------------
//4h indicator values
[_diplus_4h, _diminus_4h, _adx_4h] =  f_dmi(7, 7) 

adx_slope_up_4h      = f_rising(_adx_4h, 1)

adx_up_4h           = adx_slope_up_4h and _diplus_4h > _diminus_4h                       
adx_dn_4h           = adx_slope_up_4h and _diplus_4h < _diminus_4h 

ema1_4h             = f_ema(8)
ema2_4h             = f_ema(21)

ema_x_up_4h         = ema1_4h > ema2_4h   

hma_4h              = f_hma(15)                  
hma_slo_up_4h       = f_rising(hma_4h, 1)     


//day indicator values
[_diplus_d, _diminus_d, _adx_d] =  f_dmi(7, 7) 

adx_slope_up_d      = f_rising(_adx_d, 1)

adx_up_d            = adx_slope_up_d and _diplus_d > _diminus_d                       
adx_dn_d            = adx_slope_up_d and _diplus_d < _diminus_d 

ema1_d              = f_ema(5)
ema2_d              = f_ema(21)

ema_x_up_d          = ema1_d > ema2_d   

hma_d               = f_hma(10)                  
hma_slo_up_d           = f_rising(hma_d, 1)  


//week indicator values
[_diplus_w, _diminus_w, _adx_w] =  f_dmi(2, 7) 

adx_slope_up_w      = f_rising(_adx_w, 1)

adx_up_w            = adx_slope_up_w and _diplus_w > _diminus_w                       
adx_dn_w            = adx_slope_up_w and _diplus_w < _diminus_w 

ema1_w              = f_ema(5)
ema2_w              = f_ema(8)

ema_x_up_w          = ema1_w > ema2_w   

hma_w               = f_hma(10)                  
hma_slo_up_w           = f_rising(hma_w, 1)  


//month indicator values
[_diplus_m, _diminus_m, _adx_m] =  f_dmi(2, 2) 

adx_slope_up_m      = f_rising(_adx_m, 1)

adx_up_m            = adx_slope_up_m and _diplus_m > _diminus_m                       
adx_dn_m            = adx_slope_up_m and _diplus_m < _diminus_m 

ema1_m              = f_ema(3)
ema2_m              = f_ema(8)

ema_x_up_m          = ema1_m > ema2_m   

hma_m               = f_hma(5)                  
hma_slo_up_m           = f_rising(hma_m, 1)  

  
//colors
color_blue_1    = color.new(color.blue, 30)
color_red_1     = color.new(color.red, 30)
color_gray_1    = color.new(color.gray, 30)


//adx long htf
adx_4h_up       = request.security(syminfo.tickerid, '240', adx_up_4h)
adx_d_up        = request.security(syminfo.tickerid, 'D', adx_up_d)
adx_w_up        = request.security(syminfo.tickerid, 'W', adx_up_w)
adx_m_up        = request.security(syminfo.tickerid, 'M', adx_up_m)
//adx short htf
adx_4h_dn       = request.security(syminfo.tickerid, '240', adx_dn_4h)
adx_d_dn        = request.security(syminfo.tickerid, 'D', adx_dn_d)
adx_w_dn        = request.security(syminfo.tickerid, 'W', adx_dn_w)
adx_m_dn        = request.security(syminfo.tickerid, 'M', adx_dn_m)


//hma htf
hma_4h_up       = request.security(syminfo.tickerid, '240', hma_slo_up_4h)
hma_d_up        = request.security(syminfo.tickerid, 'D', hma_slo_up_d)
hma_w_up        = request.security(syminfo.tickerid, 'W', hma_slo_up_w)
hma_m_up        = request.security(syminfo.tickerid, 'M', hma_slo_up_m)


//ema1 x ema2 htf upcross
e1xe2_4h_up     = request.security(syminfo.tickerid, '240', ema_x_up_4h)
e1xe2_d_up      = request.security(syminfo.tickerid, 'D', ema_x_up_d)
e1xe2_w_up      = request.security(syminfo.tickerid, 'W', ema_x_up_w)
e1xe2_m_up      = request.security(syminfo.tickerid, 'M', ema_x_up_m)


//adx conditions
a_color_4h        = adx_4h_up ? color_blue_1 : adx_4h_dn ? color_red_1 : color_gray_1    
a_color_d         = adx_d_up ? color_blue_1 : adx_d_dn ? color_red_1 : color_gray_1
a_color_w         = adx_w_up ? color_blue_1 : adx_w_dn ? color_red_1 : color_gray_1
a_color_m         = adx_m_up ? color_blue_1 : adx_m_dn ? color_red_1 : color_gray_1

//hma conditions
h_color_4h      = hma_4h_up ? color_blue_1 : not hma_4h_up ? color_red_1 : color_gray_1    
h_color_d       = hma_d_up ? color_blue_1 : not hma_d_up ? color_red_1 : color_gray_1
h_color_w       = hma_w_up ? color_blue_1 : not hma_w_up ? color_red_1 : color_gray_1
h_color_m       = hma_m_up ? color_blue_1 : not hma_m_up ? color_red_1 : color_gray_1

//ema1 x ema2 condition
e_color_4h      = e1xe2_4h_up ? color_blue_1 : not e1xe2_4h_up ? color_red_1 : color_gray_1    
e_color_d       = e1xe2_d_up ? color_blue_1 : not e1xe2_d_up ? color_red_1 : color_gray_1
e_color_w       = e1xe2_w_up ? color_blue_1 : not e1xe2_w_up ? color_red_1 : color_gray_1
e_color_m       = e1xe2_m_up ? color_blue_1 : not e1xe2_m_up ? color_red_1 : color_gray_1


//current tf condition for adx, hama and ema
a_color_c       = adx_up_c ? color_blue_1 : adx_dn_c ? color_red_1 : color_gray_1
h_color_c       = hma_slo_up ? color_blue_1 : not hma_slo_up ? color_red_1 : color_gray_1
e_color_c       = ema_x_up ? color_blue_1 : not ema_x_up ? color_red_1 : color_gray_1


//mtf time frames
Intra           = timeframe.isintraday
Intra_D         = timeframe.isintraday or timeframe.isdaily
Intra_D_W       = timeframe.isintraday or timeframe.isdaily or timeframe.isweekly
Intra_D_W_M     = timeframe.isintraday or timeframe.isdaily or timeframe.isweekly or timeframe.ismonthly


if adx_trend
    var info_panel = table.new(position = position.bottom_left, columns = 4, rows = 7, bgcolor=color.new(color.blue, 95), frame_width=1, border_width=1, 
                     frame_color=color.new(color.black, 50), border_color=color.new(color.black, 50))

    table.cell(table_id=info_panel, column=0, row=0, text="C", text_size= size.small, text_color=color.silver)
    table.cell(table_id=info_panel, column=1, row=0, bgcolor=(Intra_D_W_M) ? a_color_c : na, width=2)
    table.cell(table_id=info_panel, column=2, row=0, bgcolor=(Intra_D_W_M) ? h_color_c : na, width=2)
    table.cell(table_id=info_panel, column=3, row=0, bgcolor=(Intra_D_W_M) ? e_color_c : na, width=2)

    table.cell(table_id=info_panel, column=0, row=1, text="TF", text_size= size.small, text_color=color.silver)
    table.cell(table_id=info_panel, column=1, row=1, text= "ADX", text_size= size.small, text_color=color.silver)
    table.cell(table_id=info_panel, column=2, row=1, text= "HMA", text_size= size.small, text_color=color.silver)
    table.cell(table_id=info_panel, column=3, row=1, text= "EMA", text_size= size.small, text_color=color.silver)

    table.cell(table_id=info_panel, column=0, row=2, text="4H", text_size= size.small, text_color=color.silver)
    table.cell(table_id=info_panel, column=1, row=2, bgcolor=Intra ? a_color_4h : na, width=2)
    table.cell(table_id=info_panel, column=2, row=2, bgcolor=Intra ? h_color_4h : na, width=2)
    table.cell(table_id=info_panel, column=3, row=2, bgcolor=Intra ? e_color_4h : na, width=2)

    table.cell(table_id=info_panel, column=0, row=3, text="1D", text_size= size.small, text_color=color.silver)
    table.cell(table_id=info_panel, column=1, row=3, bgcolor=(Intra_D) ? a_color_d : na, width=2)
    table.cell(table_id=info_panel, column=2, row=3, bgcolor=(Intra_D) ? h_color_d : na, width=2)
    table.cell(table_id=info_panel, column=3, row=3, bgcolor=(Intra_D) ? e_color_d : na, width=2)
    
    table.cell(table_id=info_panel, column=0, row=4, text="1W", text_size= size.small, text_color=color.silver)
    table.cell(table_id=info_panel, column=1, row=4, bgcolor=(Intra_D_W) ? a_color_w : na, width=2)
    table.cell(table_id=info_panel, column=2, row=4, bgcolor=(Intra_D_W) ? h_color_w : na, width=2)
    table.cell(table_id=info_panel, column=3, row=4, bgcolor=(Intra_D_W) ? e_color_w : na, width=2)
    
    table.cell(table_id=info_panel, column=0, row=5, text="1M", text_size= size.small, text_color=color.silver)
    table.cell(table_id=info_panel, column=1, row=5, bgcolor=(Intra_D_W_M) ? a_color_m : na, width=2)
    table.cell(table_id=info_panel, column=2, row=5, bgcolor=(Intra_D_W_M) ? h_color_m : na, width=2)
    table.cell(table_id=info_panel, column=3, row=5, bgcolor=(Intra_D_W_M) ? e_color_m : na, width=2)

    table.cell(table_id=info_panel, column=0, row=6, text="ATR14", text_size= size.small, text_color=color.silver)
    table.cell(table_id=info_panel, column=2, row=6, text=str.tostring(ta.atr(14), '#'), text_color=color.silver)             //'#.000' - format


// ----------------------------------------------------------- pivot points -----------------------------------------------------------------

d_high          = request.security(syminfo.tickerid,"D", high[1])
d_low           = request.security(syminfo.tickerid,"D", low[1])
d_close         = request.security(syminfo.tickerid,"D", close[1])

w_high          = request.security(syminfo.tickerid,"W", high[1])
w_low           = request.security(syminfo.tickerid,"W", low[1])
w_close         = request.security(syminfo.tickerid,"W", close[1])

m_high          = request.security(syminfo.tickerid, 'M', high[1])
m_low           = request.security(syminfo.tickerid, 'M', low[1])
m_close         = request.security(syminfo.tickerid, 'M', close[1])

m3_high         = request.security(syminfo.tickerid, '3M', high[1])
m3_low          = request.security(syminfo.tickerid, '3M', low[1])
m3_close        = request.security(syminfo.tickerid, '3M', close[1])

m6_high         = request.security(syminfo.tickerid, '6M', high[1])
m6_low          = request.security(syminfo.tickerid, '6M', low[1])
m6_close        = request.security(syminfo.tickerid, '6M', close[1])

m12_high        = request.security(syminfo.tickerid, '12M', high[1])
m12_low         = request.security(syminfo.tickerid, '12M', low[1])
m12_close       = request.security(syminfo.tickerid, '12M', close[1])

// P pivot points
//d_PP            = (d_high + d_low + d_close) / 3
w_PP            = (w_high + w_low + w_close) / 3
m_PP            = (m_high + m_low + m_close) / 3
m3_PP           = (m3_high + m3_low + m3_close) / 3
m6_PP           = (m6_high + m6_low + m6_close) / 3
m12_PP          = (m12_high + m12_low + m12_close) / 3


// daily R/S pivot points
//d_R1 = d_PP + (d_PP - d_low)
//d_R2 = d_PP + (d_high - d_low)
//d_R3 = d_high + 2 * (d_PP - d_low) 

//d_S1 = d_PP - (d_high - d_PP)
//d_S2 = d_PP - (d_high - d_low)
//d_S3 = d_low - 2 * (d_high - d_PP)


// weekly R/S pivot points
w_R1            = w_PP + w_PP - w_low
w_R2            = w_PP + w_high - w_low
w_R3            = w_high + 2 * (w_PP - w_low) 

w_S1            = w_PP - (w_high - w_PP)
w_S2            = w_PP - (w_high - w_low)
w_S3            = w_low - 2 * (w_high - w_PP)


// monthly R/S pivot points
m_R1            = m_PP + m_PP - m_low
m_R2            = m_PP + m_high - m_low
m_R3            = m_high + 2 * (m_PP - m_low)

m_S1            = m_PP - (m_high - m_PP)
m_S2            = m_PP - (m_high - m_low)
m_S3            = m_low - 2 * (m_high - m_PP)


// 3 month R/S pivot points
m3_R1           = m3_PP + m3_PP - m3_low
m3_R2           = m3_PP + m3_high - m3_low
m3_R3           = m3_high + 2 * (m3_PP - m3_low)

m3_S1           = m3_PP - (m3_high - m3_PP)
m3_S2           = m3_PP - (m3_high - m3_low)
m3_S3           = m3_low - 2 * (m3_high - m3_PP)


// 6 month R/S pivot points
m6_R1           = m6_PP + m6_PP - m6_low
m6_R2           = m6_PP + m6_high - m6_low
m6_R3           = m6_high + 2 * (m6_PP - m6_low)

m6_S1           = m6_PP - (m6_high - m6_PP)
m6_S2           = m6_PP - (m6_high - m6_low)
m6_S3           = m6_low - 2 * (m6_high - m6_PP)


// 12 month R/S pivot points
m12_R1          = m12_PP + m12_PP - m12_low
m12_R2          = m12_PP + m12_high - m12_low
m12_R3          = m12_high + 2 * (m12_PP - m12_low)

m12_S1          = m12_PP - (m12_high - m12_PP)
m12_S2          = m12_PP - (m12_high - m12_low)
m12_S3          = m12_low - 2 * (m12_high - m12_PP)



//d_PP_line       = Intra and plot_pivots_d ? line.new(x1=time, x2=time + 10, xloc = xloc.bar_time, y1=d_PP, y2=d_PP, color=color.new(color.blue, 0), width=2) : na

//line.delete(Intra and plot_pivots_d ? d_PP_line[1] : d_PP_line[0])


//line.set_xloc(d_PP_line, time + (0), time + (100), xloc.bar_time)





//plot P/R/S daily pivot points
//plot(Intra and plot_pivots_d ? d_PP : na, color= color.yellow, title= "PP", style = plot.style_line, linewidth= 2, show_last= 1, offset= 2)

//plot(Intra and plot_pivots_d ? d_R1 : na, color= color.red, title= "R1", style = plot.style_line, linewidth= 2, show_last= 1, offset= 2)
//plot(Intra and plot_pivots_d ? d_R2 : na, color= color.red, title= "R2", style = plot.style_line, linewidth= 2, show_last= 1, offset= 2)
//plot(Intra and plot_pivots_d ? d_R3 : na, color= color.red, title= "R3", style = plot.style_line, linewidth= 2, show_last= 1, offset= 2)

//plot(Intra and plot_pivots_d ? d_S1 : na, color= color.green, title= "S1", style = plot.style_line, linewidth= 2, show_last= 1, offset= 2)
//plot(Intra and plot_pivots_d ? d_S2 : na, color= color.green, title= "S2", style = plot.style_line, linewidth= 2, show_last= 1, offset= 2)
//plot(Intra and plot_pivots_d ? d_S3 : na, color= color.green, title= "S3", style = plot.style_line, linewidth= 2, show_last= 1, offset= 2)


//plot P/R/S weekly pivot points
plot(Intra_D and plot_pivots_w ? w_PP : na, color= color.yellow, title= "W PP", style = plot.style_line, linewidth= 3, show_last= 1, offset= 2)

plot(Intra_D and plot_pivots_w ? w_R1 : na, color= color.red, title= "W R1", style = plot.style_line, linewidth= 3, show_last= 1, offset= 2)
plot(Intra_D and plot_pivots_w ? w_R2 : na, color= color.red, title= "W R2", style = plot.style_line, linewidth= 3, show_last= 1, offset= 2)
plot(Intra_D and plot_pivots_w ? w_R3 : na, color= color.red, title= "W R3", style = plot.style_line, linewidth= 3, show_last= 1, offset= 2)

plot(Intra_D and plot_pivots_w ? w_S1 : na, color= color.green, title= "w S1", style = plot.style_line, linewidth= 3, show_last= 1, offset= 2)
plot(Intra_D and plot_pivots_w ? w_S2 : na, color= color.green, title= "w S2", style = plot.style_line, linewidth= 3, show_last= 1, offset= 2)
plot(Intra_D and plot_pivots_w ? w_S3 : na, color= color.green, title= "W S3", style = plot.style_line, linewidth= 3, show_last= 1, offset= 2)


//plot P/R/S 1 month pivot points
plot(Intra_D_W and plot_pivots_m ? m_PP : na, color=color.new(color.yellow, 0), title='M PP', style=plot.style_line, linewidth=4, show_last=1, offset=3)

plot(Intra_D_W and plot_pivots_m ? m_R1 : na, color=color.new(color.red, 0), title='M R1', style=plot.style_line, linewidth=4, show_last=1, offset=3)
plot(Intra_D_W and plot_pivots_m ? m_R2 : na, color=color.new(color.red, 0), title='M R2', style=plot.style_line, linewidth=4, show_last=1, offset=3)
plot(Intra_D_W and plot_pivots_m ? m_R3 : na, color=color.new(color.red, 0), title='M R3', style=plot.style_line, linewidth=4, show_last=1, offset=3)

plot(Intra_D_W and plot_pivots_m ? m_S1 : na, color=color.new(color.green, 0), title='M S1', style=plot.style_line, linewidth=4, show_last=1, offset=3)
plot(Intra_D_W and plot_pivots_m ? m_S2 : na, color=color.new(color.green, 0), title='M S2', style=plot.style_line, linewidth=4, show_last=1, offset=3)
plot(Intra_D_W and plot_pivots_m ? m_S3 : na, color=color.new(color.green, 0), title='M S3', style=plot.style_line, linewidth=4, show_last=1, offset=3)


//plot P/R/S 3 month pivot points
plot(Intra_D_W_M and plot_pivots_3m ? m3_PP : na, color=color.new(color.yellow, 0), title='3M PP', style=plot.style_line, linewidth=5, show_last=1, offset=3)

plot(Intra_D_W_M and plot_pivots_3m ? m3_R1 : na, color=color.new(color.red, 0), title='3M R1', style=plot.style_line, linewidth=5, show_last=1, offset=3)
plot(Intra_D_W_M and plot_pivots_3m ? m3_R2 : na, color=color.new(color.red, 0), title='3M R2', style=plot.style_line, linewidth=5, show_last=1, offset=3)
plot(Intra_D_W_M and plot_pivots_3m ? m3_R3 : na, color=color.new(color.red, 0), title='3M R3', style=plot.style_line, linewidth=5, show_last=1, offset=3)

plot(Intra_D_W_M and plot_pivots_3m ? m3_S1 : na, color=color.new(color.green, 0), title='3M S1', style=plot.style_line, linewidth=5, show_last=1, offset=3)
plot(Intra_D_W_M and plot_pivots_3m ? m3_S2 : na, color=color.new(color.green, 0), title='3M S2', style=plot.style_line, linewidth=5, show_last=1, offset=3)
plot(Intra_D_W_M and plot_pivots_3m ? m3_S3 : na, color=color.new(color.green, 0), title='3M S3', style=plot.style_line, linewidth=5, show_last=1, offset=3)


//plot P/R/S 6 month pivot points
plot(Intra_D_W_M and plot_pivots_6m ? m6_PP : na, color=color.new(color.yellow, 0), title='6M PP', style=plot.style_line, linewidth=6, show_last=1, offset=5)

plot(Intra_D_W_M and plot_pivots_6m ? m6_R1 : na, color=color.new(color.red, 0), title='6M R1', style=plot.style_line, linewidth=6, show_last=1, offset=5)
plot(Intra_D_W_M and plot_pivots_6m ? m6_R2 : na, color=color.new(color.red, 0), title='6M R2', style=plot.style_line, linewidth=6, show_last=1, offset=5)
plot(Intra_D_W_M and plot_pivots_6m ? m6_R3 : na, color=color.new(color.red, 0), title='6M R3', style=plot.style_line, linewidth=6, show_last=1, offset=5)

plot(Intra_D_W_M and plot_pivots_6m ? m6_S1 : na, color=color.new(color.green, 0), title='6M S1', style=plot.style_line, linewidth=6, show_last=1, offset=5)
plot(Intra_D_W_M and plot_pivots_6m ? m6_S2 : na, color=color.new(color.green, 0), title='6M S2', style=plot.style_line, linewidth=6, show_last=1, offset=5)
plot(Intra_D_W_M and plot_pivots_6m ? m6_S3 : na, color=color.new(color.green, 0), title='6M S3', style=plot.style_line, linewidth=6, show_last=1, offset=5)


//plot P/R/S 12 month pivot points
plot(Intra_D_W_M and plot_pivots_12m ? m12_PP : na, color=color.new(color.yellow, 0), title='12M PP', style=plot.style_line, linewidth=7, show_last=1, offset=5)

plot(Intra_D_W_M and plot_pivots_12m ? m12_R1 : na, color=color.new(color.red, 0), title='12M R1', style=plot.style_line, linewidth=7, show_last=1, offset=5)
plot(Intra_D_W_M and plot_pivots_12m ? m12_R2 : na, color=color.new(color.red, 0), title='12M R2', style=plot.style_line, linewidth=7, show_last=1, offset=5)
plot(Intra_D_W_M and plot_pivots_12m ? m12_R3 : na, color=color.new(color.red, 0), title='12M R3', style=plot.style_line, linewidth=7, show_last=1, offset=5)

plot(Intra_D_W_M and plot_pivots_12m ? m12_S1 : na, color=color.new(color.green, 0), title='12M S1', style=plot.style_line, linewidth=7, show_last=1, offset=5)
plot(Intra_D_W_M and plot_pivots_12m ? m12_S2 : na, color=color.new(color.green, 0), title='12M S2', style=plot.style_line, linewidth=7, show_last=1, offset=5)
plot(Intra_D_W_M and plot_pivots_12m ? m12_S3 : na, color=color.new(color.green, 0), title='12M S3', style=plot.style_line, linewidth=7, show_last=1, offset=5)


//----------------------------------- Bollinger Bands ------------------------------------

f_stdev(_bb_len) => ta.stdev(close, _bb_len)
f_sma(_sma_len) => BB_calc_tog ? ta.sma(close, _sma_len) : ta.ema(close, _sma_len)

f_bb_basis(_sma_len) => BB_calc_tog ? f_sma(_sma_len) : ta.ema((open + high + low + close) / 4, _sma_len)

f_bb_dev(_sma_len) => BB_calc_tog ? f_stdev(_sma_len) : math.sqrt(ta.sma((((open + high + low + close) 
     / 4 - ta.ema((open + high + low + close) / 4, _sma_len)) * ((open + high + low + close) 
     / 4 - ta.ema((open + high + low + close) / 4, _sma_len))), _sma_len))

//bb1
basis = f_bb_basis(BB_length_1)
dev_1 = BB_sdev_1 * f_bb_dev(BB_length_1)
upper_1 = basis + dev_1
lower_1 = basis - dev_1

//bb2
dev_2 = BB_sdev_2 * f_bb_dev(BB_length_1)
upper_2 = basis + dev_2
lower_2 = basis - dev_2

//bb3
dev_3 = BB_sdev_3 * f_bb_dev(BB_length_1)
upper_3 = basis + dev_3
lower_3 = basis - dev_3

//bb4
dev_4 = BB_sdev_4 * f_bb_dev(BB_length_1)
upper_4 = basis + dev_4
lower_4 = basis - dev_4

approach_up = near_bb ? high > upper_1 : true
approach_dn = near_bb ? low < lower_1 : true

bup_1 = plot(BB_plot and approach_up ? upper_1 : na, title='Upper BB1', color=color.new(color.gray, 100), linewidth=1)
bdn_1 = plot(BB_plot and approach_dn ? lower_1 : na, title='Lower BB1', color=color.new(color.gray, 100), linewidth=1)

bup_3 = plot(BB_plot and approach_up ? upper_3 : na, title='Upper BB3', color=color.new(color.gray, 100), linewidth=1)
bdn_3 = plot(BB_plot and approach_dn ? lower_3 : na, title='Lower BB3', color=color.new(color.gray, 100), linewidth=1)

fill(bup_1, bup_3, color=color.new(color.red, 80))
fill(bdn_1, bdn_3, color=color.new(color.green, 80))

