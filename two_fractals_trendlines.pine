//@version=5
indicator("CONF REG Pro Bias Verifier", shorttitle="CONF/REG", overlay=true, max_bars_back=3000)

// -----------------------------------------------------------------------------
// 1. UI & INPUTS
// -----------------------------------------------------------------------------
grp_ui = "UI Settings"
show_panel  = input.bool(true, "Show Panel", group=grp_ui)
show_bg     = input.bool(true, "Show Background Blocks", group=grp_ui)
calc_mode   = input.string("Closed Bar", "Calculation Mode", options=["Closed Bar", "Realtime (Repainting)"], group=grp_ui)
profile     = input.string("Auto", "Profile", options=["Auto"], group=grp_ui) // Fixed to Auto
debug       = input.bool(false, "Debug Info", group=grp_ui)

// -----------------------------------------------------------------------------
// 2. HELPER FUNCTIONS & SYSTEM
// -----------------------------------------------------------------------------
f_clamp(x, lo, hi) => math.max(lo, math.min(x, hi))
f_safe_div(a, b)   => b != 0 ? a / b : 0
f_sign0(x)         => x > 0 ? 1 : x < 0 ? -1 : 0
f_softsat(x, k) =>
    if k <= 0
        0.0
    else
        float u = x / k
        if u > 10
            1.0
        else
            float e2u = math.exp(2 * u)
            (e2u - 1) / (e2u + 1)

// Update Gating
// "Closed Bar": updates strictly on confirmed bar.
// "Realtime": updates intrabar.
// NOTE: ta.* functions must run GLOBALLY (outside this check).
bool update_allowed = (calc_mode == "Realtime (Repainting)") ? true : barstate.isconfirmed

// -----------------------------------------------------------------------------
// 3. GLOBAL INDICATORS (Always calculated to maintain ta.* consistency)
// -----------------------------------------------------------------------------
// 3.1 Efficiency Ratio (ER)
len_er = 20
er_change = math.abs(close - close[len_er])
er_vol    = math.sum(math.abs(close - close[1]), len_er)
er_val    = f_safe_div(er_change, er_vol)

// 3.2 ADX
adx_len = 14
dirmov_len = 14
[di_plus, di_minus, adx_val] = ta.dmi(dirmov_len, adx_len)

// 3.3 BB Width
bb_len  = 20
bb_mult = 2.0
bb_basis = ta.sma(close, bb_len)
bb_dev   = bb_mult * ta.stdev(close, bb_len)
bb_upper = bb_basis + bb_dev
bb_lower = bb_basis - bb_dev
bbw_raw  = f_safe_div(bb_upper - bb_lower, bb_basis)
bbw_sma  = ta.sma(bbw_raw, bb_len)

// 3.4 Trend EMAs
ema_fast = ta.ema(close, 50)
ema_slow = ta.ema(close, 200)

// 3.5 ATR (Safe)
atr_len = 14
atr_val = ta.atr(atr_len)
atr_safe = math.max(atr_val, syminfo.mintick)

// 3.6 Pivots (for Structure & Divergence)
piv_l_len = 2
piv_r_len = 2
ph = ta.pivothigh(piv_l_len, piv_r_len)
pl = ta.pivotlow(piv_l_len, piv_r_len)
// Note: ph/pl are non-na only on the offset bar (index 2).
// To use them in real-time logic, we must track them.

// 3.7 RSI (for Divergence)
rsi_val = ta.rsi(close, 14)

// 3.8 Pre-Calc Bias Components (Global for Scaling)
// Spread
spread_norm_raw = (ema_fast - ema_slow) / atr_safe
spread_abs_raw  = math.abs(spread_norm_raw)
spread_k        = ta.ema(spread_abs_raw, 100) // Auto-scaling factor

// Slope
slope_len_bi    = 8
slope_norm_raw  = (ema_fast - ema_fast[slope_len_bi]) / (atr_safe * slope_len_bi)
slope_abs_raw   = math.abs(slope_norm_raw)
slope_k         = ta.ema(slope_abs_raw, 100) // Auto-scaling factor

// -----------------------------------------------------------------------------
// 4. REGIME / Trendiness Engine
// -----------------------------------------------------------------------------
// Normalize Components
trend_er  = f_clamp(er_val, 0, 1)
trend_adx = f_clamp((adx_val - 15) / (30 - 15), 0, 1)
trend_bbw = f_clamp(f_safe_div(bbw_raw - bbw_sma, bbw_sma), 0, 1) // Expansion relative to SMA

// Combine
trendiness_raw = 0.55 * trend_er + 0.35 * trend_adx + 0.10 * trend_bbw
trendiness_s   = ta.ema(f_clamp(trendiness_raw, 0, 1), 8) // Smoothed per spec
trendiness     = trendiness_s // Use smoothed globally
TS             = math.round(100 * trendiness_s)

// State Machine (Hysteresis / Ternary)
var string reg_state = "RANGE" // Init
if update_allowed
    if TS >= 55
        reg_state := "TREND"
    else if TS <= 45
        reg_state := "RANGE"
    else
        reg_state := "MIXED"

// -----------------------------------------------------------------------------
// 5. BIAS ENGINE
// -----------------------------------------------------------------------------
// 5.1 Auto Tuning & Deadzones
atrp = f_safe_div(atr_safe, close)
volF = f_clamp((atrp - 0.002) / (0.01 - 0.002), 0, 1)

// Deadzones (Keep existing logic but remove hard scales)
dz_spread = 0.15 + 0.08 * (1 - trendiness) + 0.05 * volF
dz_slope  = 0.03 + 0.02 * (1 - trendiness) + 0.01 * volF

// 5.2 Spread Strength (Soft Saturation)
spread_strength = spread_abs_raw < dz_spread ? 0 : f_softsat(spread_abs_raw - dz_spread, spread_k)
spread_signed   = f_sign0(spread_norm_raw) * spread_strength

// 5.3 Slope Strength (Soft Saturation)
slope_strength = slope_abs_raw < dz_slope ? 0 : f_softsat(slope_abs_raw - dz_slope, slope_k)
slope_signed   = f_sign0(slope_norm_raw) * slope_strength

// 5.4 Structure State (Float Memory + Decay)
var float last_swing_high = na
var float last_swing_low  = na
var float structure_mem   = 0.0

if not na(ph)
    last_swing_high := ph
if not na(pl)
    last_swing_low := pl

if update_allowed
    // Breakout with ATR Buffer
    if not na(last_swing_high) and close > (last_swing_high + 0.15 * atr_safe)
        structure_mem := 1.0
    else if not na(last_swing_low) and close < (last_swing_low - 0.15 * atr_safe)
        structure_mem := -1.0

    // Decay in Non-Trend Regimes (Range/Mixed)
    if reg_state != "TREND"
        structure_mem := structure_mem * 0.90

structure_signed = structure_mem * 0.45 // Weight

// 5.5 Bias Combine
// Weights: Spread 0.45, Slope 0.25, Structure 0.30
bias_signed_raw = (spread_signed * 0.45) + (slope_signed * 0.25) + (structure_signed * 0.30)

// Regime Factor (Pro Bias)
// TREND -> 1.0, MIXED -> 0.25, RANGE -> 0.10
regF = reg_state == "TREND" ? 1.0 : reg_state == "MIXED" ? 0.25 : 0.10
bias_signed = bias_signed_raw * regF

// -----------------------------------------------------------------------------
// 6. EVENT / QUALITY ENGINE
// -----------------------------------------------------------------------------
// 6.1 Event Detection

// A. Fakey (Simplified & Hardcoded per user spec)
// Inside Bar at [1]
ib_cond = high[1] < high[2] and low[1] > low[2]
// False Breakout at [0] & Close inside
// Bull Fakey: trap down -> Low[0] < Low[1] but Close[0] > Low[1]. Body confirm: Close > Open.
fakey_bull = ib_cond and low < low[1] and close > low[1] and close > open
// Bear Fakey: trap up -> High[0] > High[1] but Close[0] < High[1]. Body confirm: Close < Open.
fakey_bear = ib_cond and high > high[1] and close < high[1] and close < open

float imp_fakey = 0.0
if fakey_bull
    imp_fakey := 1.0
else if fakey_bear
    imp_fakey := -1.0

// B. Outside Bar
// Enulfing range of previous bar.
outside_bull = high > high[1] and low < low[1] and close > open // directional
outside_bear = high > high[1] and low < low[1] and close < open
float imp_outside = 0.0
if outside_bull
    imp_outside := 1.0
else if outside_bear
    imp_outside := -1.0

// C. BB Touch (Regime Aware)
// RANGE: Upper -> Bear, Lower -> Bull
// TREND: Upper -> Bull, Lower -> Bear
// MIXED: Neutral/Weak (Treat like Range or ignore)
touch_upper = high >= bb_upper
touch_lower = low <= bb_lower
float imp_bb = 0.0

if touch_upper
    if reg_state == "TREND"
        imp_bb := 1.0  // Continuation
    else
        imp_bb := -1.0 // Reversion (Range/Mixed)
if touch_lower
    if reg_state == "TREND"
        imp_bb := -1.0 // Continuation
    else
        imp_bb := 1.0  // Reversion

// D. Divergence (Confirmed pivots)
// We need to store RSI at the time of pivot.
var float last_piv_rsi_high = na
var float last_piv_rsi_low  = na
// When PH confirmed, store RSI at that index
if not na(ph)
    last_piv_rsi_high := rsi_val[piv_r_len]
if not na(pl)
    last_piv_rsi_low  := rsi_val[piv_r_len]

// Check Div on Pivot Confirmation
float imp_div = 0.0
// Bull Div: Price Low < Last Pivot Low, but RSI Low > Last Pivot RSI Low
// Trigger ONLY on the bar the pivot confirms (not na(pl))
// Note: We need the PREVIOUS pivot to compare against.
// Standard logic: Current Pivot vs Previous Pivot.
// Implementing a simple queue for last 2 pivots would be best, but trying to keep minimal.
// Let's rely on looking back.
// Since this is a verifier, we compare:
//  Current confirmed pivot (pl) vs the one BEFORE it.
//  We need variables to store the *previous* pivot data.
var float prev_swing_low_price = na
var float prev_swing_low_rsi   = na
var float prev_swing_high_price = na
var float prev_swing_high_rsi   = na

if not na(pl)
    // Check Bull Div
    // Current PL is 'pl', RSI at that PL is 'rsi_val[piv_r_len]'
    curr_rsi_l = rsi_val[piv_r_len]
    if not na(prev_swing_low_price)
        if pl < prev_swing_low_price and curr_rsi_l > prev_swing_low_rsi
            imp_div := 1.0
    // Update Prev
    prev_swing_low_price := pl
    prev_swing_low_rsi   := curr_rsi_l

if not na(ph)
    // Check Bear Div
    curr_rsi_h = rsi_val[piv_r_len]
    if not na(prev_swing_high_price)
        if ph > prev_swing_high_price and curr_rsi_h < prev_swing_high_rsi
            imp_div := -1.0
    // Update Prev
    prev_swing_high_price := ph
    prev_swing_high_rsi   := curr_rsi_h


// 6.2 Trace Engine (Decay & Cooldown)
// Constants
decay_f = 0.65, cap_f = 1.0
decay_o = 0.65, cap_o = 1.0, cd_o = 1
decay_bb = 0.75, cap_bb = 2.0, cd_bb = 3
decay_div = 0.88, cap_div = 2.5, cd_div = 5

// State Vars
var float tr_f = 0.0
var float tr_o = 0.0
var float tr_bb = 0.0
var float tr_div = 0.0

var int last_idx_o   = 0
var int last_idx_bb  = 0
var int last_idx_div = 0

if update_allowed
    // F (No Cooldown mentioned, but decay)
    tr_f := f_clamp(tr_f * decay_f + imp_fakey, -cap_f, cap_f)

    // O (Cooldown 1)
    if imp_outside != 0 and (bar_index - last_idx_o) > cd_o
        tr_o := f_clamp(tr_o * decay_o + imp_outside, -cap_o, cap_o)
        last_idx_o := bar_index
    else
        tr_o := f_clamp(tr_o * decay_o, -cap_o, cap_o) // Decay only

    // BB (Cooldown 3)
    if imp_bb != 0 and (bar_index - last_idx_bb) > cd_bb
        tr_bb := f_clamp(tr_bb * decay_bb + imp_bb, -cap_bb, cap_bb)
        last_idx_bb := bar_index
    else
        tr_bb := f_clamp(tr_bb * decay_bb, -cap_bb, cap_bb)

    // DIV (Cooldown 5)
    if imp_div != 0 and (bar_index - last_idx_div) > cd_div
        tr_div := f_clamp(tr_div * decay_div + imp_div, -cap_div, cap_div)
        last_idx_div := bar_index
    else
        tr_div := f_clamp(tr_div * decay_div, -cap_div, cap_div)

// 6.3 Trigger Score & Quality
trigger_signed = (tr_f/cap_f * 0.25) + (tr_o/cap_o * 0.25) + (tr_bb/cap_bb * 0.25) + (tr_div/cap_div * 0.25)
// Note: User said "weighted_avg", but didn't specify weights for trigger, assuming equal or standard.
// "weighted_avg( (trF/capF), ... )" -> Usually implies equal weight if not specified.
// Let's stick to equal 0.25 for simplicity unless strictly specified otherwise.
// Re-reading spec: "trigger_signed = weighted_avg( ... )". No weights listed. Equal is safe.

trigger_mag = math.abs(trigger_signed)

aligned = f_sign0(trigger_signed) == f_sign0(bias_signed)
misaligned = f_sign0(trigger_signed) != f_sign0(bias_signed)

quality_boost = 0.10 + 0.05 * trendiness
quality = 1.0
if aligned
    quality := quality + (quality_boost * trigger_mag)
if misaligned
    quality := quality - (quality_boost * trigger_mag)

quality := f_clamp(quality, 0.85, 1.15)


// -----------------------------------------------------------------------------
// 7. CONF SCORE ENGINE
// -----------------------------------------------------------------------------
conf_signed = f_clamp(bias_signed * quality, -1, 1)

// Map to 0..100
conf_raw = 50 + 50 * conf_signed

// Guarantee 1: Non-Trend Drift to 50
if reg_state != "TREND"
    conf_raw := 50 + (conf_raw - 50) * 0.25

conf_score_smooth = ta.ema(conf_raw, 7) // EMA 7 per spec

// Output Latch (Fix for Closed Bar Repainting)
var float conf_latched = na
var string reg_latched = "RANGE"
var int   TS_latched   = 0

if calc_mode == "Realtime (Repainting)" or barstate.isconfirmed
    conf_latched := conf_score_smooth
    reg_latched  := reg_state
    TS_latched   := TS
else
    conf_latched := nz(conf_latched[1], conf_score_smooth)
    reg_latched  := reg_latched[1]
    TS_latched   := nz(TS_latched[1], TS)

// 7.1 Bias BG State Logic
// Use TS_latched for stable thresholds in Closed Bar mode
widen = f_clamp(math.round(4 * (1 - (TS_latched / 100.0))), 0, 3)
bull_on  = 60 + widen
bull_off = 55 + widen
bear_on  = 40 - widen
bear_off = 45 - widen

base_bars = timeframe.isintraday ? 2 : 3
confirm_bars = f_clamp(base_bars + (TS_latched < 35 ? 1 : 0), 1, 4)

var int bias_state = 0
var int bull_cnt = 0
var int bear_cnt = 0
var int exit_cnt = 0
var int state_age = 0

// Range Kill-Switch
if update_allowed
    if reg_latched != "TREND"
        bias_state := 0
        bull_cnt   := 0
        bear_cnt   := 0
        exit_cnt   := 0
        state_age  := 0
    else
        // Entry Counters
        if conf_latched > bull_on
            bull_cnt += 1
        else
            bull_cnt := 0

        if conf_latched < bear_on
            bear_cnt += 1
        else
            bear_cnt := 0

        // Exit Counters (HoldBars + Confirmation)
        bool cond_exit_bull = bias_state == 1 and conf_latched < bull_off
        bool cond_exit_bear = bias_state == -1 and conf_latched > bear_off

        if cond_exit_bull or cond_exit_bear
            exit_cnt += 1
        else
            exit_cnt := 0

        // State Age
        if bias_state != 0
            state_age += 1
        else
            state_age := 0

        // State Transitions
        // Entry
        if bias_state == 0
            if bull_cnt >= confirm_bars
                bias_state := 1
                state_age := 1
                exit_cnt := 0
            else if bear_cnt >= confirm_bars
                bias_state := -1
                state_age := 1
                exit_cnt := 0

        // Exit (Must hold 3 bars and confirm exit 2 bars)
        if bias_state != 0 and state_age >= 3 and exit_cnt >= 2
            bias_state := 0
            state_age := 0
            exit_cnt := 0

// -----------------------------------------------------------------------------
// 8. VISUALIZATION
// -----------------------------------------------------------------------------
// 8.1 Background Blocks
intensity = f_clamp(TS_latched / 100.0, 0, 1)
alpha_val = 90 - math.round(60 * intensity) // Stronger trend = less transparent

bg_col = color.new(color.gray, 100)
if show_bg
    if bias_state == 1
        bg_col := color.new(color.green, alpha_val)
    else if bias_state == -1
        bg_col := color.new(color.red, alpha_val)

bgcolor(bg_col, title="Regime Background")

// 8.2 Info Panel
// Table logic
var table panel = table.new(position.bottom_right, 2, 2, bgcolor=color.new(color.black, 50), border_color=color.gray, border_width=1)

if show_panel and barstate.islast
    // Row 1: CONF
    table.cell(panel, 0, 0, "CONF", text_color=color.white, text_size=size.small)
    conf_col = conf_latched > 55 ? color.green : conf_latched < 45 ? color.red : color.gray
    table.cell(panel, 1, 0, str.tostring(math.round(conf_latched)), text_color=conf_col, text_size=size.small)

    // Row 2: REG
    table.cell(panel, 0, 1, "REG", text_color=color.white, text_size=size.small)
    reg_col = reg_latched == "TREND" ? color.orange : color.silver
    table.cell(panel, 1, 1, reg_latched, text_color=reg_col, text_size=size.small)

// Debug Plots (Hidden by default, useful for dev)
plot(debug ? TS_latched : na, "Trend Strength", color=color.yellow, display=display.none)
plot(debug ? bias_signed : na, "Bias Signed", color=color.blue, display=display.none)
plot(debug ? conf_latched : na, "CONF Score", color=color.purple, display=display.none)
plot(debug ? regF : na, "Regime Factor", color=color.white, display=display.none)
plot(debug ? conf_raw : na, "CONF Raw", color=color.orange, display=display.none)

// -----------------------------------------------------------------------------
// 9. ALERTS
// -----------------------------------------------------------------------------
// Alerts use latched values to ensure they fire only on confirmed logic in Closed Bar mode
bull_entry = ta.crossover(conf_latched, 70) and reg_latched == "TREND"
bear_entry = ta.crossunder(conf_latched, 30) and reg_latched == "TREND"

reg_to_trend = reg_latched == "TREND" and reg_latched[1] != "TREND"
reg_to_range = reg_latched == "RANGE" and reg_latched[1] != "RANGE"

alertcondition(bull_entry, "Bull Entry Zone", "CONF entered Bull Zone (70+) with Trend")
alertcondition(bear_entry, "Bear Entry Zone", "CONF entered Bear Zone (30-) with Trend")
alertcondition(reg_to_trend, "REG Trend", "Regime changed to TREND")
alertcondition(reg_to_range, "REG Range", "Regime changed to RANGE")

// End of Script
