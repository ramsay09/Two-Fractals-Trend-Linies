//@version=5

indicator('Market Context & Confluence Suite', overlay=true, shorttitle='MCCS', max_bars_back=3000, max_lines_count=500, max_boxes_count=500, max_labels_count=500, dynamic_requests=true)

general_info   = input.bool(title='General Description', defval=false, tooltip='Use the signals in confluence and as an indication of market tension, which will discharged in higher volatility or trend continuation. ... context matters.
                 Always keep in mind: the most direct indicator is the chart itself. Choose these tools wisely.')

// Constants for Panel & Weights (Centralized)
int PANEL_ROWS = 15
int PANEL_COLS = 3

// Confluence Weights
int W_FR    = 4
int W_FVG   = 4
int W_KAMA  = 1
int W_CLOUD = 1
int W_SLOPE = 1
int W_TL    = 1
int W_SEG   = 1
int W_MA    = 1
int W_L12   = 1
int W_DIV   = 1
int W_PAT   = 1
int W_VOL   = 1
int W_BB    = 1
int W_O     = 1


// --- TOP LEVEL UI ---
// adx, hma and ema1 x ema2 mtf trend info panel
trading_approach        = input.string("Custom", "Context Lenses", options=["Custom", "Market Map", "Opening Auction", "Value Reversion", "Compression -> Expansion", "Trend Continuation", "Range Rotation"], tooltip="Applies focused defaults for a trading lens. Custom = manual.\nâ€¢ Market Map: Sessions + key levels.\nâ€¢ Opening Auction: OR/IB + RVOL.\nâ€¢ Value Reversion: VWAP bands + BB touch.\nâ€¢ Compression -> Expansion: Squeeze + RVOL.\nâ€¢ Trend Continuation: Trend tools + weekly VWAP.\nâ€¢ Range Rotation: VWAP zone + BB touch.")


panel_pos               = input.string(title='MTF Panel', inline="panel", defval='Bottom Right', options=['None', 'Top Right', 'Bottom Right', 'Bottom Left'],
                          tooltip='')
panel_update_mode       = input.string("Realtime Preview", "â €Panel Update Mode", inline="panel", options=["Realtime Preview", "Strict Confirm"], tooltip="Provides an overview of multi time frame trends: FVG Close state, and Fractal Break state. Select position to enable.\nâ—‹ = developing (current candle not closed), \nâ— = confirmed (closed).\nRealtime Preview: shows live/developing values (â—‹). \nStrict Confirm: shows last confirmed close values only (â—).")
bool panel_show_live    = panel_update_mode == "Realtime Preview"

auto_tuning         = input.string("Balanced", "CONF/REG Auto Tuning", options=["Conservative", "Balanced", "Aggressive"], tooltip="CONF (Trend Bias) shows the current dominant trend direction as a compact 0â€“100 score.
                     \nâ€¢ BULL / BEAR / NEUT = direction
                     \nâ€¢ Number = bias strength (50 = neutral)
                     \nâ€¢ H / M / L = quality / reliability (high / medium / low)
                     \nHow CONF is built:
                     \nâ€¢ Core bias comes from structural trend components (mainly FVG state + fractal/structure + a trend filter).
                     \n  The first FVG sets the bias and it stays valid until an opposite FVG appears.
                     \nâ€¢ Trendlines & Segments act only as short-lived confirmation (with decay) and cannot flip the bias on their own.
                     \nâ€¢ REG (SQUEEZE/TREND/RANGE) gates reliability: in SQUEEZE, CONF is intentionally dampened (FVG is not counted at full weight).
                     \nVisuals:
                     \nâ€¢ Green/Red = Bull/Bear bias
                     \nâ€¢ NEUT is fully transparent (panel + chart background).
                     \n\nPlots the Confluence Signal background color.
                     \nAuto uses tuned parameters for CONF/REG. \nSensitivity of Auto Mode.\nConservative: Slower, safer.\nBalanced: Standard.\nAggressive: Faster, more signals.")

// MTF CANDLE OVERLAY INPUTS
//grp_mtf_candle    = "MTF Candle Overlay"
show_mtf_candles  = input.bool(false, "MTF Candle Overlay", inline="mtf_ov", tooltip="")
mtf_tf_sel        = input.string("1h", "", options=["5m", "15m", "30m", "1h", "2h", "4h", "6h", "12h", "1d", "1w", "1M", "3M"], inline="mtf_ov")
mtf_opacity       = input.int(15, "â €Opacity %", inline="mtf_ov", minval=0, maxval=100, tooltip="Two timelines at one glance. It's like looking inside a candle with X-rays. \n0% = Invisible, 100% = Solid")

// fractals input
grp_adv_set     = "â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €Advanced Settings"
fractals_plot   = input.bool(title='Bill Williams Fractalsâ €', inline="fr_s", defval=true, group=grp_adv_set, tooltip='')
sub_fractals    = input.bool(title='Sub Fractals', inline="fr_s", defval=false, group=grp_adv_set, tooltip='Bill Williams Fractals (five Candles): white triangle. Works as support and resistance level.
                 \nSub Bill Williams Fractals (four Candles): Lightgray triangle. Works as support and resistance level. These are B. W. Fractals on a Lower Timeframe.')


// Confluence & Regime Visuals
grp_conf_reg    = "Confluence & Regime Visuals"

conf_use_vwap_quality = input.bool(true, "CONF: VWAP Quality Gate", group=grp_conf_reg, tooltip="Adjusts CONF quality using VWAP alignment + stretch (anti-chase). State remains unchanged.")
conf_vwap_mode        = input.string("Auto", "VWAP Anchor", inline="conf", options=["Auto","Session VWAP","Weekly VWAP"], group=grp_conf_reg, tooltip="")
conf_z_penalty_mode   = input.string("Default", "â €Stretch Penalty", inline="conf", options=["Default","Conservative","Aggressive"], group=grp_conf_reg, tooltip="Which VWAP anchor CONF uses for quality. Auto: Session â‰¤ 60m, Weekly > 60m. \nHow strongly VWAP stretch reduces CONF quality.")

show_conf_meter     = input.bool(true, "CONFâ €â €â €", inline="conf_ui", group=grp_conf_reg, tooltip="")
show_conf_bg        = input.bool(false, "Confluence Meter BGâ €", inline="conf_ui", group=grp_conf_reg, tooltip="Colors the chart background based on CONF score thresholds (score > 55 = green, < 45 = red). Neutral stays transparent.")
show_confirmed_bias_bg  = input.bool(false, "Confirmed Bias BG", inline="conf_ui", group=grp_conf_reg, tooltip="Colors the chart background based on Confirmed Bias (BULL/BEAR/NEUT). Useful to compare the stable filter vs the score background.")

show_regime_panel   = input.bool(true, "REGâ €â €â €â €", inline="REGIME_UI", group=grp_conf_reg, tooltip="")
regime_bg_enabled   = input.bool(false, "Squeeze & Trend BG", inline="REGIME_UI", group=grp_conf_reg, tooltip="Market Regime Detection (Squeeze/Trend/Range). \nâ€¢ Panel: Displays state in Info Table. \nâ€¢ BG: Colors chart background (Gold=Squeeze, Blue=Trend). \n\nPanel Codes: \nâ€¢ RVOL: L(<Low), M(Low-Med), H(Med-High), E(>High) \nâ€¢ VWAP Z: N(Normal), S(Stretch), T(TP), E(Extreme)\nâ—‹ = developing (current candle not closed), â— = confirmed (closed).")

// CONF Panel: Confirmed Bias (profile + optional scalp optimization)
//string grp_conf_bias = "CONF Confirmed Bias"
cb_profile      = input.string("Standard", "Bias Confirmation Profile", inline="bias", options=["Stable","Standard","Fast"], tooltip="")
cb_scalp_opt    = input.bool(false, "Scalp Optimize", inline="bias", tooltip="Stable: fewer flips, stronger filter.\nStandard: allround.\nFast: quicker bias response (timing).
                  \nScalp Optimize: Optimizes confirmed bias parameters for scalping (faster reaction).\nBias remains a direction gate; entries come from separate signals.")

string M_FORM = "â—‹"
string M_CONF = "â—"
color MARKER_COLOR = color.new(color.white, 50)
marker_size_grid = size.normal
marker_size_inline = size.small

f_marker(bool show_live, bool is_confirmed) =>
    show_live and not is_confirmed ? M_FORM : M_CONF

f_with_marker(string txt, string marker) =>
    txt + " " + marker

f_panel_row(int r) =>
    r


// --- STAGE 2: CONFIGURATION & AUTO-SCALING ---

// 1. Timeframe Classification
int tf_sec = timeframe.in_seconds(timeframe.period)

// 2. Define Effective Variables (Init)
// CONF - Variables defined via f_resolve_auto_params

// REG
int eff_adx_len      = 14
// eff_adx_th defined via f_resolve_auto_params
int eff_bb_len       = 20
float eff_bb_mult    = 2.0
int eff_kc_len       = 20
float eff_kc_mult    = 1.5
bool eff_squeeze_strict = true
bool eff_use_kc_squeeze = true

// ADR/ATR
// eff_use_adr_gate defined via f_resolve_auto_params
int eff_adr_len      = 20
// eff_adr_warn defined via f_resolve_auto_params
// eff_adr_hard defined via f_resolve_auto_params
int eff_atr_len      = 14
int eff_atr_norm     = 50
float eff_atr_low    = 0.90
float eff_atr_high   = 1.10

f_resolve_auto_params(_tf_sec, _auto_tuning) =>
    bool is_fast = _tf_sec <= 900
    bool is_med = _tf_sec > 900 and _tf_sec <= 14400
    bool is_slow = _tf_sec > 14400 and _tf_sec < 86400
    bool is_daily = _tf_sec >= 86400 and _tf_sec < 604800
    bool is_weekly_plus = _tf_sec >= 604800
    int a_core_len = 13
    int a_persist = 3
    int a_vol_len = 80
    float a_enter_k = 1.0
    float a_exit_k = 0.5
    float a_decay = 0.70
    float a_clamp = 0.15
    int a_adx_th = 20
    bool use_adr_gate = true
    float adr_warn = 85.0
    float adr_hard = 110.0
    if is_fast
        a_core_len := 8
        a_persist  := 3
        a_vol_len  := 50
    else if is_med
        a_core_len := 13
        a_persist  := 3
        a_vol_len  := 80
    else if is_slow
        a_core_len := 21
        a_persist  := 2
        a_vol_len  := 120
    else if is_daily
        a_core_len := 21
        a_persist  := 2
        a_vol_len  := 150
    else
        a_core_len := 34
        a_persist  := 2
        a_vol_len  := 200
    if _auto_tuning == "Conservative"
        a_enter_k := 1.25
        a_exit_k  := 0.65
        a_decay   := 0.60
        a_clamp   := 0.12
        a_adx_th  := 22
        a_core_len := math.round(a_core_len * 1.4)
        a_vol_len  := math.round(a_vol_len * 1.4)
        a_persist  := math.min(a_persist + 2, 6)
        use_adr_gate := true
        adr_warn := 85.0
        adr_hard := 110.0
    else if _auto_tuning == "Aggressive"
        a_enter_k := 0.80
        a_exit_k  := 0.45
        a_decay   := 0.75
        a_clamp   := 0.18
        a_adx_th  := 18
        a_core_len := math.max(math.round(a_core_len * 0.75), 5)
        a_vol_len  := math.max(math.round(a_vol_len * 0.75), 30)
        a_persist  := math.max(a_persist - 3, 1)
        use_adr_gate := (is_daily or is_weekly_plus) ? false : true
        adr_warn := 85.0
        adr_hard := 110.0
    else
        a_enter_k := 1.00
        a_exit_k  := 0.50
        a_decay   := 0.70
        a_clamp   := 0.15
        a_adx_th  := 20
        use_adr_gate := true
        adr_warn := 85.0
        adr_hard := 110.0
        // Balanced: persist -1 (more responsive than default)
        a_persist := math.max(a_persist - 1, 1)
    [int(a_core_len), int(a_vol_len), a_enter_k, a_exit_k, int(a_persist), a_decay, a_clamp, a_adx_th, use_adr_gate, adr_warn, adr_hard]

[eff_core_ema_len, eff_vol_len, eff_enter_k, eff_exit_k, eff_persist_bars, eff_ov_decay, eff_ov_clamp, eff_adx_th, eff_use_adr_gate, eff_adr_warn, eff_adr_hard] = f_resolve_auto_params(tf_sec, auto_tuning)

// --- Confirmed Bias: Profile Resolver (Stable / Standard / Fast + Scalp Optimize) ---
f_resolve_bias_confirm_params(string _profile, bool _scalp_opt) =>
    // Base defaults: Standard
    float enter_bull = 55.0
    float exit_bull  = 52.0
    float enter_bear = 45.0
    float exit_bear  = 48.0
    int enter_bars   = 2
    int exit_bars    = 1

    if _profile == "Stable"
        enter_bull := 58.0
        exit_bull  := 53.0
        enter_bear := 42.0
        exit_bear  := 47.0
        enter_bars := 3
        exit_bars  := 2
    else if _profile == "Fast"
        enter_bull := 54.0
        exit_bull  := 52.0
        enter_bear := 46.0
        exit_bear  := 48.0
        enter_bars := 1
        exit_bars  := 1

    if _scalp_opt
        // A) Persistenz (Bars)
        enter_bars := math.max(1, enter_bars - 1)
        exit_bars  := math.max(1, exit_bars - 1)

        // B) Hysterese / Schwellen (symmetrische Beschleunigung)
        enter_bull := enter_bull - 2.0
        exit_bull  := exit_bull  - 1.0
        enter_bear := enter_bear + 2.0
        exit_bear  := exit_bear  + 1.0

        // C) Invarianten / Clamps
        exit_bull := math.max(exit_bull, 51.0)
        exit_bear := math.min(exit_bear, 49.0)
        enter_bull := math.max(enter_bull, exit_bull + 1.0)
        enter_bear := math.min(enter_bear, exit_bear - 1.0)

    // Clamp all thresholds to [0..100]
    enter_bull := math.max(0.0, math.min(100.0, enter_bull))
    exit_bull  := math.max(0.0, math.min(100.0, exit_bull))
    enter_bear := math.max(0.0, math.min(100.0, enter_bear))
    exit_bear  := math.max(0.0, math.min(100.0, exit_bear))

    [enter_bull, enter_bear, exit_bull, exit_bear, enter_bars, exit_bars]

[eff_cb_enter_bull, eff_cb_enter_bear, eff_cb_exit_bull, eff_cb_exit_bear, eff_cb_enter_bars, eff_cb_exit_bars] = f_resolve_bias_confirm_params(cb_profile, cb_scalp_opt)

// FVG Inputs
grp_fvg1        = "Price Imbalance (Fair Value Gap) 1"
plot_fvg1       = input.bool(true, title="FVG 1 â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €", group=grp_fvg1, inline="f1_1", tooltip="")
fvg1_tf_sel     = input.timeframe("", title="TF", group=grp_fvg1, inline="f1_1", tooltip="Indicates a potential pullback area after an strong price movement (Displacement). Also reveals institutional interest (new trend). \nSelect the timeframe for Price Imbalance detection. Chart = Current Chart Timeframe.")
fvg1_len        = input.int(1, title="Box Length", minval=1, group=grp_fvg1, inline="f1_2")
fvg1_limit      = input.int(50, title="â €â € Visible Boxes", minval=1, maxval=500, group=grp_fvg1, inline="f1_2")
col_fvg1_bull   = input.color(color.new(color.green, 80), title="Bullish Color", group=grp_fvg1, inline="f1_3")
col_fvg1_bear   = input.color(color.new(color.red, 80), title="â €â €â €â €â €â €â €â € Bearish Color", group=grp_fvg1, inline="f1_3")

grp_fvg2        = "Price Imbalance (Fair Value Gap) 2"
plot_fvg2       = input.bool(false, title="FVG 2 â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €", group=grp_fvg2, inline="f2_1", tooltip="")
fvg2_tf_sel     = input.timeframe("", title="TF", group=grp_fvg2, inline="f2_1", tooltip="Indicates a potential pullback area after an strong price movement (Displacement). Also reveals institutional interest (new trend). \nSelect the timeframe for Price Imbalance detection. Chart = Current Chart Timeframe.")
fvg2_len        = input.int(1, title="Box Length", minval=1, group=grp_fvg2, inline="f2_2")
fvg2_limit      = input.int(5, title="â €â € Visible Boxes", minval=1, maxval=500, group=grp_fvg2, inline="f2_2")
col_fvg2_bull   = input.color(color.new(color.green, 80), title="Bullish Color", group=grp_fvg2, inline="f2_3")
col_fvg2_bear   = input.color(color.new(color.red, 80), title="â €â €â €â €â €â €â €â € Bearish Color", group=grp_fvg2, inline="f2_3")

// Key Levels Inputs
grp_key             = "Key Levels"
key_levels_enabled  = input.bool(true, "Key Levels", group=grp_key, tooltip="Previous Day High/Low/Close, Weekly/Monthly Open. \nKey reference levels for intraday structure, targets, and invalidation. \n\nâ€¢ PDH/PDL: Liquidity Magnets; Break/Reject helps Bias. \nâ€¢ PDC: Mean-reversion reference. \nâ€¢ Weekly/Monthly Open: Trend-Bias; Market above = Bull, below = Bear. \n\nOrigin-anchored: Lines start at the bar where the level formed.")
show_pdh            = input.bool(true, "PDHâ €", inline="kl_1", group=grp_key, tooltip="Prior Day High = liquidity pool; break+hold â†’ continuation, sweep+reclaim â†’ trap.")
show_pdl            = input.bool(true, "PDLâ €", inline="kl_1", group=grp_key, tooltip="Prior Day Low = liquidity pool; break+hold â†’ continuation, sweep+reclaim â†’ trap.")
show_pdc            = input.bool(false, "PDCâ €", inline="kl_1", group=grp_key, tooltip="Reversion target / magnet on range days.")
show_wopen          = input.bool(true, "Weekly Openâ €", inline="kl_1", group=grp_key, tooltip="Higher timeframe bias line; watch reclaim/hold for continuation days.")
show_mopen          = input.bool(false, "Monthly Open", inline="kl_1", group=grp_key, tooltip="Higher timeframe bias line; watch reclaim/hold for continuation days.")
key_style           = input.string("Both", "Style", options=["Lines", "Labels", "Both"], inline="kl_3", group=grp_key, tooltip="Visual style for levels.")
key_extend          = input.bool(true, "Extend", inline="kl_3", group=grp_key, tooltip="Extend projects the level into the future; turn off to keep chart clean.")

// RVOL Inputs
grp_rvol            = "Relative Volume & High Volume Spikes"
rvol_enabled        = input.bool(true, "RVOL Enabled", group=grp_rvol, tooltip="Relative Volume = Current Vol / Avg Vol. \nMeasures participation; confirms breakouts and reclaims. \nâ€¢ Opening Auction / Expansion: RVOL > 2.0 signals expansion. \nâ€¢ Reclaim: RVOL pickup confirms strength.")
rvol_len            = input.int(20, "Length", minval=1, group=grp_rvol, inline="rv_1", tooltip="Average window; 20 is common.")
rvol_display        = input.string("Marker", "â €Display", options=["None", "Marker", "Label", "Both"], group=grp_rvol, inline="rv_1", tooltip="Visual style.")
rvol_points_enabled = input.bool(true, "Points", group=grp_rvol, inline="rv_1", tooltip="H/E only markers to reduce noise. \nEnabled by default in Opening Auction / Expansion lenses.")
rvol_th_1           = input.float(1.2, "Lowâ €", step=0.1, group=grp_rvol, inline="rv_2", tooltip="1.2x: Slightly elevated.")
rvol_th_2           = input.float(2.0, "â €Med", step=0.1, group=grp_rvol, inline="rv_2", tooltip="2.0x: Event / Breakout fuel.")
rvol_th_3           = input.float(3.0, "â €High", step=0.1, group=grp_rvol, inline="rv_2", tooltip="3.0x: Strong trend / News.")

show_vol            = input.bool(true, "High Volume Spikesâ €", group=grp_rvol, inline="vol_sp", tooltip="A small 'V' indicates whether institutions are active (e.g., double the average volume). High volume is often observed at local highs and lows.")
vol_mult            = input.float(2.0, "Threshold (x Avg)", inline="vol_sp", group=grp_rvol)


// VWAP Inputs
grp_vwap            = "VWAP / Value Zone"
vwap_enabled        = input.bool(false, "VWAP Enabled", group=grp_vwap, tooltip="Volume-weighted fair value. \nâ€¢ Trend: Above=Bull, Below=Bear. \nâ€¢ Reversion: Far from VWAP = Stretched.")
vwap_anchor         = input.string("Session (Daily Reset)", "Anchor", options=["Session (Daily Reset)", "Weekly"], group=grp_vwap, inline="vw_1", tooltip="Session: Intraday fair value. \nWeekly: Swing bias filter.")
vwap_src_opt        = input.string("HLC3", "â €Source", options=["HLC3", "HL2", "Close", "OHLC4"], group=grp_vwap, inline="vw_1", tooltip="HLC3 standard for fair value, HL2 for range focus, Close simplest; choose oneâ€”avoid overfitting.")
vwap_show_line      = input.bool(true, "Show Lineâ €", group=grp_vwap, inline="vw_2")
vwap_only_sess      = input.bool(false, "Calc Only in Sessions", group=grp_vwap, inline="vw_2", tooltip="If enabled, VWAP pauses outside selected sessions.")

vwap_display_mode   = input.string("Value Zone (Â±1Ïƒ)", "Display", options=["Line only", "Value Zone (Â±1Ïƒ)", "Full Bands (B1â€“B3)"], group=grp_vwap, inline="vw_3", tooltip="Line only: clean bias filter. \nValue Zone: VWAP Â±1Ïƒ. \nFull: bands B1â€“B3.")
vwap_bands_enabled  = input.bool(true, "Bands Enabled", group=grp_vwap, inline="vw_3", tooltip="Standard Deviation Bands (K1/K2/K3). \nUsage: 'Don't chase' zones and Take Profit targets.")
vwap_sigma_mode     = input.string("Rolling (ta.stdev)", "Sigma Mode", options=["Rolling (ta.stdev)", "Session (Welford)"], group=grp_vwap, inline="vw_4", tooltip="Rolling: Last N bars (Stable). \nWelford: Session-cumulative (Precise).")
vwap_stdev_len      = input.int(100, "â €Len", minval=2, group=grp_vwap, inline="vw_4")
band_k1             = input.float(1.0, "K1", step=0.5, group=grp_vwap, inline="vw_6", tooltip="1st Band Multiplier (1Ïƒ).")
band_k2             = input.float(2.0, "â €K2", step=0.5, group=grp_vwap, inline="vw_6", tooltip="2nd Band Multiplier (2Ïƒ).")
band_k3             = input.float(3.0, "â €K3", step=0.5, group=grp_vwap, inline="vw_6", tooltip="3rd Band Multiplier (3Ïƒ).")

vwap_z_enabled      = input.bool(true, "Z-Score Enabled", group=grp_vwap, inline="vw_5", tooltip="Z-Score = Distance to VWAP in Sigmas. \nUsed for Value Reversion signals.")
z_th_entry          = input.float(2.0, "â €Entry Th", step=0.1, group=grp_vwap, inline="vw_5", tooltip="Avoid entries when stretched > Entry Th.")
z_th_tp             = input.float(2.5, "â €TP Th", step=0.1, group=grp_vwap, inline="vw_5", tooltip="Scale out when Z reaches TP Th.")
z_th_ext            = input.float(3.0, "Ext Th", step=0.1, group=grp_vwap, inline="vw_5", tooltip="Extreme extension; look for reversals.")

// Lite Value (POC/VAH/VAL)
grp_lite_value           = "Lite Value (POC/VAH/VAL)"
lite_value_enable        = input.bool(false, "value Area Levels", group=grp_lite_value, tooltip="Lightweight value area levels (POC/VAH/VAL). 3 lines only.")
lite_value_apply_to      = input.string("Map + Range only (recommended)", "Apply To", options=["Map + Range only (recommended)", "All Lenses", "Custom only"], group=grp_lite_value)
lite_value_lookback      = input.int(400, "Lookbackâ €â €", minval=100, maxval=800, group=grp_lite_value, inline="lv_1")
lite_value_bins          = input.int(32, "â €â €â €Binsâ €â €â €â €â €â €", minval=16, maxval=48, group=grp_lite_value, inline="lv_1")
lite_value_area_pct      = input.float(70.0, "Value Area %", minval=50, maxval=85, step=0.5, group=grp_lite_value, inline="lv_2")
lite_value_src           = input.string("HLC3", "â €â €â €Sourceâ €â €â €â €", options=["HL2", "HLC3", "Close"], group=grp_lite_value, inline="lv_2")
lite_value_update        = input.string("On last bar", "Updateâ €â €â €", options=["On last bar", "Every N bars"], group=grp_lite_value, inline="lv_3")
lite_value_update_n      = input.int(5, "â €â €â €â €Nâ €â €â €â €â €â €â €", minval=1, maxval=50, group=grp_lite_value, inline="lv_3")
lite_value_line_width    = input.int(1, "Line Width", minval=1, maxval=4, group=grp_lite_value, inline="lv_4")
lite_value_line_transp   = input.int(30, "â €â €â €Transparency", minval=0, maxval=90, group=grp_lite_value, inline="lv_4")

// OR/IB Inputs
grp_or              = "Opening Range / Initial Balance"
or_enabled          = input.bool(false, "OR/IB Enabled", group=grp_or, tooltip="Defines the first battle zone; key for trend vs range days.")

use_sess_1st    = input.bool(false, "1st Session Candle â €â €â €â €â €", inline="sess_1st", group=grp_or, tooltip="")
sess_1st_tf     = input.timeframe("5", "", inline="sess_1st", group=grp_or, tooltip="Lines remain at the high and low of the first candle of the running trading session. \nSelect the timeframe for the 1st Session Candle calculation.")

or_type             = input.string("Opening Range", "Type", options=["Opening Range", "Initial Balance"], group=grp_or, inline="or_1", tooltip="OR: User defined minutes. \nIB: First 60 minutes.")
or_sess             = input.string("New York", "â €Session", options=["London", "New York", "Custom"], group=grp_or, inline="or_1", tooltip="Market open context.")
or_cust             = input.session("0930-1600", "Custom Sess", group=grp_or, inline="or_2")
or_min              = input.int(15, "Duration", inline="or_2", minval=1, group=grp_or, inline="or_2", tooltip="Window size in minutes (for OR).")
or_display          = input.string("Box+Lines", "Display", options=["Box+Lines", "Box", "Lines"], group=grp_or, inline="or_3", tooltip="Visual style.")
or_lock             = input.bool(true, "Lock after Window", group=grp_or, inline="or_3", tooltip="Freeze levels after window ends (required for breakouts).")

// Squeeze Box
grp_sq              = "Squeeze Box"
sq_box_enabled      = input.bool(false, "Squeeze Boxâ €", inline="sq_b", group=grp_sq, tooltip="Builds a box during squeeze regime. Trade release/break with RVOL confirmation.")
sq_lock             = input.bool(true, "Lock on Release", inline="sq_b", group=grp_sq, tooltip="Locks the box levels when the squeeze ends to provide breakout references.")
sq_tf               = input.timeframe("", "â €â €TF", inline="sq_b", group=grp_sq, tooltip="Select the timeframe used for Squeeze Box squeeze detection/range.\nâ€¢ Chart: uses current chart timeframe.\nâ€¢ Higher TF: builds the box from that TF squeeze.\nLower TF selections fall back to Chart.")


// Smart MTF S&R
grp_psr             = "Smart S&R (Support & Resistance)"
ps_mode             = input.string("None", title="Smart S&R", options=["None", "Auto", "Manuell"], group=grp_psr, inline="en_tf", tooltip="")
ps_tf               = input.timeframe("D", title="â €â €â €â €Pivot TFâ €â €", inline="en_tf", group=grp_psr, tooltip="Activates the 'Smart Market Structure' system:
                      \nâ€¢ Multi-Timeframe Analysis: Identifies significant Swing Highs/Lows from a higher timeframe (e.g., 4H levels on a 15m chart).
                      \nâ€¢ Noise Filtering: Uses adjustable pivot strength to ignore minor price fluctuations.
                      \nâ€¢ Smart Zones: Automatically merges levels that are close together into a single 'Zone' (Box) to reduce clutter.
                      \nâ€¢ Dynamic State: Tracks confirmed breakouts and can automatically flip Support to Resistance (Role Reversal) or remove broken levels.
                      \nâ€¢ Clutter Control: Manages a fixed number of active levels, removing old or irrelevant ones automatically. \nSelect the Higher Timeframe to scan for significant Swing Highs/Lows. \nSmart S&R 'Auto' affects 'Pivot TF' only.")
ps_left             = input.int(2, title="Pivot Left", inline="pivot", minval=1, group=grp_psr, tooltip="Higher values filter out minor market noise. Left Standard=2 (Bill Williams Fractal).")
ps_right            = input.int(2, title="â €â €â €â €Pivot Right", inline="pivot", minval=1, group=grp_psr, tooltip="Higher values filter out minor market noise. Right Standard=2 (Bill Williams Fractal).")
ps_max              = input.int(20, title="Max Active Levels â €", minval=1, maxval=50, group=grp_psr, tooltip="Limits the number of visible lines to prevent chart clutter. FIFO (First In, First Out).")
ps_break_act        = input.string("Role Reversal", title="On Break Action ", options=["Keep", "Delete", "Role Reversal"], group=grp_psr, tooltip="How the script handles a level when price crosses it. \nKeep: Do nothing. \nDelete: Remove line. \nRole Reversal: Support becomes Resistance (Color change).")
ps_merge_en         = input.bool(true, title="Merge Nearby Levels (Zones) ", group=grp_psr, inline="ps_m")
ps_merge_pct        = input.float(0.1, title="Threshold %", minval=0.01, step=0.1, group=grp_psr, inline="ps_m", tooltip="If a new level appears within X% of an existing level, they are merged into a Zone.")
ps_col_res          = input.color(color.new(color.red, 30), title="Res Color", group=grp_psr, inline="ps_c")
ps_col_sup          = input.color(color.new(color.green, 30), title="â €Sup Color", group=grp_psr, inline="ps_c")
ps_col_zone         = input.color(color.new(color.blue, 85), title="â €Zone Fill", group=grp_psr, inline="ps_c")

// UDT for S&R Management
type SRLevel
    float price
    bool  is_res      // True=Resistance, False=Support
    bool  is_broken
    int   start_time
    line  id_line
    box   id_box      // Used if merged into a zone
    bool  is_zone

type ActiveSD
    box   id_box
    float top
    float bottom
    bool  is_bull
    bool  mitigated
    int   start_time

// --- New UDTs ---
type VwapState
    float cumVol
    float cumPV
    float vwap

type WelfordState
    int n
    float mean
    float m2

type OrState
    int start_bar
    float hi
    float lo
    bool building
    bool locked
    box id_box
    line l_hi
    line l_lo

type SqState
    float hi
    float lo
    bool active
    bool locked
    box id_box

// Bollinger Bands
grp_bb              = 'Bollinger Bands'
BB_plot             = input.bool(true, title='Bollinger Bandsâ €', inline="bb_t", group=grp_bb, tooltip='')
near_bb             = input.bool(true, title='Touched BBs only', inline="bb_t", group=grp_bb, tooltip='This maintains a better chart overview and works as reversal zone indicator.
                      \nWorks as support and resistence, as reversal zone and as squeeze indicator.')
// BB_length_1 & BB_sdev_1 moved to Advanced: REG
BB_sdev_2           = 3
BB_sdev_3           = 4
BB_sdev_4           = 5

// ema cloud and ma inputs
grp_ma              = 'EMA cloud and MA'
en_cloud            = input.bool(false, title='EMA Cloudâ €', inline="ema_c", group=grp_ma, tooltip='')
sig_plot            = input.bool(true, title='Cloud Color Signal', inline="ema_c", group=grp_ma, tooltip='EMA1 cross EMA2 color signal.
                      \nThis EMA cloud works as dynamic support and resistance and as trend indication. A wide cloud indicates high volatility, a narrow cloud indicates low volatility and breakout potential. Interesting pairs: 8/21, 40/97')

ema_inp1            = input.int(8, title='EMA1 Length', inline="ema_l", minval=1, group=grp_ma, tooltip="")
ema_inp2            = input.int(21, title='â €EMA2 Length', inline="ema_l", minval=1, group=grp_ma, tooltip="")

// MA 1 Inputs
ma1_type            = input.string("EMA", title="MA 1", options=["None", "SMA", "EMA"], inline="ma1", group=grp_ma)
ma1_len             = input.int(200, title="", minval=1, inline="ma1", group=grp_ma)
ma1_slope_c         = input.bool(false, title="Slope Color", inline="ma1", group=grp_ma)

// MA 2 Inputs
ma2_type            = input.string("SMA", title="MA 2", options=["None", "SMA", "EMA"], inline="ma2", group=grp_ma)
ma2_len             = input.int(200, title="", minval=1, inline="ma2", group=grp_ma)
ma2_slope_c         = input.bool(false, title="Slope Color", inline="ma2", group=grp_ma)

// KAMA Inputs
kama_len            = 10
kama_fast           = 2
kama_slow           = 30

// two fractal trendlines inputs
grp_fr              = 'Fractal Trend lines'
plot_trendline      = input.bool(false, title='Fractal Trend Linesâ €', inline="fr_tr", group=grp_fr, tooltip='')
fractalBarsPerSide  = input.int(2, title="Bars Per Side", minval=0, maxval=10, inline="fr_tr", group=grp_fr, tooltip="The trend lines connect two up- and two down-Bill-Williams-Fractals. Works as price action/pattern breakout signal. \nNumber of bars to the left and right of the fractal bar for trendlines. Default is 2 (5-bar fractal).
                     Min=0 (Fractal(2) using anchored linear regression, follow the highs/lows of the subsequent candles to align with the current trend), Max=10 (21 bars).")
show_last_frac  = input.bool(false, "Last Fractal S/R â €â €â €â €â €â €â €â €â €â €â €", group=grp_fr, inline="l_rf", tooltip="")
last_frac_tf    = input.timeframe("240", "", group=grp_fr, inline="l_rf", tooltip="Draws lines at the last confirmed Up/Down Fractals. Every new trend begins with the breaking of a fractal. (Time Frame dependent). \nSelect the timeframe for the Last Fractal calculation.")


// divergence signal inputs
grp_div             = 'Divergences'
plot_div            = input.bool(true, title='Divergences', group=grp_div, tooltip='These divergences are very early signals and must be used in confluence with other signals. Hidden and classic divergence are used')
div_indi            = input.string('rsi', title='Divergence Indicator', options=['rsi', 'macd(fast_line)', 'macd(slow_line)'], tooltip='Select an Indicator for divergence calculation.', group=grp_div)
rsi_length          = input.int(14, title='RSI Length', inline="rsi_p", minval=1, step=2, group=grp_div)
bar_div_p           = input.int(25, title='â €â €â €â €Bar Period', inline="rsi_p", minval=1, step=1, tooltip='RSI Length. \nThe number of bars in which divergences are detected.', group=grp_div)
src_div             = input.string('high/low', title='Bar Divergence Source', options=['high/low', 'close'], tooltip='The bar source for divergence calculation.', group=grp_div)

// bar signals inputs
grp_bar             = 'Bar signals'
plot_l12_bar        = input.bool(true, title='Last 12 Bar (L12) â €', inline="l12", tooltip='', group=grp_bar)
L12_input           = input.int(12, minval=1, title='Bar count', inline="l12", group=grp_bar, tooltip='"Letter: L, L12 => highest low of last 12 bars -> long. Lowest high of last 12 bars -> short. Indicates a new trend. \nLast 12 Bar" Bar count.')
plot_nr_bar         = input.bool(true, title='Narrow Range Bar (NR7)', tooltip='Letter: n, NR7 = narrowest range of a bar of the last seven bars. Indicates market tension.', group=grp_bar)
plot_i_bar          = input.bool(true, title='Inside Bar', tooltip='Letter: i. An inside bar is a triangle formation on smaller time frame.', group=grp_bar)
plot_o_bar          = input.bool(true, title='Outside Bar', tooltip='Letter: o. An outside bar is an opening funnel formation on smaller time frames. gray-> normal outside bar, valid at least for the next bar: red-> short, green-> long', group=grp_bar)
plot_s_bar          = input.bool(true, title='Sandwich Bar', tooltip='Letter: s. Indicates market tension.', group=grp_bar)
plot_f_bar          = input.bool(true, title='Fakey', tooltip='Letter: F. An inside bar false breakout.', group=grp_bar)

// segments inputs
grp_seg             = 'Segment signal'
plot_segments       = input.bool(false, title='Segments â €', inline="seg", tooltip='', group=grp_seg)
sb                  = input.int(10 ,title='Max Bars', inline="seg", minval=0, step=1, tooltip='Gray lines that follow the highest highs and lowest lows. This is a subtle way to detect a new trend. The higher the timeframe the more reliable the signal.
                      \nMax bars between two segment highs or segment lows.', group=grp_seg)


// pivot points inputs
grp_pi              = 'Pivot points'
plot_pivots_h1      = input.bool(false, title= "1 Hour Classic Pivot Points", group=grp_pi, tooltip= "1 Hour Pivot points (P, R1-R4, S1-S4). Only visible on charts < 1H.")
plot_pivots_h4      = input.bool(true, title= "4 Hour Classic Pivot Points", group=grp_pi, tooltip= "4 Hour Pivot points (P, R1-R4, S1-S4). Only visible on charts < 4H.")
plot_pivots_d       = input.bool(true, title= "1 Day Classic Pivot Points", group=grp_pi, tooltip= "Daily Pivot points (P, R1-R4, S1-S4). Only visible on intraday charts.")
plot_pivots_w       = input.bool(true, title= "1 Week Classic Pivot Points", group=grp_pi, tooltip= "1 week classic Pivot points are plotted (P, R1-R4, S1-4). Pivot points are used as support and resistance levels. Watch out for clusters.")
plot_pivots_m       = input.bool(true, title='1 Month Classic Pivot Points', group=grp_pi, tooltip='1 month classic pivot points are plotted (P, R1-R4, S1-4). Pivot points are used as support and resistance levels. Watch out for clusters.')
plot_pivots_3m      = input.bool(true, title='3 Month Classic Pivot Points', group=grp_pi, tooltip='3 month classic pivot points are plotted (P, R1-R4, S1-4). Pivot points are used as support and resistance levels. Watch out for clusters.')
plot_pivots_12m     = input.bool(true, title='12 Month Classic Pivot Points', group=grp_pi, tooltip='12 month classic pivot points are plotted (P, R1-R4, S1-4). Pivot points are used as support and resistance levels. Watch out for clusters.')
plot_pivot_labels   = input.bool(false, title='Pivot Labels (P/R/S + TF)', group=grp_pi, tooltip='Draws small text tags on the pivot dash (e.g., P H4, R2 W).')
// TRADING SESSIONS INPUTS ---
grp_sess      = "Trading Sessions"
sess_timezone = input.string("Europe/Berlin", title="Timezone", inline="ses", tooltip="", group=grp_sess)
sess_style    = input.string("Vertical Line", title="â €Session Style", inline="ses", options=["Vertical Line", "Box", "Background", "Inv. Background"], group=grp_sess, tooltip="Standard: Europe/Berlin. Change to 'UTC' or 'America/New_York' if needed. \nVisual style for trading sessions: \nâ€¢ Vertical Line: Start/End lines. \nâ€¢ Box: High/Low Range. \nâ€¢ Background: Session Time Window (Highest Priority Layer). \nâ€¢ Inv. Background: Unified Color (Blue 50%) during 'Off-Hours'.")

use_sess_rest   = input.bool(false, title="Session Restriction", inline="ses_rest", group=grp_sess)
sess_rest_time  = input.int(60, title="â €â €â €â €Time", inline="ses_rest", tooltip="Rstricts Session Trading Time (Default 1 hour).", group=grp_sess)

// London - ORANGE
london_show   = input.bool(true, title="London Session â €â €", group=grp_sess, inline="lon")
london_sess   = input.session("0900-1730", title="", group=grp_sess, inline="lon")
london_col    = input.color(color.new(color.orange, 90), title="", group=grp_sess, inline="lon")

// New York - BLUE
ny_show       = input.bool(true, title="New York Sessionâ €", group=grp_sess, inline="ny")
ny_sess       = input.session("1530-2200", title="", group=grp_sess, inline="ny")
ny_col        = input.color(color.new(color.blue, 90), title="", group=grp_sess, inline="ny")

// Tokyo - YELLOW
tokyo_show    = input.bool(false, title="Tokyo Session â €â €â €", group=grp_sess, inline="tok")
tokyo_sess    = input.session("0100-0900", title="", group=grp_sess, inline="tok")
tokyo_col     = input.color(color.new(color.yellow, 90), title="", group=grp_sess, inline="tok")

// Sydney - RED
sydney_show     = input.bool(false, title="Sydney Session â €â €", group=grp_sess, inline="syd")
sydney_sess     = input.session("2200-0700", title="", group=grp_sess, inline="syd")
sydney_col      = input.color(color.new(color.red, 90), title="", group=grp_sess, inline="syd")
sess_line_limit = input.int(150, "Max Session Lines (FIFO)", group=grp_sess, minval=20, tooltip="Limits total number of vertical session lines to prevent 'Max lines' error.")

// Alerts
grp_alerts      = "ðŸ”” Alerts"
alert_profile   = input.string("Normal", "Alert Profile", options=["Off", "Minimal","Normal","Moderate"], group=grp_alerts, tooltip="Controls the complexity of alert triggers to avoid spam. \nâ€¢ Off: No alerts. \nâ€¢ Minimal: Trendline Breakouts only. \nâ€¢ Normal: Adds Divergences. \nâ€¢ Moderate: Adds Regime Changes & High Confluence Events.")
alert_cooldown  = input.int(5, "Cooldown (Bars)", minval=1, group=grp_alerts, tooltip="Wait period (in bars) after an alert is triggered before the same alert type can trigger again. Prevents repetitive alerts during the same market event.")
use_rt_alert   = input.bool(false, title="Alert on 5th Fractal Candle (Real-time)", group=grp_alerts, tooltip="Triggers an alert signal while the 5th candle of a fractal pattern is forming (Real-time). Select 'Any function call' when creating the alert.")

// Debug (Performance)
debug_on       = input.bool(false, "Debug (Perf)", group="Debug")
dbg_stress     = input.bool(false, "DBG: Stress preset (limits)", group="Debug")
dbg_perf       = input.bool(false, "DBG: perf metrics", group="Debug")
bool dbg_ops   = debug_on or dbg_perf or dbg_stress

// attributes inputs
grp_atri            = "Attributes of drawn objects"
color_fr            = input.color(color.white, "Fractal Color", group=grp_atri)
transp_fr           = input.int(40, "Fractal Transparency", minval=1, maxval= 100, group=grp_atri)

color_ema_c         = input.color(color.blue, 'EMA Cloud Color', group=grp_atri)
color_ema_sig_up    = input.color(color.green, 'EMA Signal Up Cloud Color', group=grp_atri)
color_ema_sig_dn    = input.color(color.red, 'EMA Signal Down Cloud Color', group=grp_atri)
transp_ema_c        = input.int(65, 'EMA Cloud Transparency', minval=1, maxval= 100, group=grp_atri)

color_tr            = input.color(color.blue, 'Trend Line Color', group=grp_atri)
width_tr            = input.int(2, 'Trend Line Width', minval=1, group=grp_atri)
transp_tr           = input.int(50, 'Trend Line Transparency', minval=1, maxval= 100, group=grp_atri)

color_seg           = input.color(color.white, 'Segment Line Color', group=grp_atri)
transp_seg          = input.int(65, 'Segment Line Transparency', minval=1, maxval= 100, group=grp_atri)

transp_bg           = input.int(85, 'Background Color Transparency', minval=1, maxval= 100, group=grp_atri)


//-------------------------------------------------------- GLOBAL ON-FLAGS (Performance / Gating) --------------------------------------------------------
// Stage 0: Centralized Gating Flags as aliases for inputs

// Preset Helper
int approach_id = trading_approach == "Market Map" ? 1 : trading_approach == "Opening Auction" ? 2 : trading_approach == "Value Reversion" ? 3 : trading_approach == "Compression -> Expansion" ? 4 : trading_approach == "Trend Continuation" ? 5 : trading_approach == "Range Rotation" ? 6 : 0

f_approach_bool(_custom, _map, _auction, _reversion, _compExp, _trend, _range) =>
    approach_id == 1 ? _map : approach_id == 2 ? _auction : approach_id == 3 ? _reversion : approach_id == 4 ? _compExp : approach_id == 5 ? _trend : approach_id == 6 ? _range : _custom

// Preset Helper for Strings
f_approach_str(_custom, _map, _auction, _reversion, _compExp, _trend, _range) =>
    approach_id == 1 ? _map : approach_id == 2 ? _auction : approach_id == 3 ? _reversion : approach_id == 4 ? _compExp : approach_id == 5 ? _trend : approach_id == 6 ? _range : _custom

var int prev_approach_id = na
bool lens_changed = not na(prev_approach_id) and prev_approach_id != approach_id

// Debug Stress Preset (internal clamps, UI unchanged)
int fvg1_limit_eff = dbg_stress ? math.min(fvg1_limit, 120) : fvg1_limit
int fvg2_limit_eff = dbg_stress ? math.min(fvg2_limit, 120) : fvg2_limit
int sess_line_limit_eff = dbg_stress ? math.min(sess_line_limit, 120) : sess_line_limit

f_resolve_effective_flags() =>
    //                                          Cust           Map     Auction   Reversion   Comp->Exp   Trend   Range
    bool eff_fractals_plot = f_approach_bool(fractals_plot,      true,    true,     true,      true,       true,   true)
    bool eff_sub_fractals = f_approach_bool(sub_fractals,       false,   false,    false,     false,      false,  false)
    bool eff_plot_trendline = f_approach_bool(plot_trendline,    false,   false,    false,     true,       true,   false)
    bool eff_show_mtf_candles = f_approach_bool(show_mtf_candles,  false,   false,    false,     false,      true,   false)
    bool eff_use_sess_1st = f_approach_bool(use_sess_1st,       false,   true,     false,     false,      false,  false)
    bool eff_show_last_frac = f_approach_bool(show_last_frac,     false,   false,    false,     false,      false,  true)
    bool eff_show_vol = f_approach_bool(show_vol,           true,    false,    false,     false,      false,  false)
    bool eff_plot_fvg1 = f_approach_bool(plot_fvg1,          false,   false,    false,     false,      true,   false)
    bool eff_plot_fvg2 = f_approach_bool(plot_fvg2,          false,   false,    false,     false,      false,  false)
    string eff_ps_mode = f_approach_str(ps_mode,             "None",  "None",   "None",    "None",     "None", "None")
    bool eff_BB_plot = f_approach_bool(BB_plot,            true,    false,    true,      false,      false,  true)
    bool eff_en_cloud = f_approach_bool(en_cloud,           false,   false,    false,     false,      true,   false)
    bool eff_sig_plot = f_approach_bool(sig_plot,           sig_plot, false,    false,     false,      true,   false)
    string eff_ma1_type = f_approach_str(ma1_type,            ma1_type, "None","None","None","None", ma1_type)
    string eff_ma2_type = f_approach_str(ma2_type,            ma2_type, "None","None","None","None", ma2_type)
    bool eff_plot_div = f_approach_bool(plot_div,           false,   false,    true,      false,      false,  false)
    bool eff_plot_l12_bar = f_approach_bool(plot_l12_bar,       false,   false,    false,     false,      false,  false)
    bool eff_plot_nr_bar = f_approach_bool(plot_nr_bar,        false,   false,    false,     true,       false,  false)
    bool eff_plot_i_bar = f_approach_bool(plot_i_bar,         false,   false,    false,     false,      false,  true)
    bool eff_plot_o_bar = f_approach_bool(plot_o_bar,         false,   false,    false,     false,      false,  false)
    bool eff_plot_s_bar = f_approach_bool(plot_s_bar,         false,   false,    false,     false,      false,  false)
    bool eff_plot_f_bar = f_approach_bool(plot_f_bar,         false,   false,    false,     false,      false,  false)
    bool eff_plot_segments = f_approach_bool(plot_segments,      false,   false,    false,     false,      false,  false)
    bool eff_plot_pivots_h1 = plot_pivots_h1
    bool eff_plot_pivots_h4 = plot_pivots_h4
    bool eff_plot_pivots_d = plot_pivots_d
    bool eff_plot_pivots_w = plot_pivots_w
    bool eff_plot_pivots_m = plot_pivots_m
    bool eff_plot_pivots_3m = plot_pivots_3m
    bool eff_plot_pivots_12m = plot_pivots_12m
    bool eff_london_show = f_approach_bool(london_show,        true,    true,     false,     false,      false,  false)
    bool eff_ny_show = f_approach_bool(ny_show,            true,    true,     false,     false,      false,  false)
    bool eff_tokyo_show = f_approach_bool(tokyo_show,         true,    true,     false,     false,      false,  false)
    bool eff_sydney_show = f_approach_bool(sydney_show,        true,    true,     false,     false,      false,  false)
    bool eff_sess_bg_enable = f_approach_bool(true,               true,    true,     false,     false,      false,  false)
    bool eff_key_levels_enabled = key_levels_enabled
    bool eff_show_pdh = show_pdh
    bool eff_show_pdl = show_pdl
    bool eff_show_pdc = f_approach_bool(show_pdc, true,    true,     true,      false,      false,  true)
    bool eff_show_wopen = show_wopen
    bool eff_show_mopen = f_approach_bool(show_mopen, true,    false,    false,     false,      true,   false)
    bool eff_rvol_enabled = f_approach_bool(rvol_enabled, false,   true,     false,     true,       true,   false)
    bool eff_rvol_points_enabled = f_approach_bool(rvol_points_enabled, false,   true,     false,     true,       true,   false)
    bool eff_vwap_enabled = f_approach_bool(vwap_enabled, true,    false,    true,      false,      true,   true)
    string eff_vwap_anchor = f_approach_str(vwap_anchor, "Session (Daily Reset)", "Session (Daily Reset)", "Session (Daily Reset)", "Session (Daily Reset)", "Weekly", "Session (Daily Reset)")
    string eff_vwap_display_raw = f_approach_str(vwap_display_mode, "Value Zone (Â±1Ïƒ)", "Line only", "Full Bands (B1â€“B3)", "Line only", "Line only", "Value Zone (Â±1Ïƒ)")
    string eff_vwap_display_mode = vwap_bands_enabled ? eff_vwap_display_raw : "Line only"
    bool eff_vwap_line_only = eff_vwap_display_mode == "Line only"
    bool eff_vwap_zone = eff_vwap_display_mode == "Value Zone (Â±1Ïƒ)"
    bool eff_vwap_fullbands = eff_vwap_display_mode == "Full Bands (B1â€“B3)"
    bool eff_vwap_z = f_approach_bool(vwap_z_enabled, false,   false,    true,      false,      false,  true)
    bool eff_or_enabled = f_approach_bool(or_enabled, false,   true,     false,     false,      false,  false)
    bool eff_sq_box_enabled = f_approach_bool(sq_box_enabled, false,   false,    false,     true,       false,  false)
    bool eff_lite_value = lite_value_enable and (lite_value_apply_to == "All Lenses" ? true : lite_value_apply_to == "Custom only" ? approach_id == 0 : (approach_id == 1 or approach_id == 6 or approach_id == 0))
    [eff_fractals_plot, eff_sub_fractals, eff_plot_trendline,
     eff_show_mtf_candles, eff_use_sess_1st, eff_show_last_frac, eff_show_vol, eff_plot_fvg1,
     eff_plot_fvg2, eff_ps_mode, eff_BB_plot, eff_en_cloud, eff_sig_plot,
     eff_ma1_type, eff_ma2_type, eff_plot_div, eff_plot_l12_bar, eff_plot_nr_bar,
     eff_plot_i_bar, eff_plot_o_bar, eff_plot_s_bar, eff_plot_f_bar, eff_plot_segments,
     eff_plot_pivots_h1, eff_plot_pivots_h4, eff_plot_pivots_d, eff_plot_pivots_w, eff_plot_pivots_m,
     eff_plot_pivots_3m, eff_plot_pivots_12m, eff_london_show, eff_ny_show, eff_tokyo_show, eff_sydney_show,
     eff_sess_bg_enable, eff_key_levels_enabled, eff_show_pdh, eff_show_pdl, eff_show_pdc, eff_show_wopen,
     eff_show_mopen, eff_rvol_enabled, eff_rvol_points_enabled, eff_vwap_enabled, eff_vwap_anchor, eff_vwap_line_only,
     eff_vwap_zone, eff_vwap_fullbands, eff_vwap_z, eff_or_enabled, eff_sq_box_enabled, eff_lite_value]

[eff_fractals_plot, eff_sub_fractals, eff_plot_trendline, eff_show_mtf_candles, eff_use_sess_1st, eff_show_last_frac, eff_show_vol, eff_plot_fvg1, eff_plot_fvg2, eff_ps_mode, eff_BB_plot, eff_en_cloud, eff_sig_plot, eff_ma1_type, eff_ma2_type, eff_plot_div, eff_plot_l12_bar, eff_plot_nr_bar, eff_plot_i_bar, eff_plot_o_bar, eff_plot_s_bar, eff_plot_f_bar, eff_plot_segments, eff_plot_pivots_h1, eff_plot_pivots_h4, eff_plot_pivots_d, eff_plot_pivots_w, eff_plot_pivots_m, eff_plot_pivots_3m, eff_plot_pivots_12m, eff_london_show, eff_ny_show, eff_tokyo_show, eff_sydney_show, eff_sess_bg_enable, eff_key_levels_enabled, eff_show_pdh, eff_show_pdl, eff_show_pdc, eff_show_wopen, eff_show_mopen, eff_rvol_enabled, eff_rvol_points_enabled, eff_vwap_enabled, eff_vwap_anchor, eff_vwap_line_only, eff_vwap_zone, eff_vwap_fullbands, eff_vwap_z, eff_or_enabled, eff_sq_box_enabled, eff_lite_value] = f_resolve_effective_flags()

type Cfg
    int cfg_core_ema_len
    int cfg_vol_len
    float cfg_enter_k
    float cfg_exit_k
    int cfg_persist_bars
    float cfg_ov_decay
    float cfg_ov_clamp
    int cfg_adx_th
    bool cfg_use_adr_gate
    float cfg_adr_warn
    float cfg_adr_hard
    int cfg_bb_len
    float cfg_bb_mult
    int cfg_kc_len
    float cfg_kc_mult
    bool cfg_squeeze_strict
    bool cfg_use_kc_squeeze
    bool cfg_fractals_plot
    bool cfg_sub_fractals
    bool cfg_plot_trendline
    bool cfg_show_mtf_candles
    bool cfg_use_sess_1st
    bool cfg_show_last_frac
    bool cfg_show_vol
    bool cfg_plot_fvg1
    bool cfg_plot_fvg2
    string cfg_ps_mode
    bool cfg_BB_plot
    bool cfg_en_cloud
    bool cfg_sig_plot
    string cfg_ma1_type
    string cfg_ma2_type
    bool cfg_plot_div
    bool cfg_plot_l12_bar
    bool cfg_plot_nr_bar
    bool cfg_plot_i_bar
    bool cfg_plot_o_bar
    bool cfg_plot_s_bar
    bool cfg_plot_f_bar
    bool cfg_plot_segments
    bool cfg_plot_pivots_h1
    bool cfg_plot_pivots_h4
    bool cfg_plot_pivots_d
    bool cfg_plot_pivots_w
    bool cfg_plot_pivots_m
    bool cfg_plot_pivots_3m
    bool cfg_plot_pivots_12m
    bool cfg_london_show
    bool cfg_ny_show
    bool cfg_tokyo_show
    bool cfg_sydney_show
    bool cfg_sess_bg_enable
    bool cfg_key_levels_enabled
    bool cfg_show_pdh
    bool cfg_show_pdl
    bool cfg_show_pdc
    bool cfg_show_wopen
    bool cfg_show_mopen
    bool cfg_rvol_enabled
    bool cfg_rvol_points_enabled
    bool cfg_vwap_enabled
    string cfg_vwap_anchor
    bool cfg_vwap_line_only
    bool cfg_vwap_zone
    bool cfg_vwap_fullbands
    bool cfg_vwap_z
    bool cfg_or_enabled
    bool cfg_sq_box_enabled
    bool cfg_lite_value

type Out
    float dummy

type Sig
    bool tl_bull
    bool tl_bear
    bool div_bull
    bool div_bear
    bool ema_bull
    bool ema_bear
    bool ma_bull
    bool ma_bear
    bool seg_bull
    bool seg_bear
    bool l12_bull
    bool l12_bear
    bool pat_bull
    bool pat_bear
    bool o_bull
    bool o_bear
    bool kama_bull
    bool kama_bear
    bool fvg_bull
    bool fvg_bear
    bool vol_spike

f_build_cfg() =>
    Cfg.new(eff_core_ema_len, eff_vol_len, eff_enter_k, eff_exit_k, eff_persist_bars, eff_ov_decay, eff_ov_clamp, eff_adx_th, eff_use_adr_gate, eff_adr_warn, eff_adr_hard, eff_bb_len, eff_bb_mult, eff_kc_len, eff_kc_mult, eff_squeeze_strict, eff_use_kc_squeeze, eff_fractals_plot, eff_sub_fractals, eff_plot_trendline, eff_show_mtf_candles, eff_use_sess_1st, eff_show_last_frac, eff_show_vol, eff_plot_fvg1, eff_plot_fvg2, eff_ps_mode, eff_BB_plot, eff_en_cloud, eff_sig_plot, eff_ma1_type, eff_ma2_type, eff_plot_div, eff_plot_l12_bar, eff_plot_nr_bar, eff_plot_i_bar, eff_plot_o_bar, eff_plot_s_bar, eff_plot_f_bar, eff_plot_segments, eff_plot_pivots_h1, eff_plot_pivots_h4, eff_plot_pivots_d, eff_plot_pivots_w, eff_plot_pivots_m, eff_plot_pivots_3m, eff_plot_pivots_12m, eff_london_show, eff_ny_show, eff_tokyo_show, eff_sydney_show, eff_sess_bg_enable, eff_key_levels_enabled, eff_show_pdh, eff_show_pdl, eff_show_pdc, eff_show_wopen, eff_show_mopen, eff_rvol_enabled, eff_rvol_points_enabled, eff_vwap_enabled, eff_vwap_anchor, eff_vwap_line_only, eff_vwap_zone, eff_vwap_fullbands, eff_vwap_z, eff_or_enabled, eff_sq_box_enabled, eff_lite_value)

Cfg cfg = f_build_cfg()

int active_sec_calls = 0
// Performance Counters (Per Bar)
int ops_trend = 0
int ops_div = 0
int ops_bb = 0

// Peak Trackers
var int peak_ops_trend = 0

var table tbl_dbg = na

ON_FVG1         = eff_plot_fvg1
ON_FVG2         = eff_plot_fvg2
ON_MTF_OV       = eff_show_mtf_candles
ON_SESS_1ST     = eff_use_sess_1st
ON_LAST_FR      = eff_show_last_frac
ON_PS           = eff_ps_mode != "None"

// New Features Flags (Independently Controlled)
// Confluence & Regime are now strictly controlled by their inputs, ignoring Profile Mode
bool eff_show_conf_meter = show_conf_meter
bool eff_regime_panel    = show_regime_panel
bool eff_regime_bg_enabled  = regime_bg_enabled

// ADR/KC Logic (Mapped to Config Stage)
// We map the legacy names to our new effective variables to minimize downstream changes
squeeze_strict      = eff_squeeze_strict

//----------------- Global Signal Registry (For Alerts & Confluence) -----------------
// These variables are reset to false/na on every bar execution
// We populate them inside the respective feature blocks
var Out out = Out.new(na)
var Sig sig = Sig.new(false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false)

f_reset_sig() =>
    sig.tl_bull := false
    sig.tl_bear := false
    sig.div_bull := false
    sig.div_bear := false
    sig.ema_bull := false
    sig.ema_bear := false
    sig.ma_bull := false
    sig.ma_bear := false
    sig.seg_bull := false
    sig.seg_bear := false
    sig.l12_bull := false
    sig.l12_bear := false
    sig.pat_bull := false
    sig.pat_bear := false
    sig.o_bull := false
    sig.o_bear := false
    sig.kama_bull := false
    sig.kama_bear := false
    sig.fvg_bull := false
    sig.fvg_bear := false
    sig.vol_spike := false

f_main(_cfg) =>
    f_reset_sig()

f_main(cfg)


// Helper Functions for Object Reuse (Unified)
f_line_get_or_create(_l, _x1, _y1, _x2, _y2, _col, _style, _xloc=xloc.bar_index) =>
    line ret = _l
    if na(ret)
        ret := line.new(_x1, _y1, _x2, _y2, extend=extend.right, color=_col, style=_style, width=1, xloc=_xloc)
    else
        line.set_xy1(ret, _x1, _y1)
        line.set_xy2(ret, _x2, _y2)
        line.set_color(ret, _col)
        line.set_style(ret, _style)
    ret

f_label_get_or_create(_lb, _x, _y, _txt, _col) =>
    label ret = _lb
    if na(ret)
        ret := label.new(_x, _y, _txt, xloc=xloc.bar_index, yloc=yloc.price, style=label.style_none, textcolor=_col, size=size.small, textalign=text.align_left)
    else
        label.set_xy(ret, _x, _y)
        label.set_text(ret, _txt)
        label.set_textcolor(ret, _col)
    ret


//------------------------------------------------------- Key Levels Module -------------------------------------------------------
// Stage 1: PDH/PDL/PDC + Weekly/Monthly Open (Origin-Anchored)

// 1. Data Fetching (O(1))
float d_h = na, float d_l = na, float d_c = na, int d_start = na, int d_end = na
float w_o = na, int w_start = na
float m_o = na, int m_start = na

if eff_key_levels_enabled
    [t_dh, t_dl, t_dc, t_ds, t_de] = request.security(syminfo.tickerid, "D", [high[1], low[1], close[1], time[1], time], lookahead=barmerge.lookahead_off)
    d_h := t_dh, d_l := t_dl, d_c := t_dc, d_start := t_ds, d_end := t_de

    [t_wo, t_ws] = request.security(syminfo.tickerid, "W", [open, time], lookahead=barmerge.lookahead_on)
    w_o := t_wo, w_start := t_ws

    [t_mo, t_ms] = request.security(syminfo.tickerid, "M", [open, time], lookahead=barmerge.lookahead_on)
    m_o := t_mo, m_start := t_ms

    active_sec_calls += 3

// 2. Scan & State Management
var int idx_pdh = na
var int idx_pdl = na
var int idx_pdc = na

// State to detect new day/week/month
var int last_d_start = 0

// Objects
var line l_pdh = na, var label lb_pdh = na
var line l_pdl = na, var label lb_pdl = na
var line l_pdc = na, var label lb_pdc = na
var line l_wo  = na, var label lb_wo  = na
var line l_mo  = na, var label lb_mo  = na

// Helper for Drawing (Global Scope)
f_draw_kl(_l, _lb, _idx, _val, _txt, _col, _en, _style, _ext) =>
    line ret_l = _l
    label ret_lb = _lb

    if _en and not na(_val) and not na(_idx)
        // Line
        if key_style != "Labels"
            ret_l := f_line_get_or_create(ret_l, _idx, _val, bar_index, _val, _col, _style)
            line.set_extend(ret_l, _ext ? extend.right : extend.none)
        else
            line.delete(ret_l)
            ret_l := na

        // Label
        if key_style != "Lines"
            ret_lb := f_label_get_or_create(ret_lb, bar_index + 5, _val, _txt, _col)
        else
            label.delete(ret_lb)
            ret_lb := na
    else
        line.delete(ret_l)
        label.delete(ret_lb)
        ret_l := na
        ret_lb := na

    [ret_l, ret_lb]

f_draw_kl_time(_l, _lb, _t1, _val, _txt, _col, _en, _style, _ext) =>
    line ret_l = _l
    label ret_lb = _lb

    if _en and not na(_val) and not na(_t1)
        // Line
        if key_style != "Labels"
            ret_l := f_line_get_or_create(ret_l, _t1, _val, time_close, _val, _col, _style, xloc.bar_time)
            line.set_extend(ret_l, _ext ? extend.right : extend.none)
        else
            line.delete(ret_l)
            ret_l := na

        // Label
        if key_style != "Lines"
            ret_lb := f_label_get_or_create(ret_lb, bar_index + 5, _val, _txt, _col)
        else
            label.delete(ret_lb)
            ret_lb := na
    else
        line.delete(ret_l)
        label.delete(ret_lb)
        ret_l := na
        ret_lb := na

    [ret_l, ret_lb]

// Scan Limits
int MAX_SCAN = 3000 // Max bars back

if eff_key_levels_enabled and barstate.islast and bar_index > 100
    // Dynamic Scan Limit (Safe)
    int scan_limit = math.min(MAX_SCAN, bar_index)

    // PDH/PDL/PDC Scan
    if d_start != last_d_start
        idx_pdh := na
        idx_pdl := na
        idx_pdc := na

        float scan_max_h = -1.0e10
        int   scan_max_h_idx = na
        float scan_min_l = 1.0e10
        int   scan_min_l_idx = na

        int   scan_last_idx = na
        int   fallback_idx = na

        if scan_limit >= 1
            for i = 1 to scan_limit
                int t = time[i]
                if t < d_start
                    break

                if t >= d_start
                    fallback_idx := bar_index - i

                if t >= d_start and t < d_end
                    // Track High (>= to find earliest/left-most in backward scan)
                    if high[i] >= scan_max_h
                        scan_max_h := high[i]
                        scan_max_h_idx := bar_index - i

                    // Track Low (<= to find earliest/left-most in backward scan)
                    if low[i] <= scan_min_l
                        scan_min_l := low[i]
                        scan_min_l_idx := bar_index - i

                    // Track Close (first encountered going backwards is the latest/close)
                    if na(scan_last_idx)
                        scan_last_idx := bar_index - i

        int fb_final = not na(fallback_idx) ? fallback_idx : (bar_index - scan_limit)
        idx_pdh := not na(scan_max_h_idx) ? scan_max_h_idx : fb_final
        idx_pdl := not na(scan_min_l_idx) ? scan_min_l_idx : fb_final
        idx_pdc := not na(scan_last_idx) ? scan_last_idx : fb_final
        last_d_start := d_start

    // Drawing
    // Execute Draws
    [t_l_pdh, t_lb_pdh] = f_draw_kl(l_pdh, lb_pdh, idx_pdh, d_h, "PDH", color.new(color.red, 30), eff_show_pdh, line.style_dashed, key_extend)
    l_pdh := t_l_pdh, lb_pdh := t_lb_pdh

    [t_l_pdl, t_lb_pdl] = f_draw_kl(l_pdl, lb_pdl, idx_pdl, d_l, "PDL", color.new(color.green, 30), eff_show_pdl, line.style_dashed, key_extend)
    l_pdl := t_l_pdl, lb_pdl := t_lb_pdl

    [t_l_pdc, t_lb_pdc] = f_draw_kl(l_pdc, lb_pdc, idx_pdc, d_c, "PDC", color.new(color.gray, 30), eff_show_pdc, line.style_dotted, key_extend)
    l_pdc := t_l_pdc, lb_pdc := t_lb_pdc

    [t_l_wo, t_lb_wo] = f_draw_kl_time(l_wo, lb_wo, w_start, w_o, "W.Open", color.new(color.orange, 0), eff_show_wopen, line.style_dashed, key_extend)
    l_wo := t_l_wo, lb_wo := t_lb_wo

    [t_l_mo, t_lb_mo] = f_draw_kl_time(l_mo, lb_mo, m_start, m_o, "M.Open", color.new(color.white, 0), eff_show_mopen, line.style_dashed, key_extend)
    l_mo := t_l_mo, lb_mo := t_lb_mo

else
    // Cleanup if disabled
    line.delete(l_pdh)
    label.delete(lb_pdh)
    line.delete(l_pdl)
    label.delete(lb_pdl)
    line.delete(l_pdc)
    label.delete(lb_pdc)
    line.delete(l_wo)
    label.delete(lb_wo)
    line.delete(l_mo)
    label.delete(lb_mo)

    l_pdh:=na
    lb_pdh:=na
    l_pdl:=na
    lb_pdl:=na
    l_pdc:=na
    lb_pdc:=na
    l_wo:=na
    lb_wo:=na
    l_mo:=na
    lb_mo:=na


//------------------------------------------------------- RVOL Module -------------------------------------------------------
// Stage 2: Standard RVOL

float rvol_val = na
string rvol_state = "0"

if eff_rvol_enabled
    // Standard RVOL
    float v_avg = ta.sma(volume, rvol_len)

    if v_avg > 0
        rvol_val := volume / v_avg

    if not na(rvol_val)
        if rvol_val >= rvol_th_3
            rvol_state := "3"
        else if rvol_val >= rvol_th_2
            rvol_state := "2"
        else if rvol_val >= rvol_th_1
            rvol_state := "1"

// Visuals
bool show_rvol_visuals = eff_rvol_enabled and rvol_display != "None" and rvol_state != "0"
color c_rv = rvol_state == "3" ? color.red : rvol_state == "2" ? color.orange : color.yellow
// Marker only for H/E (State 2 or 3) if enabled
bool show_marker = show_rvol_visuals and (rvol_display == "Marker" or rvol_display == "Both") and eff_rvol_points_enabled and (rvol_state == "3" or rvol_state == "2")

plotshape(show_marker, style=shape.circle, location=location.bottom, color=c_rv, size=size.tiny, title="RVOL Marker")

if show_rvol_visuals and (rvol_display == "Label" or rvol_display == "Both")
    string txt = "RVOL " + str.tostring(rvol_val, "#.#")
    var label lb_rvol = na
    label.delete(lb_rvol)
    lb_rvol := label.new(bar_index, low, txt, yloc=yloc.belowbar, color=c_rv, style=label.style_label_up, textcolor=color.black, size=size.small)


//-------------------------------------------------------- williams fractals (Visuals for Chart) --------------------------------------------------------------

up_fr               = ta.pivothigh(2, 2)
dn_fr               = ta.pivotlow(2, 2)

last_up_fr_level    = ta.valuewhen(up_fr, high[2], 0)
last_dn_fr_level    = ta.valuewhen(dn_fr, low[2], 0)

// Plot fractals
plotshape(eff_fractals_plot ? up_fr : na, style=shape.triangleup, location=location.abovebar, offset=-2, color=color.new(color_fr, transp_fr), title='Fractal up')
plotshape(eff_fractals_plot ? dn_fr : na, style=shape.triangledown, location=location.belowbar, offset=-2, color=color.new(color_fr, transp_fr), title='Fractal down')

// Sub Fractals Logic
// Up Sub Fractals
// Pattern A: Peak at [2] (1 Left, 2 Right). Strict check (left 2nd bar must be higher to NOT be a standard fractal) to avoid overlap.
up_sub_a = high[2] > high[3] and high[2] > high[1] and high[2] > high[0]
up_sub_a_strict = up_sub_a and high[2] <= high[4]

// Pattern B: Peak at [2] (2 Left, 1 Right) - Strict: Must NOT be 2 Right (high[2] <= high[0])
up_sub_b = high[2] > high[4] and high[2] > high[3] and high[2] > high[1] and high[2] <= high[0]

// Down Sub Fractals
// Pattern A: Peak at [2] (1 Left, 2 Right)
dn_sub_a = low[2] < low[3] and low[2] < low[1] and low[2] < low[0]
dn_sub_a_strict = dn_sub_a and low[2] >= low[4]

// Pattern B: Peak at [2] (2 Left, 1 Right) - Strict: Must NOT be 2 Right (low[2] >= low[0])
dn_sub_b = low[2] < low[4] and low[2] < low[3] and low[2] < low[1] and low[2] >= low[0]

// Plot Sub Fractals
col_sub_fr = color.new(color.gray, 30)

plotshape(eff_sub_fractals and up_sub_a_strict ? high[2] : na, style=shape.triangleup, location=location.abovebar, offset=-2, color=col_sub_fr, title='Sub Fractal Up A')
plotshape(eff_sub_fractals and up_sub_b ? high[2] : na, style=shape.triangleup, location=location.abovebar, offset=-2, color=col_sub_fr, title='Sub Fractal Up B')

plotshape(eff_sub_fractals and dn_sub_a_strict ? low[2] : na, style=shape.triangledown, location=location.belowbar, offset=-2, color=col_sub_fr, title='Sub Fractal Down A')
plotshape(eff_sub_fractals and dn_sub_b ? low[2] : na, style=shape.triangledown, location=location.belowbar, offset=-2, color=col_sub_fr, title='Sub Fractal Down B')


//------------------------------------------------------- Pro Smart S&R Logic -----------------------------------------------------

// --- 1. Data Fetching (MTF) ---
// Function to get Raw Pivot Data from HTF
// We need to return specific values when a pivot is confirmed
f_get_mtf_pivots(_src_h, _src_l, _l, _r) =>
    _ph = ta.pivothigh(_src_h, _l, _r)
    _pl = ta.pivotlow(_src_l, _l, _r)

    // Values are confirmed at the close of the bar _r bars after the peak
    // We return the Price and the Time of the peak
    // Note: Pivot High was at offset _r
    _ph_val = not na(_ph) ? _ph : na
    _ph_time = not na(_ph) ? time[_r] : na

    _pl_val = not na(_pl) ? _pl : na
    _pl_time = not na(_pl) ? time[_r] : na

    [_ph_val, _ph_time, _pl_val, _pl_time]

// Helper to calculate Auto Timeframe
f_calc_auto_tf() =>
    timeframe.isseconds ? "30" :
         timeframe.isintraday ? (timeframe.multiplier <= 15 ? "120" : timeframe.multiplier <= 240 ? "D" : "W") :
         timeframe.isdaily ? "W" :
         timeframe.isweekly ? "3M" :
         timeframe.ismonthly ? (timeframe.multiplier <= 3 ? "12M" : "12M") :
         "12M"

// Determine Effective TF
ps_tf_final = eff_ps_mode == "Auto" ? f_calc_auto_tf() : ps_tf

// Security call to get the data from the selected timeframe
float s_ph_val = na
int s_ph_time = na
float s_pl_val = na
int s_pl_time = na

if ON_PS
    [t_ph, t_pht, t_pl, t_plt] = request.security(syminfo.tickerid, ps_tf_final, f_get_mtf_pivots(high, low, ps_left, ps_right))
    s_ph_val := t_ph
    s_ph_time := t_pht
    s_pl_val := t_pl
    s_pl_time := t_plt
    active_sec_calls += 1

// --- 2. State Management (Arrays) ---
var sr_levels = array.new<SRLevel>()
var int last_ph_t = 0
var int last_pl_t = 0

// Helper to check proximity for Merging
f_is_near(_p1, _p2, _pct) =>
    math.abs(_p1 - _p2) <= (_p1 * (_pct / 100))

// Main Logic Loop (Runs on every bar, but updates state only on new pivots or close)
if ON_PS
    // A. Ingest New High Pivot
    if not na(s_ph_val) and s_ph_time != last_ph_t
        last_ph_t := s_ph_time
        // Check for merge candidate (Iterate backwards to find newest nearby)
        bool merged = false
        if ps_merge_en and array.size(sr_levels) > 0
            for i = array.size(sr_levels) - 1 to 0
                SRLevel lvl = array.get(sr_levels, i)
                // Only merge with same type (Resistance) and active lines
                if lvl.is_res and not lvl.is_broken and f_is_near(lvl.price, s_ph_val, ps_merge_pct)
                    // CONVERT TO ZONE
                    if not lvl.is_zone
                        // Create Box
                        float top = math.max(lvl.price, s_ph_val)
                        float bot = math.min(lvl.price, s_ph_val)
                        lvl.id_box := box.new(lvl.start_time, top, time, bot, xloc=xloc.bar_time, border_color=na, bgcolor=ps_col_zone)
                        lvl.is_zone := true
                        // Delete the old line
                        line.delete(lvl.id_line)
                    else
                        // Extend Zone Price Range
                        float cur_top = box.get_top(lvl.id_box)
                        float cur_bot = box.get_bottom(lvl.id_box)
                        box.set_top(lvl.id_box, math.max(cur_top, s_ph_val))
                        box.set_bottom(lvl.id_box, math.min(cur_bot, s_ph_val))

                    array.set(sr_levels, i, lvl)
                    merged := true
                    break

        if not merged
            // Add New Resistance Line
            line new_l = line.new(s_ph_time, s_ph_val, time, s_ph_val, xloc=xloc.bar_time, color=ps_col_res, style=line.style_solid, width=1)
            SRLevel new_lvl = SRLevel.new(s_ph_val, true, false, s_ph_time, new_l, na, false)
            array.push(sr_levels, new_lvl)

    // B. Ingest New Low Pivot
    if not na(s_pl_val) and s_pl_time != last_pl_t
        last_pl_t := s_pl_time
        // Check for merge candidate
        bool merged = false
        if ps_merge_en and array.size(sr_levels) > 0
            for i = array.size(sr_levels) - 1 to 0
                SRLevel lvl = array.get(sr_levels, i)
                if not lvl.is_res and not lvl.is_broken and f_is_near(lvl.price, s_pl_val, ps_merge_pct)
                    // CONVERT TO ZONE
                    if not lvl.is_zone
                        float top = math.max(lvl.price, s_pl_val)
                        float bot = math.min(lvl.price, s_pl_val)
                        lvl.id_box := box.new(lvl.start_time, top, time, bot, xloc=xloc.bar_time, border_color=na, bgcolor=ps_col_zone)
                        lvl.is_zone := true
                        line.delete(lvl.id_line)
                    else
                        float cur_top = box.get_top(lvl.id_box)
                        float cur_bot = box.get_bottom(lvl.id_box)
                        box.set_top(lvl.id_box, math.max(cur_top, s_pl_val))
                        box.set_bottom(lvl.id_box, math.min(cur_bot, s_pl_val))

                    array.set(sr_levels, i, lvl)
                    merged := true
                    break

        if not merged
            line new_l = line.new(s_pl_time, s_pl_val, time, s_pl_val, xloc=xloc.bar_time, color=ps_col_sup, style=line.style_solid, width=1)
            SRLevel new_lvl = SRLevel.new(s_pl_val, false, false, s_pl_time, new_l, na, false)
            array.push(sr_levels, new_lvl)

    // C. Pruning (FIFO)
    while array.size(sr_levels) > ps_max
        // Remove oldest (Index 0)
        SRLevel old = array.shift(sr_levels)
        line.delete(old.id_line)
        box.delete(old.id_box)

    // D. Update & Break Handling (Loop all active levels)
    // We loop backwards to allow safe removal if "Delete" action is selected
    if array.size(sr_levels) > 0
        for i = array.size(sr_levels) - 1 to 0
            SRLevel lvl = array.get(sr_levels, i)

            // 1. Check Break
            // Use current close to detect break.
            // Resistance Broken: Close > Price
            // Support Broken: Close < Price
            // For Zones: Check against Top/Bottom
            bool broken_now = false

            if not lvl.is_broken
                // Stage 6: Getter Caching (Micro-Opt)
                // Cache top/bottom to avoid double calling get_top/get_bottom in expressions
                float zone_top = na
                float zone_bot = na
                if lvl.is_zone
                    zone_top := box.get_top(lvl.id_box)
                    zone_bot := box.get_bottom(lvl.id_box)

                float check_price = lvl.is_zone ? (lvl.is_res ? zone_top : zone_bot) : lvl.price

                if lvl.is_res and close > check_price
                    broken_now := true
                else if not lvl.is_res and close < check_price
                    broken_now := true

            if broken_now
                lvl.is_broken := true
                if ps_break_act == "Delete"
                    line.delete(lvl.id_line)
                    box.delete(lvl.id_box)
                    array.remove(sr_levels, i)
                    continue // Skip to next iteration

                if ps_break_act == "Role Reversal"
                    // Reset broken status for the new role
                    lvl.is_broken := false
                    // Flip Type
                    lvl.is_res := not lvl.is_res
                    // Update Color
                    color new_c = lvl.is_res ? ps_col_res : ps_col_sup
                    if not lvl.is_zone
                        line.set_color(lvl.id_line, new_c)
                        line.set_style(lvl.id_line, line.style_dashed)

            // 2. Extend visual to current time (Stage 6: Micro-Opt)
            if barstate.islast
                if not lvl.is_zone
                    line.set_x2(lvl.id_line, time)
                else
                    box.set_right(lvl.id_box, time)
else
    // Cleanup when disabled
    if array.size(sr_levels) > 0
        for i = 0 to array.size(sr_levels) - 1
            SRLevel lvl = array.get(sr_levels, i)
            line.delete(lvl.id_line)
            box.delete(lvl.id_box)
        array.clear(sr_levels)


//---------------------------------------------------- macd and rsi divergences (Visuals for Chart) -------------------------------------------------------------

// Stage 3: Divergences Hard-Gating
ON_DIV = eff_plot_div

float rsi_d = na
float macdLine = na
float signalLine = na
float histLine = na
float bar_scr_bear = na
float bar_scr_bull = na
float indi_scr = na

bool c_div_bear = false
bool c_div_bull = false
bool h_div_bear = false
bool h_div_bull = false

if ON_DIV
    ops_div += dbg_ops ? 1 : 0 // Count Ops (at least one block execution)

    rsi_d := ta.rsi(close, rsi_length)

    fast_length     = 12
    slow_length     = 26
    signal_length   = 9
    src             = close

    [t_macd, t_sig, t_hist] = ta.macd(src, fast_length, slow_length, signal_length)
    macdLine := t_macd
    signalLine := t_sig
    histLine := t_hist

    bar_scr_bear := src_div == 'close' ? close : high
    bar_scr_bull := src_div == 'close' ? close : low

    indi_scr := div_indi == 'rsi' ? rsi_d : div_indi == 'macd(fast_line)' ? macdLine : div_indi == 'macd(slow_line)' ? signalLine : na

    //rsi and macd divergence calc
    // Check if indi_scr is valid before calculation
    if not na(indi_scr)
        c_div_bear := bar_scr_bear > ta.highest(bar_scr_bear, bar_div_p)[1] and indi_scr < ta.highest(indi_scr, bar_div_p)[1]
        c_div_bull := bar_scr_bull < ta.lowest(bar_scr_bull, bar_div_p)[1] and indi_scr > ta.lowest(indi_scr, bar_div_p)[1]

        h_div_bear := bar_scr_bear < ta.highest(bar_scr_bear, bar_div_p)[1] and indi_scr > ta.highest(indi_scr, bar_div_p)[1]
        h_div_bull := bar_scr_bull > ta.lowest(bar_scr_bull, bar_div_p)[1] and indi_scr < ta.lowest(indi_scr, bar_div_p)[1]


plot_bear_combined = ON_DIV and (c_div_bear or h_div_bear)
plot_bull_combined = ON_DIV and (c_div_bull or h_div_bull)
if ON_DIV
    sig.div_bull := c_div_bull or h_div_bull
    sig.div_bear := c_div_bear or h_div_bear

plotshape(plot_bear_combined, style=shape.arrowdown, location=location.abovebar, offset=0, size= size.small,  textcolor=color.new(color.red, 0),  color=color.new(color.red, 0), title='Bear divergence')
plotshape(plot_bull_combined, style=shape.arrowup, location=location.belowbar, offset=0, size= size.small,  textcolor=color.new(color.green, 0), color=color.new(color.green, 0), title='Bull divergence')


//----------------------------------------------------------------- ema cloud / hma slope / dmi adx (Visuals for Chart) -------------------------------------------------------------------

bool need_cloud_vals = eff_en_cloud
ema1                = need_cloud_vals ? ta.ema(close, ema_inp1) : na
ema2                = need_cloud_vals ? ta.ema(close, ema_inp2) : na

// MA 1 Calculation & Logic
ma1_val = switch eff_ma1_type
    "SMA" => ta.sma(close, ma1_len)
    "EMA" => ta.ema(close, ma1_len)
    => na
// MA 1 Color Logic: Checked=Slope(Lime/Red), Unchecked=Red
ma1_col = ma1_slope_c ? (ma1_val >= ma1_val[1] ? color.lime : color.rgb(255, 20, 20)) : color.green
plot(eff_ma1_type != "None" ? ma1_val : na, color=ma1_col, linewidth=1, title="MA 1")

// MA 2 Calculation & Logic
ma2_val = switch eff_ma2_type
    "SMA" => ta.sma(close, ma2_len)
    "EMA" => ta.ema(close, ma2_len)
    => na
// MA 2 Color Logic: Checked=Slope(Lime/Red), Unchecked=Green
ma2_col = ma2_slope_c ? (ma2_val >= ma2_val[1] ? color.lime : color.rgb(255, 20, 20)) : color.red
plot(eff_ma2_type != "None" ? ma2_val : na, color=ma2_col, linewidth=1, title="MA 2")


ema_buy             = eff_en_cloud ? ema1 > ema2 : na
ema_sell            = eff_en_cloud ? ema1 < ema2 : na

if eff_en_cloud
    sig.ema_bull := ema_buy
    sig.ema_bear := ema_sell

ema1_pl             = plot(eff_en_cloud ? ema1 : na, color=color.new(color.blue, 100), title='EMA 1')
ema2_pl             = plot(eff_en_cloud ? ema2 : na, color=color.new(color.blue, 100), title='EMA 2')

fill(ema1_pl, ema2_pl, color=color.new(eff_sig_plot and not ema_buy[1] ? color_ema_sig_dn : eff_sig_plot and not ema_sell[1] ? color_ema_sig_up : color_ema_c, transp_ema_c))


//----------------------------------------------------------------- KAMA Calculation -------------------------------------------------------------------

// Function for KAMA
f_kama(_src, _len, _fast, _slow) =>
    _change = math.abs(_src - _src[_len])
    _volatility = math.sum(math.abs(_src - _src[1]), _len)
    _er = _volatility != 0 ? _change / _volatility : 0
    _sc = math.pow(_er * (2 / (_fast + 1) - 2 / (_slow + 1)) + 2 / (_slow + 1), 2)
    var float _kama = 0.0
    _kama := na(_kama[1]) ? _src : _kama[1] + _sc * (_src - _kama[1])
    _kama

kama_val = f_kama(close, kama_len, kama_fast, kama_slow)

// KAMA Signals (Slope Mode)
// Rising = Bullish, Falling = Bearish
bool kama_bull = kama_val > kama_val[1]
bool kama_bear = kama_val < kama_val[1]

sig.kama_bull := kama_bull
sig.kama_bear := kama_bear


//------------------------------------------------------------ trend lines (Visuals for Chart) ----------------------------------------------------------------

// Determine logic based on input
use_special_trend = fractalBarsPerSide == 0
// Force 2 (5-bar fractal) for special mode to ensure stability
n_tl = use_special_trend ? 2 : fractalBarsPerSide

// --- Detection using Pivot Functions ---
ph_val = ta.pivothigh(high, n_tl, n_tl)
pl_val = ta.pivotlow(low, n_tl, n_tl)

// --- State Variables (Pivot 0 = Newest, Pivot 1 = Old) ---
var float y0_up = na
var int x0_up = na
var float y1_up = na
var int x1_up = na

if not na(ph_val)
    y1_up := y0_up
    x1_up := x0_up
    y0_up := ph_val
    x0_up := bar_index - n_tl

var float y0_dn = na
var int x0_dn = na
var float y1_dn = na
var int x1_dn = na

if not na(pl_val)
    y1_dn := y0_dn
    x1_dn := x0_dn
    y0_dn := pl_val
    x0_dn := bar_index - n_tl

// --- Optimized Anchored Regression (O(1) Running Sums) ---

// Globale Running Sums for Up-Trend
var float sum_xy_up_run = 0.0
var float sum_x2_up_run = 0.0

// Globale Running Sums for Down-Trend
var float sum_xy_dn_run = 0.0
var float sum_x2_dn_run = 0.0

// Variables to track changes in pivots for reset logic
var int last_x0_up = na
var int last_x0_dn = na

// Drawing Objects
var line upper_line = na
var line lower_line = na

// STAGE 1: HYBRID HARD GATING
// We only run the heavy regression and drawing logic if enabled.
if eff_plot_trendline
    // LOGIC for Up-Trend Regression
    if use_special_trend
        // Check if new pivot detected (x0_up changed)
        if x0_up != last_x0_up
            // Reset sums
            sum_xy_up_run := 0.0
            sum_x2_up_run := 0.0

            // Backfill loop (Only runs once per new pivot, for n_tl bars)
            if not na(x0_up) and not na(y0_up)
                int start_idx = x0_up + 1
                int end_idx = bar_index - 1
                if end_idx >= start_idx
                    // Just loop forward conceptually using offset j from current bar
                    int j_max = bar_index - start_idx
                    for j = 1 to j_max
                        ops_trend += dbg_ops ? 1 : 0 // Count Ops
                        // Calculate terms
                        // Real Index: bar_index - j
                        int dx = (bar_index - j) - x0_up
                        float dy = high[j] - y0_up

                        sum_xy_up_run += (dx * dy)
                        sum_x2_up_run += (float(dx) * float(dx))

            last_x0_up := x0_up

        else
            // Incremental Update (Every bar)
            if not na(x0_up) and not na(y0_up)
                int dx = (bar_index - 1) - x0_up
                if dx > 0
                    float dy = high[1] - y0_up
                    sum_xy_up_run += (dx * dy)
                    sum_x2_up_run += (float(dx) * float(dx))

    // Calculate Slope Up
    slope_up = (use_special_trend and sum_x2_up_run != 0) ? sum_xy_up_run / sum_x2_up_run : na


    // LOGIC for Down-Trend Regression
    if use_special_trend
        if x0_dn != last_x0_dn
            // Reset
            sum_xy_dn_run := 0.0
            sum_x2_dn_run := 0.0
            last_x0_dn := x0_dn

            // Backfill
            if not na(x0_dn) and not na(y0_dn)
                int start_idx = x0_dn + 1
                int end_idx = bar_index - 1
                if end_idx >= start_idx
                    int j_max = bar_index - start_idx
                    for j = 1 to j_max
                        ops_trend += dbg_ops ? 1 : 0 // Count Ops
                        int dx = (bar_index - j) - x0_dn
                        float dy = low[j] - y0_dn
                        sum_xy_dn_run += (dx * dy)
                        sum_x2_dn_run += (float(dx) * float(dx))
        else
            // Incremental
            if not na(x0_dn) and not na(y0_dn)
                int dx = (bar_index - 1) - x0_dn
                if dx > 0
                    float dy = low[1] - y0_dn
                    sum_xy_dn_run += (dx * dy)
                    sum_x2_dn_run += (float(dx) * float(dx))

    // Calculate Slope Down
    slope_dn = (use_special_trend and sum_x2_dn_run != 0) ? sum_xy_dn_run / sum_x2_dn_run : na

    // --- Draw Trendlines ---
    // --- UPPER LINE ---
    // Mode 0: Start=Newest(x0), Slope based calculation
    // Mode >0: Start=Old(x1), End=Newest(x0)

    x1_u = use_special_trend ? x0_up : x1_up
    y1_u = use_special_trend ? y0_up : y1_up

    x2_u = use_special_trend ? bar_index - 1 : x0_up
    // Calculate Y2 based on Slope for Mode 0, or plain value for Mode >0
    float y2_u = na
    if use_special_trend
        if not na(slope_up) and not na(x0_up)
            // y = mx + b -> y2 = slope * distance + start_y
            y2_u := y0_up + slope_up * (x2_u - x0_up)
    else
        y2_u := y0_up

    // Draw
    if not na(x1_u) and not na(x2_u) and x1_u != x2_u and not na(y2_u)
        if na(upper_line)
            upper_line := line.new(x1 = x1_u, y1 = y1_u, x2 = x2_u, y2 = y2_u, extend = extend.right, color = color.new(color_tr, transp_tr), style = line.style_solid, width = width_tr)
        else
            line.set_xy1(upper_line, x1_u, y1_u)
            line.set_xy2(upper_line, x2_u, y2_u)
            line.set_color(upper_line, color.new(color_tr, transp_tr))
            line.set_width(upper_line, width_tr)

    // --- LOWER LINE ---
    x1_d = use_special_trend ? x0_dn : x1_dn
    y1_d = use_special_trend ? y0_dn : y1_dn

    x2_d = use_special_trend ? bar_index - 1 : x0_dn
    float y2_d = na
    if use_special_trend
        if not na(slope_dn) and not na(x0_dn)
            y2_d := y0_dn + slope_dn * (x2_d - x0_dn)
    else
        y2_d := y0_dn

    if not na(x1_d) and not na(x2_d) and x1_d != x2_d and not na(y2_d)
        if na(lower_line)
            lower_line := line.new(x1 = x1_d, y1 = y1_d, x2 = x2_d, y2 = y2_d, extend = extend.right, color = color.new(color_tr, transp_tr), style = line.style_solid, width = width_tr)
        else
            line.set_xy1(lower_line, x1_d, y1_d)
            line.set_xy2(lower_line, x2_d, y2_d)
            line.set_color(lower_line, color.new(color_tr, transp_tr))
            line.set_width(lower_line, width_tr)

    // --- Signal Logic for Registry (Trendlines) ---
    // Calculate current projected level
    float cur_y_up = na
    float cur_y_dn = na

    if use_special_trend
        if not na(slope_up) and not na(x0_up)
            cur_y_up := y0_up + slope_up * (bar_index - x0_up)
        if not na(slope_dn) and not na(x0_dn)
            cur_y_dn := y0_dn + slope_dn * (bar_index - x0_dn)
    else
        // Classic
        if not na(x1_u) and not na(x0_up) and x1_u != x0_up
            m_u = (y0_up - y1_u) / (x0_up - x1_u)
            cur_y_up := y1_u + m_u * (bar_index - x1_u)
        if not na(x1_d) and not na(x0_dn) and x1_d != x0_dn
            m_d = (y0_dn - y1_d) / (x0_dn - x1_d)
            cur_y_dn := y1_d + m_d * (bar_index - x1_d)

    // Update Registry
    if not na(cur_y_up) and close > cur_y_up
        sig.tl_bull := true
    if not na(cur_y_dn) and close < cur_y_dn
        sig.tl_bear := true

else
    // Cleanup & State Reset (Crucial for Resuming)
    if not na(last_x0_up)
        last_x0_up := na
        last_x0_dn := na

    if not na(upper_line)
        line.delete(upper_line)
        upper_line := na
    if not na(lower_line)
        line.delete(lower_line)
        lower_line := na


//----------------------------------------------------------- last 12 bar (Visuals for Chart) ----------------------------------------------------------

l12_long = ta.highest(low, L12_input)
l12_short = ta.lowest(high, L12_input)

var bool long_plotted = na
var bool short_plotted = na

// Determine the actual signal trigger point
plot_l12_long = low == l12_long and (na(short_plotted) or short_plotted)
plot_l12_short = high == l12_short and (na(long_plotted) or long_plotted)

if plot_l12_long
    long_plotted := true
    short_plotted := false

if plot_l12_short
    short_plotted := true
    long_plotted := false

plotchar(eff_plot_l12_bar and plot_l12_long ? l12_long : na, char='L', location=location.belowbar, color=color.new(color.blue, 0), title='L12 long bar')
plotchar(eff_plot_l12_bar and plot_l12_short ? l12_short : na, char='L', location=location.abovebar, color=color.new(color.red, 0), title='L12 short bar')


//----------------------------------------------------------- narrow range bar / anticipated fractal (Visuals for Chart)----------------------------------------------------------

// --- Narrow Range Bar (NR7) ---
p_nr_bar = high - low
bar_1 = high[1] - low[1]
bar_2 = high[2] - low[2]
bar_3 = high[3] - low[3]
bar_4 = high[4] - low[4]
bar_5 = high[5] - low[5]
bar_6 = high[6] - low[6]
bar_7 = high[7] - low[7]

nr_bar = p_nr_bar < bar_1 and p_nr_bar < bar_2 and p_nr_bar < bar_3 and p_nr_bar < bar_4 and p_nr_bar < bar_5 and p_nr_bar < bar_6

plotchar(eff_plot_nr_bar and nr_bar, char='n', location=location.belowbar, color=color.new(color.gray, 0), title='NR bar')


// --- Anticipated Fractal Logic ---
af_up = high > high[1] and high > high[2]
af_dn = low < low[1] and low < low[2]

var int last_af_state = 0

bool plot_blue_a_now = false
bool plot_red_a_now = false


if af_up and (last_af_state == 0 or last_af_state == -1)
    plot_blue_a_now := true
    last_af_state := 1

else if af_dn and (last_af_state == 0 or last_af_state == 1)
    plot_red_a_now := true
    last_af_state := -1


//----------------------------------------------- inside bar / outside bar / sandwich bar / pin bar / fakey ---------------------------------------------

i_bar       = high < high[1] and low > low[1]

o_bar       = high > high[1] and low < low[1]

o_bar_color = close > high[1] ? color.new(color.red, 0) : close < low[1] ? color.new(color.green, 0) :color.new(color.gray, 0)

s_bar       = high[1] < high[2] and low[1] > low[2] and high > high[1] and low < low[1]

f_up_e      = i_bar[1] and low < low[1] and close > open[1] and close > open or i_bar[2] and close[1] < low[2] and close > close[1] and high > high[1] or i_bar[1] and low < low[2] and close > close[1] and close > open or i_bar[2] and close[1] < low[3] and close > open and close > open[1]
f_dn_e      = i_bar[1] and high > high[1] and close < open[1] and close < open or i_bar[2] and close[1] > high[2] and close < close[1] and low < low[1] or i_bar[1] and high > high[2] and close < open and close < close[1] or i_bar[2] and close[1] > high[3] and close < open and close < close[1]


i_bar_1 = high[1] < high[2] and low[1] > low[2]
i_bar_2 = high[2] < high[3] and low[2] > low[3]
i_bar_3 = high[3] < high[4] and low[3] > low[4]
i_bar_4 = high[4] < high[5] and low[4] > low[5]

f_up_b = ((i_bar_1 and low < low[1] and close > high[1]) or (i_bar_2 and low < low[2] and close > high[2]) or (i_bar_3 and low < low[3] and close > high[3]) or (i_bar_4 and low < low[4] and close > high[4]))
f_up = f_up_b and not f_up_b[1]

f_dn_b = ((i_bar_1 and high > high[1] and close < low[1]) or (i_bar_2 and high > high[2] and close < low[2]) or (i_bar_3 and high > high[3] and close < low[3]) or (i_bar_4 and high > high[4] and close < low[4]))
f_dn = f_dn_b and not f_dn_b[1]


plotchar(eff_plot_i_bar ? i_bar : na, char='i', location=location.abovebar, color=color.new(color.gray, 0), title='I bar')
plotchar(eff_plot_o_bar ? o_bar : na, char='o', location=location.abovebar, color=o_bar_color, title='O bar')
plotchar(eff_plot_s_bar ? s_bar : na, char='s', location=location.abovebar, color=color.new(color.silver, 0), offset=-1, title='S bar')

plotchar(eff_plot_f_bar ? f_up and (not f_up[1] or not f_up[2] or not f_up[3]) or f_up_e and not f_up : na, char='F', location=location.belowbar, color=color.new(color.blue, 0), title='F bar up')
plotchar(eff_plot_f_bar ? f_dn and (not f_dn[1] or not f_dn[2] or not f_dn[3]) or f_dn_e and not f_dn : na, char='F', location=location.abovebar, color=color.new(color.red, 0), title='F bar down')

// Registry Updates
if eff_plot_l12_bar
    sig.l12_bull := plot_l12_long
    sig.l12_bear := plot_l12_short

if eff_plot_f_bar
    sig.pat_bull := f_up
    sig.pat_bear := f_dn

if eff_plot_o_bar
    // Green O (Long) -> Bullish
    if o_bar and close < low[1]
        sig.o_bull := true
    // Red O (Short) -> Bearish
    if o_bar and close > high[1]
        sig.o_bear := true


//----------------------------------------------------------------- segments (Visuals for Chart) --------------------------------------------------------------

count1_l                    = 0
count2_l                    = 0
segment_1_stat_l            = false
segment_2_stat_l            = false
segment_3_stat_l            = false

var line segment_low_1_l    = na
var line segment_low_2_l    = na
var line segment_low_3_l    = na

count1_s                    = 0
count2_s                    = 0
segment_1_stat_s            = false
segment_2_stat_s            = false
segment_3_stat_s            = false

var line segment_high_1     = na
var line segment_high_2     = na
var line segment_high_3     = na

// Stage 5: Segments Optimization (Bar Close Only)
// Only run the heavy loops when the bar is confirmed (historical bars or realtime bar close)
if eff_plot_segments and barstate.isconfirmed
    // long segments
    for i = 0 to sb by 1
        count1_l := count1_l + 1
        if low[1] > low[i + 2]
            segment_low_1_l := line.new(x1=bar_index[2 + i], y1=low[2 + i], x2=bar_index[1], y2=low[1], color=color.new(color_seg, transp_seg), width=3)
            segment_1_stat_l := true
            break

    for i = count1_l to sb + count1_l by 1
        count2_l := count2_l + 1
        if low[1 + count1_l] > low[i + 2] and segment_1_stat_l
            segment_low_2_l := line.new(x1=bar_index[2 + i], y1=low[2 + i], x2=bar_index[1 + count1_l], y2=low[1 + count1_l], color=color.new(color_seg, transp_seg), width=2)
            segment_2_stat_l := true
            break

    for i = count2_l to sb + count2_l by 1
        if low[1 + count1_l + count2_l] > low[i + 2 + count1_l] and segment_2_stat_l
            segment_low_3_l := line.new(x1=bar_index[i + 2 + count1_l], y1=low[i + 2 + count1_l], x2=bar_index[1 + count1_l + count2_l], y2=low[1 + count1_l + count2_l], color=color.new(color_seg, transp_seg), width=1)
            segment_3_stat_l := true
            break

    line.delete(segment_low_1_l[1])
    line.delete(segment_low_2_l[1])
    line.delete(segment_low_3_l[1])

    // short segments
    for i = 0 to sb by 1
        count1_s := count1_s + 1
        if high[1] < high[i + 2]
            segment_high_1 := line.new(x1=bar_index[2 + i], y1=high[2 + i], x2=bar_index[1], y2=high[1], color=color.new(color_seg, transp_seg), width=3)
            segment_1_stat_s := true
            break

    for i = count1_s to sb + count1_s by 1
        count2_s := count2_s + 1
        if high[1 + count1_s] < high[i + 2] and segment_1_stat_s
            segment_high_2 := line.new(x1=bar_index[2 + i], y1=high[2 + i], x2=bar_index[1 + count1_s], y2=high[1 + count1_s], color=color.new(color_seg, transp_seg), width=2)
            segment_2_stat_s := true
            break

    for i = count2_s to sb + count2_s by 1
        if high[1 + count1_s + count2_s] < high[i + 2 + count1_s] and segment_2_stat_s
            segment_high_3 := line.new(x1=bar_index[i + 2 + count1_s], y1=high[i + 2 + count1_s], x2=bar_index[1 + count1_s + count2_s], y2=high[1 + count1_s + count2_s], color=color.new(color_seg, transp_seg), width=1)
            segment_3_stat_s := true
            break

    line.delete(segment_high_1[1])
    line.delete(segment_high_2[1])
    line.delete(segment_high_3[1])

    // --- Signal Logic for Registry (Segments) ---
    // Segments Signal:
    // Buy: High > High[1] AND 3 Long Segments Active
    // Sell: Low < Low[1] AND 3 Short Segments Active
    // Note: segment_*_stat_* variables are local to this block.
    // We reuse the logic:

    // We need to re-verify state if not already captured.
    // Actually, segment_3_stat_l is only true if we found 3 segments.
    // Buy Signal: high > high[1] and segment_1_stat_l and segment_2_stat_l and segment_3_stat_l

    if high > high[1] and segment_3_stat_l
        sig.seg_bull := true

    if low < low[1] and segment_3_stat_s
        sig.seg_bear := true


//-------------------------------------------------------------------- info panel -------------------------------------------------------------------------

//indicator funktions for 4h, d, w, m

// Helper function for Panel State
f_panel_state() =>
    // FVG Close State
    var int fvg_state = 1
    bool bull_fvg_cond = low > high[2]
    bool bear_fvg_cond = high < low[2]
    fvg_state := bull_fvg_cond ? 1 : bear_fvg_cond ? -1 : fvg_state
    int fvg_candidate_i = (not barstate.isconfirmed and (bull_fvg_cond or bear_fvg_cond)) ? 1 : 0

    // Bill Williams Fractals State
    // Standard 2,2 fractals
    up_fr = ta.pivothigh(2, 2)
    dn_fr = ta.pivotlow(2, 2)

    last_up_lvl = ta.valuewhen(not na(up_fr), high[2], 0)
    last_dn_lvl = ta.valuewhen(not na(dn_fr), low[2], 0)

    var int fr_state = 1
    // Check breaks
    bool fr_evt_up = ta.crossover(high, last_up_lvl)
    bool fr_evt_dn = ta.crossunder(low, last_dn_lvl)
    fr_state := fr_evt_up ? 1 : fr_evt_dn ? -1 : fr_state

    int tf_conf_i = barstate.isconfirmed ? 1 : 0
    int fr_pending_i = ((fr_evt_up or fr_evt_dn) and not barstate.isconfirmed) ? 1 : 0
    int fvg_last_conf = barstate.isconfirmed ? fvg_state : fvg_state[1]
    int fr_last_conf = barstate.isconfirmed ? fr_state : fr_state[1]

    [fvg_state, fvg_last_conf, fr_state, fr_last_conf, tf_conf_i, fvg_candidate_i, fr_pending_i]

//colors
color_blue_1    = color.new(color.blue, 30)
color_red_1     = color.new(color.red, 30)
color_gray_1    = color.new(color.gray, 100)

//current tf condition for adx, hama and ema
// RECALC for info panel table to ensure it matches current chart regardless of bg signal

//mtf time frames
Intra           = timeframe.isintraday
Intra_D         = timeframe.isintraday or timeframe.isdaily
Intra_D_W       = timeframe.isintraday or timeframe.isdaily or timeframe.isweekly
Intra_D_W_M     = timeframe.isintraday or timeframe.isdaily or timeframe.isweekly or timeframe.ismonthly

// Stage 6: Info Panel Refactoring (Global Current TF + Gated HTF)

// 1. Always Run Current TF (To prevent warm-up issues)
atr14_val             = ta.atr(14)

// Global Current TF Logic (Additions)
// FVG
var int fvg_state_inf = 1
bool bull_fvg_inf = low > high[2]
bool bear_fvg_inf = high < low[2]
if bull_fvg_inf
    fvg_state_inf := 1
else if bear_fvg_inf
    fvg_state_inf := -1
int fvg_candidate_inf = (not barstate.isconfirmed and (bull_fvg_inf or bear_fvg_inf)) ? 1 : 0

// Fractals
up_fr_inf = ta.pivothigh(2, 2)
dn_fr_inf = ta.pivotlow(2, 2)
last_up_lvl_inf = ta.valuewhen(not na(up_fr_inf), high[2], 0)
last_dn_lvl_inf = ta.valuewhen(not na(dn_fr_inf), low[2], 0)
var int fr_state_inf = 1
bool fr_evt_up_inf = ta.crossover(high, last_up_lvl_inf)
bool fr_evt_dn_inf = ta.crossunder(low, last_dn_lvl_inf)
bool bull_struct_break = fr_evt_up_inf and barstate.isconfirmed
bool bear_struct_break = fr_evt_dn_inf and barstate.isconfirmed
if fr_evt_up_inf
    fr_state_inf := 1
else if fr_evt_dn_inf
    fr_state_inf := -1
int fr_pending_inf = ((fr_evt_up_inf or fr_evt_dn_inf) and not barstate.isconfirmed) ? 1 : 0

fvg_color_c     = fvg_state_inf == 1 ? color_blue_1 : fvg_state_inf == -1 ? color_red_1 : color_gray_1
fr_color_c      = fr_state_inf == 1 ? color_blue_1 : fr_state_inf == -1 ? color_red_1 : color_gray_1

// Info Panel Table (Declared global to allow deletion)
var table info_panel = na

// Define Variables for HTF colors (Init to default)
// FVG Colors
color fvg_color_5m  = na
color fvg_color_15m = na
color fvg_color_1h  = na
color fvg_color_4h  = na
color fvg_color_d   = na
color fvg_color_w   = na
color fvg_color_m   = na

// FR Colors
color fr_color_5m  = na
color fr_color_15m = na
color fr_color_1h  = na
color fr_color_4h  = na
color fr_color_d   = na
color fr_color_w   = na
color fr_color_m   = na

// 2. Gated HTF & Table Update
if panel_pos != "None" and barstate.islast // Stage 5: Last-Bar Gating for Security & Logic
    // Optimization: Combine security calls for Info Panel (7 calls)
    // Using global input parameters for all timeframes as requested
    [fvg_5m, fvg_5m_conf, fr_5m, fr_5m_conf, tfconf_5m_i, fvgcand_5m_i, frpend_5m_i] = request.security(syminfo.tickerid, '5',   f_panel_state())
    [fvg_15m, fvg_15m_conf, fr_15m, fr_15m_conf, tfconf_15m_i, fvgcand_15m_i, frpend_15m_i] = request.security(syminfo.tickerid, '15',  f_panel_state())
    [fvg_1h, fvg_1h_conf, fr_1h, fr_1h_conf, tfconf_1h_i, fvgcand_1h_i, frpend_1h_i] = request.security(syminfo.tickerid, '60',  f_panel_state())
    [fvg_4h, fvg_4h_conf, fr_4h, fr_4h_conf, tfconf_4h_i, fvgcand_4h_i, frpend_4h_i] = request.security(syminfo.tickerid, '240', f_panel_state())
    [fvg_d, fvg_d_conf, fr_d, fr_d_conf, tfconf_d_i, fvgcand_d_i, frpend_d_i]     = request.security(syminfo.tickerid, 'D',   f_panel_state())
    [fvg_w, fvg_w_conf, fr_w, fr_w_conf, tfconf_w_i, fvgcand_w_i, frpend_w_i]     = request.security(syminfo.tickerid, 'W',   f_panel_state())
    [fvg_m, fvg_m_conf, fr_m, fr_m_conf, tfconf_m_i, fvgcand_m_i, frpend_m_i]     = request.security(syminfo.tickerid, 'M',   f_panel_state())

    // Stage 6: Debug Instrument
    active_sec_calls += 7

    int ctf_conf_i = (barstate.isconfirmed or not barstate.isrealtime) ? 1 : 0
    bool ctf_conf = ctf_conf_i == 1
    int fvg_c_conf = ctf_conf ? fvg_state_inf : fvg_state_inf[1]
    int fr_c_conf = ctf_conf ? fr_state_inf : fr_state_inf[1]

    string m_fvg_5m = panel_show_live ? (fvgcand_5m_i == 1 ? M_FORM : M_CONF) : M_CONF
    string m_fvg_15m = panel_show_live ? (fvgcand_15m_i == 1 ? M_FORM : M_CONF) : M_CONF
    string m_fvg_1h = panel_show_live ? (fvgcand_1h_i == 1 ? M_FORM : M_CONF) : M_CONF
    string m_fvg_4h = panel_show_live ? (fvgcand_4h_i == 1 ? M_FORM : M_CONF) : M_CONF
    string m_fvg_d = panel_show_live ? (fvgcand_d_i == 1 ? M_FORM : M_CONF) : M_CONF
    string m_fvg_w = panel_show_live ? (fvgcand_w_i == 1 ? M_FORM : M_CONF) : M_CONF
    string m_fvg_m = panel_show_live ? (fvgcand_m_i == 1 ? M_FORM : M_CONF) : M_CONF
    string m_fvg_c = panel_show_live ? (fvg_candidate_inf == 1 ? M_FORM : M_CONF) : M_CONF

    string m_fr_5m = panel_show_live ? (frpend_5m_i == 1 ? M_FORM : M_CONF) : M_CONF
    string m_fr_15m = panel_show_live ? (frpend_15m_i == 1 ? M_FORM : M_CONF) : M_CONF
    string m_fr_1h = panel_show_live ? (frpend_1h_i == 1 ? M_FORM : M_CONF) : M_CONF
    string m_fr_4h = panel_show_live ? (frpend_4h_i == 1 ? M_FORM : M_CONF) : M_CONF
    string m_fr_d = panel_show_live ? (frpend_d_i == 1 ? M_FORM : M_CONF) : M_CONF
    string m_fr_w = panel_show_live ? (frpend_w_i == 1 ? M_FORM : M_CONF) : M_CONF
    string m_fr_m = panel_show_live ? (frpend_m_i == 1 ? M_FORM : M_CONF) : M_CONF
    string m_fr_c = panel_show_live ? (fr_pending_inf == 1 ? M_FORM : M_CONF) : M_CONF

    int fvg_disp_5m = panel_show_live ? fvg_5m : fvg_5m_conf
    int fr_disp_5m = panel_show_live ? fr_5m : fr_5m_conf
    int fvg_disp_15m = panel_show_live ? fvg_15m : fvg_15m_conf
    int fr_disp_15m = panel_show_live ? fr_15m : fr_15m_conf
    int fvg_disp_1h = panel_show_live ? fvg_1h : fvg_1h_conf
    int fr_disp_1h = panel_show_live ? fr_1h : fr_1h_conf
    int fvg_disp_4h = panel_show_live ? fvg_4h : fvg_4h_conf
    int fr_disp_4h = panel_show_live ? fr_4h : fr_4h_conf
    int fvg_disp_d = panel_show_live ? fvg_d : fvg_d_conf
    int fr_disp_d = panel_show_live ? fr_d : fr_d_conf
    int fvg_disp_w = panel_show_live ? fvg_w : fvg_w_conf
    int fr_disp_w = panel_show_live ? fr_w : fr_w_conf
    int fvg_disp_m = panel_show_live ? fvg_m : fvg_m_conf
    int fr_disp_m = panel_show_live ? fr_m : fr_m_conf
    int fvg_disp_c = panel_show_live ? fvg_state_inf : fvg_c_conf
    int fr_disp_c = panel_show_live ? fr_state_inf : fr_c_conf

    // --- Color Logic ---
    // FVG
    fvg_color_5m  := fvg_disp_5m == 1 ? color_blue_1 : fvg_disp_5m == -1 ? color_red_1 : color_gray_1
    fvg_color_15m := fvg_disp_15m == 1 ? color_blue_1 : fvg_disp_15m == -1 ? color_red_1 : color_gray_1
    fvg_color_1h  := fvg_disp_1h == 1 ? color_blue_1 : fvg_disp_1h == -1 ? color_red_1 : color_gray_1
    fvg_color_4h  := fvg_disp_4h == 1 ? color_blue_1 : fvg_disp_4h == -1 ? color_red_1 : color_gray_1
    fvg_color_d   := fvg_disp_d == 1 ? color_blue_1 : fvg_disp_d == -1 ? color_red_1 : color_gray_1
    fvg_color_w   := fvg_disp_w == 1 ? color_blue_1 : fvg_disp_w == -1 ? color_red_1 : color_gray_1
    fvg_color_m   := fvg_disp_m == 1 ? color_blue_1 : fvg_disp_m == -1 ? color_red_1 : color_gray_1

    // FR (Fractals)
    fr_color_5m   := fr_disp_5m == 1 ? color_blue_1 : fr_disp_5m == -1 ? color_red_1 : color_gray_1
    fr_color_15m  := fr_disp_15m == 1 ? color_blue_1 : fr_disp_15m == -1 ? color_red_1 : color_gray_1
    fr_color_1h   := fr_disp_1h == 1 ? color_blue_1 : fr_disp_1h == -1 ? color_red_1 : color_gray_1
    fr_color_4h   := fr_disp_4h == 1 ? color_blue_1 : fr_disp_4h == -1 ? color_red_1 : color_gray_1
    fr_color_d    := fr_disp_d == 1 ? color_blue_1 : fr_disp_d == -1 ? color_red_1 : color_gray_1
    fr_color_w    := fr_disp_w == 1 ? color_blue_1 : fr_disp_w == -1 ? color_red_1 : color_gray_1
    fr_color_m    := fr_disp_m == 1 ? color_blue_1 : fr_disp_m == -1 ? color_red_1 : color_gray_1
    fvg_color_c   := fvg_disp_c == 1 ? color_blue_1 : fvg_disp_c == -1 ? color_red_1 : color_gray_1
    fr_color_c    := fr_disp_c == 1 ? color_blue_1 : fr_disp_c == -1 ? color_red_1 : color_gray_1

    // Stage 7: TF Highlight Logic (Optimized with var)
    var color col_tf_highlight = color.new(color.yellow, 75)
    var int cur_sec = timeframe.in_seconds(timeframe.period)

    // Exact matches (Cached)
    var bool is_5m  = cur_sec == timeframe.in_seconds("5")
    var bool is_15m = cur_sec == timeframe.in_seconds("15")
    var bool is_1h  = cur_sec == timeframe.in_seconds("60")
    var bool is_4h  = cur_sec == timeframe.in_seconds("240")
    var bool is_1d  = cur_sec == timeframe.in_seconds("D")
    var bool is_1w  = cur_sec == timeframe.in_seconds("W")
    var bool is_1m  = cur_sec == timeframe.in_seconds("M")

    // If none match, highlight "Current"
    var bool is_custom_tf = not (is_5m or is_15m or is_1h or is_4h or is_1d or is_1w or is_1m)

    string pos_input = panel_pos == "Top Right" ? position.top_right : panel_pos == "Bottom Right" ? position.bottom_right : position.bottom_left
    info_panel := na(info_panel) ? table.new(position = pos_input, columns = PANEL_COLS, rows = PANEL_ROWS, bgcolor=color.new(color.blue, 95), frame_width=1, border_width=1, frame_color=color.new(color.black, 50), border_color=color.new(color.black, 50)) : info_panel

    // HEADER NAMES (Row 0)
    table.cell(table_id=info_panel, column=0, row=f_panel_row(0), text="TF", text_size= size.small, text_color=color.silver)
    table.cell(table_id=info_panel, column=1, row=f_panel_row(0), text= "FVGâ €", text_size= size.small, text_color=color.silver)
    table.cell(table_id=info_panel, column=2, row=f_panel_row(0), text= "FR", text_size= size.small, text_color=color.silver)

    // 1M (Row 1)
    table.cell(table_id=info_panel, column=0, row=f_panel_row(1), text="1M", text_size= size.small, text_color=color.silver, bgcolor=is_1m ? col_tf_highlight : na)
    table.cell(table_id=info_panel, column=1, row=f_panel_row(1), text=m_fvg_m, text_size=marker_size_grid, text_color=MARKER_COLOR, bgcolor=(Intra_D_W_M) ? fvg_color_m : na)
    table.cell(table_id=info_panel, column=2, row=f_panel_row(1), text=m_fr_m, text_size=marker_size_grid, text_color=MARKER_COLOR, bgcolor=(Intra_D_W_M) ? fr_color_m : na)

    // 1W (Row 2)
    table.cell(table_id=info_panel, column=0, row=f_panel_row(2), text="1W", text_size= size.small, text_color=color.silver, bgcolor=is_1w ? col_tf_highlight : na)
    table.cell(table_id=info_panel, column=1, row=f_panel_row(2), text=m_fvg_w, text_size=marker_size_grid, text_color=MARKER_COLOR, bgcolor=(Intra_D_W) ? fvg_color_w : na)
    table.cell(table_id=info_panel, column=2, row=f_panel_row(2), text=m_fr_w, text_size=marker_size_grid, text_color=MARKER_COLOR, bgcolor=(Intra_D_W) ? fr_color_w : na)

    // 1D (Row 3)
    table.cell(table_id=info_panel, column=0, row=f_panel_row(3), text="1D", text_size= size.small, text_color=color.silver, bgcolor=is_1d ? col_tf_highlight : na)
    table.cell(table_id=info_panel, column=1, row=f_panel_row(3), text=m_fvg_d, text_size=marker_size_grid, text_color=MARKER_COLOR, bgcolor=(Intra_D) ? fvg_color_d : na)
    table.cell(table_id=info_panel, column=2, row=f_panel_row(3), text=m_fr_d, text_size=marker_size_grid, text_color=MARKER_COLOR, bgcolor=(Intra_D) ? fr_color_d : na)

    // 4H (Row 4)
    table.cell(table_id=info_panel, column=0, row=f_panel_row(4), text="4H", text_size= size.small, text_color=color.silver, bgcolor=is_4h ? col_tf_highlight : na)
    table.cell(table_id=info_panel, column=1, row=f_panel_row(4), text=m_fvg_4h, text_size=marker_size_grid, text_color=MARKER_COLOR, bgcolor=Intra ? fvg_color_4h : na)
    table.cell(table_id=info_panel, column=2, row=f_panel_row(4), text=m_fr_4h, text_size=marker_size_grid, text_color=MARKER_COLOR, bgcolor=Intra ? fr_color_4h : na)

    // 1H (Row 5)
    table.cell(table_id=info_panel, column=0, row=f_panel_row(5), text="1H", text_size= size.small, text_color=color.silver, bgcolor=is_1h ? col_tf_highlight : na)
    table.cell(table_id=info_panel, column=1, row=f_panel_row(5), text=m_fvg_1h, text_size=marker_size_grid, text_color=MARKER_COLOR, bgcolor=Intra ? fvg_color_1h : na)
    table.cell(table_id=info_panel, column=2, row=f_panel_row(5), text=m_fr_1h, text_size=marker_size_grid, text_color=MARKER_COLOR, bgcolor=Intra ? fr_color_1h : na)

    // 15m (Row 6)
    table.cell(table_id=info_panel, column=0, row=f_panel_row(6), text="15m", text_size= size.small, text_color=color.silver, bgcolor=is_15m ? col_tf_highlight : na)
    table.cell(table_id=info_panel, column=1, row=f_panel_row(6), text=m_fvg_15m, text_size=marker_size_grid, text_color=MARKER_COLOR, bgcolor=Intra ? fvg_color_15m : na)
    table.cell(table_id=info_panel, column=2, row=f_panel_row(6), text=m_fr_15m, text_size=marker_size_grid, text_color=MARKER_COLOR, bgcolor=Intra ? fr_color_15m : na)

    // 5m (Row 7)
    table.cell(table_id=info_panel, column=0, row=f_panel_row(7), text="5m", text_size= size.small, text_color=color.silver, bgcolor=is_5m ? col_tf_highlight : na)
    table.cell(table_id=info_panel, column=1, row=f_panel_row(7), text=m_fvg_5m, text_size=marker_size_grid, text_color=MARKER_COLOR, bgcolor=Intra ? fvg_color_5m : na)
    table.cell(table_id=info_panel, column=2, row=f_panel_row(7), text=m_fr_5m, text_size=marker_size_grid, text_color=MARKER_COLOR, bgcolor=Intra ? fr_color_5m : na)
    // ATR14 (Row 8)
    table.merge_cells(info_panel, 0, f_panel_row(8), 2, f_panel_row(8))
    table.cell(table_id=info_panel, column=0, row=f_panel_row(8), text="ATR14 " + str.tostring(atr14_val, "#.#####"), text_size=size.small, text_color=color.silver)

    // ADR% (Row 9) - Initial Placeholder (Filled later)
    table.merge_cells(info_panel, 0, f_panel_row(9), 2, f_panel_row(9))
    table.cell(table_id=info_panel, column=0, row=f_panel_row(9), text="ADR%", text_size=size.small, text_color=color.silver)

    // HEADER (Row 10: Current)
    table.cell(table_id=info_panel, column=0, row=f_panel_row(10), text="C", text_size= size.small, text_color=color.silver, bgcolor=is_custom_tf ? col_tf_highlight : na)
    table.cell(table_id=info_panel, column=1, row=f_panel_row(10), text=m_fvg_c, text_size=marker_size_grid, text_color=MARKER_COLOR, bgcolor=(Intra_D_W_M) ? fvg_color_c : na)
    table.cell(table_id=info_panel, column=2, row=f_panel_row(10), text=m_fr_c, text_size=marker_size_grid, text_color=MARKER_COLOR, bgcolor=(Intra_D_W_M) ? fr_color_c : na)
else
    if not na(info_panel)
        table.delete(info_panel)
        info_panel := na


// ----------------------------------------------------------- pivot points -----------------------------------------------------------------

// Optimized data fetch (tuples) to avoid hitting the 40-call security limit.
// Fetch High/Low/Close in ONE request per timeframe instead of three.

// Stage 1: Pivot Points Optimization
// Strict Gating: request.security only if input is active AND timeframe is valid

// Conditions (Visibility)
cond_h1 = timeframe.isintraday and timeframe.multiplier < 60
cond_h4 = timeframe.isintraday and timeframe.multiplier < 240


// Need Flags
need_h1 = eff_plot_pivots_h1 and cond_h1
need_h4 = eff_plot_pivots_h4 and cond_h4
need_d  = eff_plot_pivots_d  and Intra
need_w  = eff_plot_pivots_w  and Intra_D
need_m  = eff_plot_pivots_m  and Intra_D_W
need_3m = eff_plot_pivots_3m and Intra_D_W_M
need_12m= eff_plot_pivots_12m and Intra_D_W_M

// Data Variables (Initial NA)
float h1_high = na
float h1_low = na
float h1_close = na

float h4_high = na
float h4_low = na
float h4_close = na

float d_high = na
float d_low = na
float d_close = na

float w_high = na
float w_low = na
float w_close = na

float m_high = na
float m_low = na
float m_close = na

float m3_high = na
float m3_low = na
float m3_close = na

float m12_high = na
float m12_low = na
float m12_close = na

// Gated Security Calls - Stage 5: Last Bar Optimization
if barstate.islast
    if need_h1
        [t_h1, t_l1, t_c1] = request.security(syminfo.tickerid, "60", [high[1], low[1], close[1]])
        h1_high := t_h1
        h1_low := t_l1
        h1_close := t_c1
        active_sec_calls += 1

    if need_h4
        [t_h4, t_l4, t_c4] = request.security(syminfo.tickerid, "240", [high[1], low[1], close[1]])
        h4_high := t_h4
        h4_low := t_l4
        h4_close := t_c4
        active_sec_calls += 1

    if need_d
        [t_hd, t_ld, t_cd] = request.security(syminfo.tickerid, "D", [high[1], low[1], close[1]])
        d_high := t_hd
        d_low := t_ld
        d_close := t_cd
        active_sec_calls += 1

    if need_w
        [t_hw, t_lw, t_cw] = request.security(syminfo.tickerid, "W", [high[1], low[1], close[1]])
        w_high := t_hw
        w_low := t_lw
        w_close := t_cw
        active_sec_calls += 1

    if need_m
        [t_hm, t_lm, t_cm] = request.security(syminfo.tickerid, "M", [high[1], low[1], close[1]])
        m_high := t_hm
        m_low := t_lm
        m_close := t_cm
        active_sec_calls += 1

    if need_3m
        [t_h3m, t_l3m, t_c3m] = request.security(syminfo.tickerid, "3M", [high[1], low[1], close[1]])
        m3_high := t_h3m
        m3_low := t_l3m
        m3_close := t_c3m
        active_sec_calls += 1

    if need_12m
        [t_h12m, t_l12m, t_c12m] = request.security(syminfo.tickerid, "12M", [high[1], low[1], close[1]])
        m12_high := t_h12m
        m12_low := t_l12m
        m12_close := t_c12m
        active_sec_calls += 1

// --- Calculations ---

f_calc_classic_pivots(_h, _l, _c) =>
    if na(_h) or na(_l) or na(_c)
        [na, na, na, na, na, na, na, na, na]
    else
        float pp = (_h + _l + _c) / 3.0
        float r1 = 2.0 * pp - _l
        float r2 = pp + (_h - _l)
        float r3 = _h + 2.0 * (pp - _l)
        float r4 = pp + 3.0 * (_h - _l)
        float s1 = 2.0 * pp - _h
        float s2 = pp - (_h - _l)
        float s3 = _l - 2.0 * (_h - pp)
        float s4 = pp - 3.0 * (_h - _l)
        [pp, r1, r2, r3, r4, s1, s2, s3, s4]

// Classic pivots per timeframe (PP, R1-R4, S1-S4)
[h1_PP, h1_R1, h1_R2, h1_R3, h1_R4, h1_S1, h1_S2, h1_S3, h1_S4] = f_calc_classic_pivots(h1_high, h1_low, h1_close)
[h4_PP, h4_R1, h4_R2, h4_R3, h4_R4, h4_S1, h4_S2, h4_S3, h4_S4] = f_calc_classic_pivots(h4_high, h4_low, h4_close)
[d_PP, d_R1, d_R2, d_R3, d_R4, d_S1, d_S2, d_S3, d_S4] = f_calc_classic_pivots(d_high, d_low, d_close)
[w_PP, w_R1, w_R2, w_R3, w_R4, w_S1, w_S2, w_S3, w_S4] = f_calc_classic_pivots(w_high, w_low, w_close)
[m_PP, m_R1, m_R2, m_R3, m_R4, m_S1, m_S2, m_S3, m_S4] = f_calc_classic_pivots(m_high, m_low, m_close)
[m3_PP, m3_R1, m3_R2, m3_R3, m3_R4, m3_S1, m3_S2, m3_S3, m3_S4] = f_calc_classic_pivots(m3_high, m3_low, m3_close)
[m12_PP, m12_R1, m12_R2, m12_R3, m12_R4, m12_S1, m12_S2, m12_S3, m12_S4] = f_calc_classic_pivots(m12_high, m12_low, m12_close)

// --- ALL PIVOTS AS LINES (Visual Update) ---

// 1. Definition of line variables
var line l_h1_pp = na, var line l_h1_r1 = na, var line l_h1_r2 = na, var line l_h1_r3 = na, var line l_h1_r4 = na, var line l_h1_s1 = na, var line l_h1_s2 = na, var line l_h1_s3 = na, var line l_h1_s4 = na
var label lb_h1_pp = na, var label lb_h1_r1 = na, var label lb_h1_r2 = na, var label lb_h1_r3 = na, var label lb_h1_r4 = na, var label lb_h1_s1 = na, var label lb_h1_s2 = na, var label lb_h1_s3 = na, var label lb_h1_s4 = na

var line l_h4_pp = na, var line l_h4_r1 = na, var line l_h4_r2 = na, var line l_h4_r3 = na, var line l_h4_r4 = na, var line l_h4_s1 = na, var line l_h4_s2 = na, var line l_h4_s3 = na, var line l_h4_s4 = na
var label lb_h4_pp = na, var label lb_h4_r1 = na, var label lb_h4_r2 = na, var label lb_h4_r3 = na, var label lb_h4_r4 = na, var label lb_h4_s1 = na, var label lb_h4_s2 = na, var label lb_h4_s3 = na, var label lb_h4_s4 = na

var line l_d_pp = na, var line l_d_r1 = na, var line l_d_r2 = na, var line l_d_r3 = na, var line l_d_r4 = na, var line l_d_s1 = na, var line l_d_s2 = na, var line l_d_s3 = na, var line l_d_s4 = na
var label lb_d_pp = na, var label lb_d_r1 = na, var label lb_d_r2 = na, var label lb_d_r3 = na, var label lb_d_r4 = na, var label lb_d_s1 = na, var label lb_d_s2 = na, var label lb_d_s3 = na, var label lb_d_s4 = na

var line l_w_pp = na, var line l_w_r1 = na, var line l_w_r2 = na, var line l_w_r3 = na, var line l_w_r4 = na, var line l_w_s1 = na, var line l_w_s2 = na, var line l_w_s3 = na, var line l_w_s4 = na
var label lb_w_pp = na, var label lb_w_r1 = na, var label lb_w_r2 = na, var label lb_w_r3 = na, var label lb_w_r4 = na, var label lb_w_s1 = na, var label lb_w_s2 = na, var label lb_w_s3 = na, var label lb_w_s4 = na

var line l_m_pp = na, var line l_m_r1 = na, var line l_m_r2 = na, var line l_m_r3 = na, var line l_m_r4 = na, var line l_m_s1 = na, var line l_m_s2 = na, var line l_m_s3 = na, var line l_m_s4 = na
var label lb_m_pp = na, var label lb_m_r1 = na, var label lb_m_r2 = na, var label lb_m_r3 = na, var label lb_m_r4 = na, var label lb_m_s1 = na, var label lb_m_s2 = na, var label lb_m_s3 = na, var label lb_m_s4 = na

var line l_3m_pp = na, var line l_3m_r1 = na, var line l_3m_r2 = na, var line l_3m_r3 = na, var line l_3m_r4 = na, var line l_3m_s1 = na, var line l_3m_s2 = na, var line l_3m_s3 = na, var line l_3m_s4 = na
var label lb_3m_pp = na, var label lb_3m_r1 = na, var label lb_3m_r2 = na, var label lb_3m_r3 = na, var label lb_3m_r4 = na, var label lb_3m_s1 = na, var label lb_3m_s2 = na, var label lb_3m_s3 = na, var label lb_3m_s4 = na

var line l_12m_pp = na, var line l_12m_r1 = na, var line l_12m_r2 = na, var line l_12m_r3 = na, var line l_12m_r4 = na, var line l_12m_s1 = na, var line l_12m_s2 = na, var line l_12m_s3 = na, var line l_12m_s4 = na
var label lb_12m_pp = na, var label lb_12m_r1 = na, var label lb_12m_r2 = na, var label lb_12m_r3 = na, var label lb_12m_r4 = na, var label lb_12m_s1 = na, var label lb_12m_s2 = na, var label lb_12m_s3 = na, var label lb_12m_s4 = na

// 2. Drawing function
f_draw_pivot(_line, _val, _col, _width, _offset_start, _show_cond, _input_active) =>
    line ret_line = _line
    if barstate.islast and _input_active and _show_cond and not na(_val)
        if na(ret_line)
            ret_line := line.new(bar_index + _offset_start, _val, bar_index + _offset_start + 1, _val, color=_col, width=_width)
        else
            line.set_xy1(ret_line, bar_index + _offset_start, _val)
            line.set_xy2(ret_line, bar_index + _offset_start + 1, _val)
            line.set_color(ret_line, _col)
            line.set_width(ret_line, _width)
    else
        if not na(ret_line)
            line.delete(ret_line)
            ret_line := na
    ret_line

f_draw_pivot_tag(_lb, _val, _txt, _col, _offset_start, _show_cond, _input_active) =>
    label ret_lb = _lb
    bool show = barstate.islast and plot_pivot_labels and _input_active and _show_cond and not na(_val)
    if show
        int x_tag = bar_index + _offset_start + 1
        float y = _val
        if na(ret_lb)
            ret_lb := label.new(x=x_tag, y=y, text=_txt, xloc=xloc.bar_index, yloc=yloc.price, style=label.style_none, textcolor=_col, size=size.tiny, textalign=text.align_right)
        else
            label.set_xy(ret_lb, x_tag, y)
            label.set_text(ret_lb, _txt)
            label.set_textcolor(ret_lb, _col)
            label.set_style(ret_lb, label.style_none)
    else
        if not na(ret_lb)
            label.delete(ret_lb)
            ret_lb := na
    ret_lb
color PIV_COL_P = color.yellow
color PIV_COL_R = color.green
color PIV_COL_S = color.red

// 3. Execution (Drawing)

// Visibility conditions

// 1H: Offset 1, Width 1 (Analog zu Daily)
l_h1_pp := f_draw_pivot(l_h1_pp, h1_PP, PIV_COL_P, 1, 1, cond_h1, plot_pivots_h1)
lb_h1_pp := f_draw_pivot_tag(lb_h1_pp, h1_PP, "P H1", PIV_COL_P, 1, cond_h1, plot_pivots_h1)
l_h1_r1 := f_draw_pivot(l_h1_r1, h1_R1, PIV_COL_R, 1, 1, cond_h1, plot_pivots_h1)
lb_h1_r1 := f_draw_pivot_tag(lb_h1_r1, h1_R1, "R1 H1", PIV_COL_R, 1, cond_h1, plot_pivots_h1)
l_h1_r2 := f_draw_pivot(l_h1_r2, h1_R2, PIV_COL_R, 1, 1, cond_h1, plot_pivots_h1)
lb_h1_r2 := f_draw_pivot_tag(lb_h1_r2, h1_R2, "R2 H1", PIV_COL_R, 1, cond_h1, plot_pivots_h1)
l_h1_r3 := f_draw_pivot(l_h1_r3, h1_R3, PIV_COL_R, 1, 1, cond_h1, plot_pivots_h1)
lb_h1_r3 := f_draw_pivot_tag(lb_h1_r3, h1_R3, "R3 H1", PIV_COL_R, 1, cond_h1, plot_pivots_h1)
l_h1_r4 := f_draw_pivot(l_h1_r4, h1_R4, PIV_COL_R, 1, 1, cond_h1, plot_pivots_h1)
lb_h1_r4 := f_draw_pivot_tag(lb_h1_r4, h1_R4, "R4 H1", PIV_COL_R, 1, cond_h1, plot_pivots_h1)
l_h1_s1 := f_draw_pivot(l_h1_s1, h1_S1, PIV_COL_S, 1, 1, cond_h1, plot_pivots_h1)
lb_h1_s1 := f_draw_pivot_tag(lb_h1_s1, h1_S1, "S1 H1", PIV_COL_S, 1, cond_h1, plot_pivots_h1)
l_h1_s2 := f_draw_pivot(l_h1_s2, h1_S2, PIV_COL_S, 1, 1, cond_h1, plot_pivots_h1)
lb_h1_s2 := f_draw_pivot_tag(lb_h1_s2, h1_S2, "S2 H1", PIV_COL_S, 1, cond_h1, plot_pivots_h1)
l_h1_s3 := f_draw_pivot(l_h1_s3, h1_S3, PIV_COL_S, 1, 1, cond_h1, plot_pivots_h1)
lb_h1_s3 := f_draw_pivot_tag(lb_h1_s3, h1_S3, "S3 H1", PIV_COL_S, 1, cond_h1, plot_pivots_h1)
l_h1_s4 := f_draw_pivot(l_h1_s4, h1_S4, PIV_COL_S, 1, 1, cond_h1, plot_pivots_h1)
lb_h1_s4 := f_draw_pivot_tag(lb_h1_s4, h1_S4, "S4 H1", PIV_COL_S, 1, cond_h1, plot_pivots_h1)
// H4: Offset 1, Width 1 (align with H1/D)
l_h4_pp := f_draw_pivot(l_h4_pp, h4_PP, PIV_COL_P, 1, 1, cond_h4, plot_pivots_h4)
lb_h4_pp := f_draw_pivot_tag(lb_h4_pp, h4_PP, "P H4", PIV_COL_P, 1, cond_h4, plot_pivots_h4)
l_h4_r1 := f_draw_pivot(l_h4_r1, h4_R1, PIV_COL_R, 1, 1, cond_h4, plot_pivots_h4)
lb_h4_r1 := f_draw_pivot_tag(lb_h4_r1, h4_R1, "R1 H4", PIV_COL_R, 1, cond_h4, plot_pivots_h4)
l_h4_r2 := f_draw_pivot(l_h4_r2, h4_R2, PIV_COL_R, 1, 1, cond_h4, plot_pivots_h4)
lb_h4_r2 := f_draw_pivot_tag(lb_h4_r2, h4_R2, "R2 H4", PIV_COL_R, 1, cond_h4, plot_pivots_h4)
l_h4_r3 := f_draw_pivot(l_h4_r3, h4_R3, PIV_COL_R, 1, 1, cond_h4, plot_pivots_h4)
lb_h4_r3 := f_draw_pivot_tag(lb_h4_r3, h4_R3, "R3 H4", PIV_COL_R, 1, cond_h4, plot_pivots_h4)
l_h4_r4 := f_draw_pivot(l_h4_r4, h4_R4, PIV_COL_R, 1, 1, cond_h4, plot_pivots_h4)
lb_h4_r4 := f_draw_pivot_tag(lb_h4_r4, h4_R4, "R4 H4", PIV_COL_R, 1, cond_h4, plot_pivots_h4)
l_h4_s1 := f_draw_pivot(l_h4_s1, h4_S1, PIV_COL_S, 1, 1, cond_h4, plot_pivots_h4)
lb_h4_s1 := f_draw_pivot_tag(lb_h4_s1, h4_S1, "S1 H4", PIV_COL_S, 1, cond_h4, plot_pivots_h4)
l_h4_s2 := f_draw_pivot(l_h4_s2, h4_S2, PIV_COL_S, 1, 1, cond_h4, plot_pivots_h4)
lb_h4_s2 := f_draw_pivot_tag(lb_h4_s2, h4_S2, "S2 H4", PIV_COL_S, 1, cond_h4, plot_pivots_h4)
l_h4_s3 := f_draw_pivot(l_h4_s3, h4_S3, PIV_COL_S, 1, 1, cond_h4, plot_pivots_h4)
lb_h4_s3 := f_draw_pivot_tag(lb_h4_s3, h4_S3, "S3 H4", PIV_COL_S, 1, cond_h4, plot_pivots_h4)
l_h4_s4 := f_draw_pivot(l_h4_s4, h4_S4, PIV_COL_S, 1, 1, cond_h4, plot_pivots_h4)
lb_h4_s4 := f_draw_pivot_tag(lb_h4_s4, h4_S4, "S4 H4", PIV_COL_S, 1, cond_h4, plot_pivots_h4)
// D: Offset 1, Width 2
l_d_pp := f_draw_pivot(l_d_pp, d_PP, PIV_COL_P, 2, 1, Intra, plot_pivots_d)
lb_d_pp := f_draw_pivot_tag(lb_d_pp, d_PP, "P D", PIV_COL_P, 1, Intra, plot_pivots_d)
l_d_r1 := f_draw_pivot(l_d_r1, d_R1, PIV_COL_R, 2, 1, Intra, plot_pivots_d)
lb_d_r1 := f_draw_pivot_tag(lb_d_r1, d_R1, "R1 D", PIV_COL_R, 1, Intra, plot_pivots_d)
l_d_r2 := f_draw_pivot(l_d_r2, d_R2, PIV_COL_R, 2, 1, Intra, plot_pivots_d)
lb_d_r2 := f_draw_pivot_tag(lb_d_r2, d_R2, "R2 D", PIV_COL_R, 1, Intra, plot_pivots_d)
l_d_r3 := f_draw_pivot(l_d_r3, d_R3, PIV_COL_R, 2, 1, Intra, plot_pivots_d)
lb_d_r3 := f_draw_pivot_tag(lb_d_r3, d_R3, "R3 D", PIV_COL_R, 1, Intra, plot_pivots_d)
l_d_r4 := f_draw_pivot(l_d_r4, d_R4, PIV_COL_R, 2, 1, Intra, plot_pivots_d)
lb_d_r4 := f_draw_pivot_tag(lb_d_r4, d_R4, "R4 D", PIV_COL_R, 1, Intra, plot_pivots_d)
l_d_s1 := f_draw_pivot(l_d_s1, d_S1, PIV_COL_S, 2, 1, Intra, plot_pivots_d)
lb_d_s1 := f_draw_pivot_tag(lb_d_s1, d_S1, "S1 D", PIV_COL_S, 1, Intra, plot_pivots_d)
l_d_s2 := f_draw_pivot(l_d_s2, d_S2, PIV_COL_S, 2, 1, Intra, plot_pivots_d)
lb_d_s2 := f_draw_pivot_tag(lb_d_s2, d_S2, "S2 D", PIV_COL_S, 1, Intra, plot_pivots_d)
l_d_s3 := f_draw_pivot(l_d_s3, d_S3, PIV_COL_S, 2, 1, Intra, plot_pivots_d)
lb_d_s3 := f_draw_pivot_tag(lb_d_s3, d_S3, "S3 D", PIV_COL_S, 1, Intra, plot_pivots_d)
l_d_s4 := f_draw_pivot(l_d_s4, d_S4, PIV_COL_S, 2, 1, Intra, plot_pivots_d)
lb_d_s4 := f_draw_pivot_tag(lb_d_s4, d_S4, "S4 D", PIV_COL_S, 1, Intra, plot_pivots_d)
// W: Offset 3, Width 3
l_w_pp := f_draw_pivot(l_w_pp, w_PP, PIV_COL_P, 3, 3, Intra_D, plot_pivots_w)
lb_w_pp := f_draw_pivot_tag(lb_w_pp, w_PP, "P W", PIV_COL_P, 3, Intra_D, plot_pivots_w)
l_w_r1 := f_draw_pivot(l_w_r1, w_R1, PIV_COL_R, 3, 3, Intra_D, plot_pivots_w)
lb_w_r1 := f_draw_pivot_tag(lb_w_r1, w_R1, "R1 W", PIV_COL_R, 3, Intra_D, plot_pivots_w)
l_w_r2 := f_draw_pivot(l_w_r2, w_R2, PIV_COL_R, 3, 3, Intra_D, plot_pivots_w)
lb_w_r2 := f_draw_pivot_tag(lb_w_r2, w_R2, "R2 W", PIV_COL_R, 3, Intra_D, plot_pivots_w)
l_w_r3 := f_draw_pivot(l_w_r3, w_R3, PIV_COL_R, 3, 3, Intra_D, plot_pivots_w)
lb_w_r3 := f_draw_pivot_tag(lb_w_r3, w_R3, "R3 W", PIV_COL_R, 3, Intra_D, plot_pivots_w)
l_w_r4 := f_draw_pivot(l_w_r4, w_R4, PIV_COL_R, 3, 3, Intra_D, plot_pivots_w)
lb_w_r4 := f_draw_pivot_tag(lb_w_r4, w_R4, "R4 W", PIV_COL_R, 3, Intra_D, plot_pivots_w)
l_w_s1 := f_draw_pivot(l_w_s1, w_S1, PIV_COL_S, 3, 3, Intra_D, plot_pivots_w)
lb_w_s1 := f_draw_pivot_tag(lb_w_s1, w_S1, "S1 W", PIV_COL_S, 3, Intra_D, plot_pivots_w)
l_w_s2 := f_draw_pivot(l_w_s2, w_S2, PIV_COL_S, 3, 3, Intra_D, plot_pivots_w)
lb_w_s2 := f_draw_pivot_tag(lb_w_s2, w_S2, "S2 W", PIV_COL_S, 3, Intra_D, plot_pivots_w)
l_w_s3 := f_draw_pivot(l_w_s3, w_S3, PIV_COL_S, 3, 3, Intra_D, plot_pivots_w)
lb_w_s3 := f_draw_pivot_tag(lb_w_s3, w_S3, "S3 W", PIV_COL_S, 3, Intra_D, plot_pivots_w)
l_w_s4 := f_draw_pivot(l_w_s4, w_S4, PIV_COL_S, 3, 3, Intra_D, plot_pivots_w)
lb_w_s4 := f_draw_pivot_tag(lb_w_s4, w_S4, "S4 W", PIV_COL_S, 3, Intra_D, plot_pivots_w)
// M: Offset 5, Width 4
l_m_pp := f_draw_pivot(l_m_pp, m_PP, PIV_COL_P, 4, 5, Intra_D_W, plot_pivots_m)
lb_m_pp := f_draw_pivot_tag(lb_m_pp, m_PP, "P M", PIV_COL_P, 5, Intra_D_W, plot_pivots_m)
l_m_r1 := f_draw_pivot(l_m_r1, m_R1, PIV_COL_R, 4, 5, Intra_D_W, plot_pivots_m)
lb_m_r1 := f_draw_pivot_tag(lb_m_r1, m_R1, "R1 M", PIV_COL_R, 5, Intra_D_W, plot_pivots_m)
l_m_r2 := f_draw_pivot(l_m_r2, m_R2, PIV_COL_R, 4, 5, Intra_D_W, plot_pivots_m)
lb_m_r2 := f_draw_pivot_tag(lb_m_r2, m_R2, "R2 M", PIV_COL_R, 5, Intra_D_W, plot_pivots_m)
l_m_r3 := f_draw_pivot(l_m_r3, m_R3, PIV_COL_R, 4, 5, Intra_D_W, plot_pivots_m)
lb_m_r3 := f_draw_pivot_tag(lb_m_r3, m_R3, "R3 M", PIV_COL_R, 5, Intra_D_W, plot_pivots_m)
l_m_r4 := f_draw_pivot(l_m_r4, m_R4, PIV_COL_R, 4, 5, Intra_D_W, plot_pivots_m)
lb_m_r4 := f_draw_pivot_tag(lb_m_r4, m_R4, "R4 M", PIV_COL_R, 5, Intra_D_W, plot_pivots_m)
l_m_s1 := f_draw_pivot(l_m_s1, m_S1, PIV_COL_S, 4, 5, Intra_D_W, plot_pivots_m)
lb_m_s1 := f_draw_pivot_tag(lb_m_s1, m_S1, "S1 M", PIV_COL_S, 5, Intra_D_W, plot_pivots_m)
l_m_s2 := f_draw_pivot(l_m_s2, m_S2, PIV_COL_S, 4, 5, Intra_D_W, plot_pivots_m)
lb_m_s2 := f_draw_pivot_tag(lb_m_s2, m_S2, "S2 M", PIV_COL_S, 5, Intra_D_W, plot_pivots_m)
l_m_s3 := f_draw_pivot(l_m_s3, m_S3, PIV_COL_S, 4, 5, Intra_D_W, plot_pivots_m)
lb_m_s3 := f_draw_pivot_tag(lb_m_s3, m_S3, "S3 M", PIV_COL_S, 5, Intra_D_W, plot_pivots_m)
l_m_s4 := f_draw_pivot(l_m_s4, m_S4, PIV_COL_S, 4, 5, Intra_D_W, plot_pivots_m)
lb_m_s4 := f_draw_pivot_tag(lb_m_s4, m_S4, "S4 M", PIV_COL_S, 5, Intra_D_W, plot_pivots_m)
// 3M: Offset 7, Width 5
l_3m_pp := f_draw_pivot(l_3m_pp, m3_PP, PIV_COL_P, 5, 7, Intra_D_W_M, plot_pivots_3m)
lb_3m_pp := f_draw_pivot_tag(lb_3m_pp, m3_PP, "P 3M", PIV_COL_P, 7, Intra_D_W_M, plot_pivots_3m)
l_3m_r1 := f_draw_pivot(l_3m_r1, m3_R1, PIV_COL_R, 5, 7, Intra_D_W_M, plot_pivots_3m)
lb_3m_r1 := f_draw_pivot_tag(lb_3m_r1, m3_R1, "R1 3M", PIV_COL_R, 7, Intra_D_W_M, plot_pivots_3m)
l_3m_r2 := f_draw_pivot(l_3m_r2, m3_R2, PIV_COL_R, 5, 7, Intra_D_W_M, plot_pivots_3m)
lb_3m_r2 := f_draw_pivot_tag(lb_3m_r2, m3_R2, "R2 3M", PIV_COL_R, 7, Intra_D_W_M, plot_pivots_3m)
l_3m_r3 := f_draw_pivot(l_3m_r3, m3_R3, PIV_COL_R, 5, 7, Intra_D_W_M, plot_pivots_3m)
lb_3m_r3 := f_draw_pivot_tag(lb_3m_r3, m3_R3, "R3 3M", PIV_COL_R, 7, Intra_D_W_M, plot_pivots_3m)
l_3m_r4 := f_draw_pivot(l_3m_r4, m3_R4, PIV_COL_R, 5, 7, Intra_D_W_M, plot_pivots_3m)
lb_3m_r4 := f_draw_pivot_tag(lb_3m_r4, m3_R4, "R4 3M", PIV_COL_R, 7, Intra_D_W_M, plot_pivots_3m)
l_3m_s1 := f_draw_pivot(l_3m_s1, m3_S1, PIV_COL_S, 5, 7, Intra_D_W_M, plot_pivots_3m)
lb_3m_s1 := f_draw_pivot_tag(lb_3m_s1, m3_S1, "S1 3M", PIV_COL_S, 7, Intra_D_W_M, plot_pivots_3m)
l_3m_s2 := f_draw_pivot(l_3m_s2, m3_S2, PIV_COL_S, 5, 7, Intra_D_W_M, plot_pivots_3m)
lb_3m_s2 := f_draw_pivot_tag(lb_3m_s2, m3_S2, "S2 3M", PIV_COL_S, 7, Intra_D_W_M, plot_pivots_3m)
l_3m_s3 := f_draw_pivot(l_3m_s3, m3_S3, PIV_COL_S, 5, 7, Intra_D_W_M, plot_pivots_3m)
lb_3m_s3 := f_draw_pivot_tag(lb_3m_s3, m3_S3, "S3 3M", PIV_COL_S, 7, Intra_D_W_M, plot_pivots_3m)
l_3m_s4 := f_draw_pivot(l_3m_s4, m3_S4, PIV_COL_S, 5, 7, Intra_D_W_M, plot_pivots_3m)
lb_3m_s4 := f_draw_pivot_tag(lb_3m_s4, m3_S4, "S4 3M", PIV_COL_S, 7, Intra_D_W_M, plot_pivots_3m)
// 12M: Offset 9, Width 6
l_12m_pp := f_draw_pivot(l_12m_pp, m12_PP, PIV_COL_P, 6, 9, Intra_D_W_M, plot_pivots_12m)
lb_12m_pp := f_draw_pivot_tag(lb_12m_pp, m12_PP, "P 12M", PIV_COL_P, 9, Intra_D_W_M, plot_pivots_12m)
l_12m_r1 := f_draw_pivot(l_12m_r1, m12_R1, PIV_COL_R, 6, 9, Intra_D_W_M, plot_pivots_12m)
lb_12m_r1 := f_draw_pivot_tag(lb_12m_r1, m12_R1, "R1 12M", PIV_COL_R, 9, Intra_D_W_M, plot_pivots_12m)
l_12m_r2 := f_draw_pivot(l_12m_r2, m12_R2, PIV_COL_R, 6, 9, Intra_D_W_M, plot_pivots_12m)
lb_12m_r2 := f_draw_pivot_tag(lb_12m_r2, m12_R2, "R2 12M", PIV_COL_R, 9, Intra_D_W_M, plot_pivots_12m)
l_12m_r3 := f_draw_pivot(l_12m_r3, m12_R3, PIV_COL_R, 6, 9, Intra_D_W_M, plot_pivots_12m)
lb_12m_r3 := f_draw_pivot_tag(lb_12m_r3, m12_R3, "R3 12M", PIV_COL_R, 9, Intra_D_W_M, plot_pivots_12m)
l_12m_r4 := f_draw_pivot(l_12m_r4, m12_R4, PIV_COL_R, 6, 9, Intra_D_W_M, plot_pivots_12m)
lb_12m_r4 := f_draw_pivot_tag(lb_12m_r4, m12_R4, "R4 12M", PIV_COL_R, 9, Intra_D_W_M, plot_pivots_12m)
l_12m_s1 := f_draw_pivot(l_12m_s1, m12_S1, PIV_COL_S, 6, 9, Intra_D_W_M, plot_pivots_12m)
lb_12m_s1 := f_draw_pivot_tag(lb_12m_s1, m12_S1, "S1 12M", PIV_COL_S, 9, Intra_D_W_M, plot_pivots_12m)
l_12m_s2 := f_draw_pivot(l_12m_s2, m12_S2, PIV_COL_S, 6, 9, Intra_D_W_M, plot_pivots_12m)
lb_12m_s2 := f_draw_pivot_tag(lb_12m_s2, m12_S2, "S2 12M", PIV_COL_S, 9, Intra_D_W_M, plot_pivots_12m)
l_12m_s3 := f_draw_pivot(l_12m_s3, m12_S3, PIV_COL_S, 6, 9, Intra_D_W_M, plot_pivots_12m)
lb_12m_s3 := f_draw_pivot_tag(lb_12m_s3, m12_S3, "S3 12M", PIV_COL_S, 9, Intra_D_W_M, plot_pivots_12m)
l_12m_s4 := f_draw_pivot(l_12m_s4, m12_S4, PIV_COL_S, 6, 9, Intra_D_W_M, plot_pivots_12m)
lb_12m_s4 := f_draw_pivot_tag(lb_12m_s4, m12_S4, "S4 12M", PIV_COL_S, 9, Intra_D_W_M, plot_pivots_12m)


//----------------------------------- Bollinger Bands ------------------------------------

f_stdev(_bb_len) => ta.stdev(close, _bb_len)
f_sma(_sma_len) => ta.sma(close, _sma_len)

f_bb_basis(_sma_len) => f_sma(_sma_len)

f_bb_dev(_sma_len) => f_stdev(_sma_len)

// Stage 4: Bollinger Bands Hard-Gating
float basis = na
float dev_1 = na
float upper_1 = na
float lower_1 = na
float dev_3 = na
float upper_3 = na
float lower_3 = na
bool approach_up = false
bool approach_dn = false

if eff_BB_plot
    ops_bb += dbg_ops ? 1 : 0 // Count Ops

    //bb1
    basis := f_bb_basis(eff_bb_len)
    dev_1 := eff_bb_mult * f_bb_dev(eff_bb_len)
    upper_1 := basis + dev_1
    lower_1 := basis - dev_1

    //bb3
    dev_3 := BB_sdev_3 * f_bb_dev(eff_bb_len)
    upper_3 := basis + dev_3
    lower_3 := basis - dev_3

    approach_up := near_bb ? high > upper_1 : true
    approach_dn := near_bb ? low < lower_1 : true

bup_1 = plot(eff_BB_plot and approach_up ? upper_1 : na, title='Upper BB1', color=color.new(color.gray, 100), linewidth=1)
bdn_1 = plot(eff_BB_plot and approach_dn ? lower_1 : na, title='Lower BB1', color=color.new(color.gray, 100), linewidth=1)

bup_3 = plot(eff_BB_plot and approach_up ? upper_3 : na, title='Upper BB3', color=color.new(color.gray, 100), linewidth=1)
bdn_3 = plot(eff_BB_plot and approach_dn ? lower_3 : na, title='Lower BB3', color=color.new(color.gray, 100), linewidth=1)

fill(bup_1, bup_3, color=color.new(color.red, 80))
fill(bdn_1, bdn_3, color=color.new(color.green, 80))


//----------------- Trading Sessions Logic -----------------

// Global FIFO Array for Session Lines
var line[] sess_lines = array.new_line()

// Function to calculate state and draw Session Boxes or Lines
// UPDATED: Added FIFO Logic
f_draw_session(_show, _sess, _tz, _col, _style, _box, _high, _low, _start_t_state, _restrict, _restrict_time, _lines_array, _limit) =>
    is_weekend = dayofweek == dayofweek.saturday or dayofweek == dayofweek.sunday

    // Calculate if session is active (Raw)
    bool is_sess_raw = _show and not is_weekend and not na(time(timeframe.period, _sess, _tz))
    bool is_start = is_sess_raw and not is_sess_raw[1]

    // Update Start Time State
    int start_t_cur = _start_t_state
    if is_start
        start_t_cur := time

    // Calculate Restriction (Effective Session)
    bool is_sess = is_sess_raw
    if _restrict and is_sess_raw and not na(start_t_cur)
        // Convert restricted time (minutes) to ms
        ms_limit = _restrict_time * 60 * 1000
        if (time - start_t_cur) >= ms_limit
            is_sess := false

    // Vertical Line Logic (FIFO)
    if _style == "Vertical Line" and is_start
        line new_l = line.new(x1=bar_index, y1=low, x2=bar_index, y2=high, extend=extend.both, color=color.new(_col, 70), style=line.style_solid, width=1)
        array.push(_lines_array, new_l)
        if array.size(_lines_array) > _limit
            line.delete(array.shift(_lines_array))

    // Box Logic
    box b_cur = _box
    float h_cur = _high
    float l_cur = _low

    if _style == "Box" and is_sess
        if is_start // Session Start
            h_cur := high
            l_cur := low
            b_cur := box.new(left=bar_index, top=h_cur, right=bar_index, bottom=l_cur, border_color=_col, bgcolor=_col)
        else // Session Ongoing
            h_cur := math.max(h_cur, high)
            l_cur := math.min(l_cur, low)
            box.set_top(b_cur, h_cur)
            box.set_bottom(b_cur, l_cur)
            box.set_right(b_cur, bar_index + 1)

    [is_sess, b_cur, h_cur, l_cur, start_t_cur]

// Check TF Constraint (Visible only if TF <= 1 Hour)
show_sess_on_tf = timeframe.isintraday and timeframe.multiplier <= 60

// Define Global State Variables for each Session
var box b_lon = na, var float h_lon = na, var float l_lon = na, var int st_lon = na
var box b_ny = na, var float h_ny = na, var float l_ny = na, var int st_ny = na
var box b_tok = na, var float h_tok = na, var float l_tok = na, var int st_tok = na
var box b_syd = na, var float h_syd = na, var float l_syd = na, var int st_syd = na

// Execute Function
[lon_active, t_b_lon, t_h_lon, t_l_lon, t_st_lon] = f_draw_session(eff_london_show and show_sess_on_tf, london_sess, sess_timezone, london_col, sess_style, b_lon, h_lon, l_lon, st_lon, use_sess_rest, sess_rest_time, sess_lines, sess_line_limit_eff)
b_lon := t_b_lon
h_lon := t_h_lon
l_lon := t_l_lon
st_lon := t_st_lon

[ny_active, t_b_ny, t_h_ny, t_l_ny, t_st_ny] = f_draw_session(eff_ny_show and show_sess_on_tf, ny_sess, sess_timezone, ny_col, sess_style, b_ny, h_ny, l_ny, st_ny, use_sess_rest, sess_rest_time, sess_lines, sess_line_limit_eff)
b_ny := t_b_ny
h_ny := t_h_ny
l_ny := t_l_ny
st_ny := t_st_ny

// --- ADD-ON: Second line at 19:30 for New York (only for Vertical Line) ---
if eff_ny_show and show_sess_on_tf and sess_style == "Vertical Line"
    // Prevent weekends (skip the line)
    is_weekend_ny = dayofweek == dayofweek.saturday or dayofweek == dayofweek.sunday
    // Check for the 19:30 session start in the selected timezone
    // "1930-2359" ensures the start is detected even on higher timeframes (e.g., 1h)
    is_1930_sess  = not is_weekend_ny and not na(time(timeframe.period, "1930-2359", sess_timezone))
    is_1930_start = is_1930_sess and not is_1930_sess[1]

    if is_1930_start
        line l = line.new(x1=bar_index, y1=low, x2=bar_index, y2=high, extend=extend.both, color=color.new(ny_col, 70), style=line.style_dashed, width=1)
        array.push(sess_lines, l)
        if array.size(sess_lines) > sess_line_limit_eff
            line.delete(array.shift(sess_lines))
// -------------------------------------------------------------------------------

[tok_active, t_b_tok, t_h_tok, t_l_tok, t_st_tok] = f_draw_session(eff_tokyo_show and show_sess_on_tf, tokyo_sess, sess_timezone, tokyo_col, sess_style, b_tok, h_tok, l_tok, st_tok, use_sess_rest, sess_rest_time, sess_lines, sess_line_limit_eff)
b_tok := t_b_tok
h_tok := t_h_tok
l_tok := t_l_tok
st_tok := t_st_tok

[syd_active, t_b_syd, t_h_syd, t_l_syd, t_st_syd] = f_draw_session(eff_sydney_show and show_sess_on_tf, sydney_sess, sess_timezone, sydney_col, sess_style, b_syd, h_syd, l_syd, st_syd, use_sess_rest, sess_rest_time, sess_lines, sess_line_limit_eff)
b_syd := t_b_syd
h_syd := t_h_syd
l_syd := t_l_syd
st_syd := t_st_syd

// Draw Backgrounds - COMBINED
// Priority: NY > London > Tokyo > Sydney (in case of overlapping times)
// For Inv. Background: Unified Blue 50% if sessions enabled but NOT active.
bool any_sess_configured = eff_london_show or eff_ny_show or eff_tokyo_show or eff_sydney_show
bool any_sess_active     = lon_active or ny_active or tok_active or syd_active

color bg_sess_color = na

if show_sess_on_tf
    if sess_style == "Background"
        bg_sess_color := ny_active ? ny_col : lon_active ? london_col : tok_active ? tokyo_col : syd_active ? sydney_col : na
    else if sess_style == "Inv. Background"
        if any_sess_configured
            bg_sess_color := any_sess_active ? na : color.new(color.blue, 85)

f_calc_lite_value_levels(_lookback, _bins, _area_pct, _src_choice) =>
    float hi = ta.highest(high, _lookback)
    float lo = ta.lowest(low, _lookback)
    float step = (hi - lo) / _bins
    if step <= 0
        [na, na, na]
    else
        float[] hist = array.new_float(_bins, 0.0)
        float total = 0.0
        for i = 0 to _lookback - 1
            float price = _src_choice == "HL2" ? hl2[i] : _src_choice == "Close" ? close[i] : hlc3[i]
            int idx = math.min(_bins - 1, math.max(0, int(math.floor((price - lo) / step))))
            float vol = volume[i]
            array.set(hist, idx, array.get(hist, idx) + vol)
            total += vol
        float maxv = -1.0
        int poc_idx = 0
        for i = 0 to _bins - 1
            float v = array.get(hist, i)
            if v > maxv
                maxv := v
                poc_idx := i
        float target = total * _area_pct / 100.0
        float cum = array.get(hist, poc_idx)
        int left = poc_idx
        int right = poc_idx
        while cum < target and (left > 0 or right < _bins - 1)
            float left_vol = left > 0 ? array.get(hist, left - 1) : -1
            float right_vol = right < _bins - 1 ? array.get(hist, right + 1) : -1
            if right_vol > left_vol
                right += 1
                cum += right_vol
            else
                left -= 1
                cum += left_vol
        float poc_price = lo + (poc_idx + 0.5) * step
        float val_price = lo + left * step
        float vah_price = lo + (right + 1) * step
        [poc_price, vah_price, val_price]


//------------------------------------------------------- VWAP Core & Bands -------------------------------------------------------
// Stage 3 & 4: VWAP Core + Bands + Z-Score

var VwapState vs = VwapState.new(0.0, 0.0, na)
var WelfordState ws = WelfordState.new(0, 0.0, 0.0)

// Anchor Logic
bool new_anchor = false
if eff_vwap_anchor == "Session (Daily Reset)"
    new_anchor := ta.change(time("D"))
else if eff_vwap_anchor == "Weekly"
    new_anchor := ta.change(time("W"))

// Session Filter
bool in_calc_window = true
if vwap_only_sess
    // any_sess_active is defined in Trading Sessions Logic
    in_calc_window := any_sess_active

// Update Logic
float vwap_val = na
float sigma_val = na
float z_val = na
string stretch_state = "NORMAL"

if eff_vwap_enabled
    // Anchor Reset
    if new_anchor
        vs.cumVol := 0.0
        vs.cumPV := 0.0
        vs.vwap := na
        ws.n := 0
        ws.mean := 0.0
        ws.m2 := 0.0

    // Core Calc
    // Source Mapping
    float src = vwap_src_opt == "HL2" ? hl2 : vwap_src_opt == "Close" ? close : vwap_src_opt == "OHLC4" ? ohlc4 : hlc3

    if in_calc_window
        vs.cumVol += volume
        vs.cumPV += (volume * src)

    if vs.cumVol > 0
        vwap_val := vs.cumPV / vs.cumVol
        vs.vwap := vwap_val

    // Bands / Sigma Calc
    if not na(vwap_val) and (eff_vwap_zone or eff_vwap_fullbands or eff_vwap_z)
        float dev = close - vwap_val

        if vwap_sigma_mode == "Rolling (ta.stdev)"
            sigma_val := ta.stdev(dev, vwap_stdev_len)
        else // Session (Welford)
            if in_calc_window
                ws.n += 1
                float delta = dev - ws.mean
                ws.mean += delta / ws.n
                ws.m2 += delta * (dev - ws.mean)

            float variance = ws.n > 1 ? ws.m2 / (ws.n - 1) : 0.0
            sigma_val := math.sqrt(variance)

        // Z-Score
        if eff_vwap_z and not na(sigma_val) and sigma_val > 0
            z_val := dev / sigma_val

            // State
            if z_val >= z_th_ext
                stretch_state := "EXTREME UP"
            else if z_val >= z_th_tp
                stretch_state := "TP UP"
            else if z_val >= z_th_entry
                stretch_state := "ENTRY UP"
            else if z_val <= -z_th_ext
                stretch_state := "EXTREME DN"
            else if z_val <= -z_th_tp
                stretch_state := "TP DN"
            else if z_val <= -z_th_entry
                stretch_state := "ENTRY DN"

// Plotting
plot(vwap_show_line ? vwap_val : na, color=color.new(color.orange, 0), title="VWAP")

// Bands
plot((eff_vwap_zone or eff_vwap_fullbands) and not na(sigma_val) ? vwap_val + band_k1 * sigma_val : na, "B1 Up", color.new(color.gray, 80))
plot((eff_vwap_zone or eff_vwap_fullbands) and not na(sigma_val) ? vwap_val - band_k1 * sigma_val : na, "B1 Dn", color.new(color.gray, 80))
plot(eff_vwap_fullbands and not na(sigma_val) ? vwap_val + band_k2 * sigma_val : na, "B2 Up", color.new(color.gray, 60))
plot(eff_vwap_fullbands and not na(sigma_val) ? vwap_val - band_k2 * sigma_val : na, "B2 Dn", color.new(color.gray, 60))
plot(eff_vwap_fullbands and not na(sigma_val) ? vwap_val + band_k3 * sigma_val : na, "B3 Up", color.new(color.gray, 40))
plot(eff_vwap_fullbands and not na(sigma_val) ? vwap_val - band_k3 * sigma_val : na, "B3 Dn", color.new(color.gray, 40))

// Label for Z
var label lb_vwap_z = na
if eff_vwap_z and stretch_state != "NORMAL" and barstate.islast
    label.delete(lb_vwap_z)
    color c_z = str.contains(stretch_state, "EXTREME") ? color.red : color.orange
    lb_vwap_z := label.new(bar_index, high, "Z: " + str.tostring(z_val, "#.##") + "\n" + stretch_state, color=c_z, style=label.style_label_down, textcolor=color.white, size=size.small)
else
    label.delete(lb_vwap_z)
    lb_vwap_z := na

//------------------------------------------------------- Lite Value (POC/VAH/VAL) -------------------------------------------------------
var line lv_poc = na
var line lv_vah = na
var line lv_val = na

if not eff_lite_value
    if not na(lv_poc)
        line.delete(lv_poc)
        lv_poc := na
    if not na(lv_vah)
        line.delete(lv_vah)
        lv_vah := na
    if not na(lv_val)
        line.delete(lv_val)
        lv_val := na
else
    bool lv_update_ok = lite_value_update == "On last bar" ? true : (bar_index % lite_value_update_n == 0)
    bool lv_can_calc = barstate.islast and lv_update_ok and bar_index >= lite_value_lookback
    if lv_can_calc
        [lv_poc_val, lv_vah_val, lv_val_val] = f_calc_lite_value_levels(lite_value_lookback, lite_value_bins, lite_value_area_pct, lite_value_src)
        if not na(lv_poc_val)
            int x1 = bar_index - lite_value_lookback
            int x2 = bar_index
            color c_poc = color.new(color.orange, lite_value_line_transp)
            color c_vah = color.new(color.green, lite_value_line_transp)
            color c_val = color.new(color.red, lite_value_line_transp)
            lv_poc := na(lv_poc) ? line.new(x1, lv_poc_val, x2, lv_poc_val, color=c_poc, width=lite_value_line_width, extend=extend.right) : lv_poc
            lv_vah := na(lv_vah) ? line.new(x1, lv_vah_val, x2, lv_vah_val, color=c_vah, width=lite_value_line_width, extend=extend.right) : lv_vah
            lv_val := na(lv_val) ? line.new(x1, lv_val_val, x2, lv_val_val, color=c_val, width=lite_value_line_width, extend=extend.right) : lv_val
            line.set_xy1(lv_poc, x1, lv_poc_val)
            line.set_xy2(lv_poc, x2, lv_poc_val)
            line.set_xy1(lv_vah, x1, lv_vah_val)
            line.set_xy2(lv_vah, x2, lv_vah_val)
            line.set_xy1(lv_val, x1, lv_val_val)
            line.set_xy2(lv_val, x2, lv_val_val)


//------------------------------------------------------- Opening Range / Initial Balance -------------------------------------------------------
// Stage 5: OR/IB Module

var OrState ors = OrState.new(na, na, na, false, false, na, na, na)

if lens_changed and not eff_or_enabled
    if not na(ors.id_box)
        box.delete(ors.id_box)
        ors.id_box := na
    if not na(ors.l_hi)
        line.delete(ors.l_hi)
        ors.l_hi := na
    if not na(ors.l_lo)
        line.delete(ors.l_lo)
        ors.l_lo := na
    ors.start_bar := na
    ors.hi := na
    ors.lo := na
    ors.building := false
    ors.locked := false

// Session Determination
string or_s_str = na
if or_sess == "London"
    or_s_str := london_sess
else if or_sess == "New York"
    or_s_str := ny_sess
else
    or_s_str := or_cust

bool in_or_sess = false
if eff_or_enabled
    in_or_sess := not na(time(timeframe.period, or_s_str, sess_timezone))

bool or_start = in_or_sess and not in_or_sess[1]

// Events
bool or_break_up = false
bool or_break_dn = false

if eff_or_enabled
    // Reset / Start
    if or_start
        ors.start_bar := bar_index
        ors.hi := high
        ors.lo := low
        ors.building := true
        ors.locked := false

        // Colors
        color c_or_border = color.new(color.blue, 30)
        color c_or_bg = color.new(color.blue, 99)
        color c_or_hi = color.new(color.green, 30)
        color c_or_lo = color.new(color.red, 30)

        // Visibility
        bool show_box = or_display == "Box+Lines" or or_display == "Box"
        bool show_lines = or_display == "Box+Lines" or or_display == "Lines"

        // Init/Reset Objects (reuse)
        if na(ors.id_box)
            ors.id_box := box.new(bar_index, high, bar_index, low, border_color=show_box ? c_or_border : na, bgcolor=show_box ? c_or_bg : na)
            ors.l_hi := line.new(bar_index, high, bar_index, high, color=show_lines ? c_or_hi : na)
            ors.l_lo := line.new(bar_index, low, bar_index, low, color=show_lines ? c_or_lo : na)
        else
            box.set_left(ors.id_box, bar_index)
            box.set_right(ors.id_box, bar_index)
            box.set_top(ors.id_box, high)
            box.set_bottom(ors.id_box, low)
            box.set_border_color(ors.id_box, show_box ? c_or_border : na)
            box.set_bgcolor(ors.id_box, show_box ? c_or_bg : na)

            line.set_xy1(ors.l_hi, bar_index, high)
            line.set_xy2(ors.l_hi, bar_index, high)
            line.set_color(ors.l_hi, show_lines ? c_or_hi : na)

            line.set_xy1(ors.l_lo, bar_index, low)
            line.set_xy2(ors.l_lo, bar_index, low)
            line.set_color(ors.l_lo, show_lines ? c_or_lo : na)

    else if ors.building
        // Check Duration
        int eff_min = or_type == "Initial Balance" ? 60 : or_min
        float dur_sec = eff_min * 60
        float elapsed_sec = (bar_index - ors.start_bar + 1) * tf_sec // Estimation via bars, simpler

        if elapsed_sec <= dur_sec
            // Update
            ors.hi := math.max(ors.hi, high)
            ors.lo := math.min(ors.lo, low)

            box.set_top(ors.id_box, ors.hi)
            box.set_bottom(ors.id_box, ors.lo)
            box.set_right(ors.id_box, bar_index + 1)

            line.set_y1(ors.l_hi, ors.hi)
            line.set_xy2(ors.l_hi, bar_index + 1, ors.hi)

            line.set_y1(ors.l_lo, ors.lo)
            line.set_xy2(ors.l_lo, bar_index + 1, ors.lo)
        else
            // Finish
            ors.building := false
            if or_lock
                ors.locked := true
                // Freeze
                box.set_right(ors.id_box, bar_index + 5)
                line.set_x2(ors.l_hi, bar_index + 5)
                line.set_x2(ors.l_lo, bar_index + 5)

    else if ors.locked
        // Extension
        if barstate.islast
            box.set_right(ors.id_box, bar_index + 5)
            line.set_x2(ors.l_hi, bar_index + 5)
            line.set_x2(ors.l_lo, bar_index + 5)

        // Break Logic (Events)
        if close > ors.hi and close[1] <= ors.hi
            or_break_up := true
        if close < ors.lo and close[1] >= ors.lo
            or_break_dn := true

//----------------- MTF Candle Overlay Logic -----------------

// Map string selection
mtf_tf = switch mtf_tf_sel
    "5m" => "5"
    "15m" => "15"
    "30m" => "30"
    "1h" => "60"
    "2h" => "120"
    "4h" => "240"
    "6h" => "360"
    "12h" => "720"
    "1d" => "D"
    "1w" => "W"
    "1M" => "M"
    "3M" => "3M"
    => "240"

// Check logic
is_higher_tf = timeframe.in_seconds(mtf_tf) > timeframe.in_seconds(timeframe.period)

// Variables (Stage 2: Hard Gating)
float mtf_o = na
float mtf_h = na
float mtf_l = na
float mtf_c = na

if ON_MTF_OV and is_higher_tf
    [t_o, t_h, t_l, t_c] = request.security(syminfo.tickerid, mtf_tf, [open, high, low, close], lookahead=barmerge.lookahead_on)
    mtf_o := t_o
    mtf_h := t_h
    mtf_l := t_l
    mtf_c := t_c
    active_sec_calls += 1

new_mtf_bar = timeframe.change(mtf_tf)

// Colors
t_val = 100 - mtf_opacity
col_bull = color.new(color.green, t_val)
col_bear = color.new(color.red, t_val)
col_border_bull = color.new(color.green, 80)
col_border_bear = color.new(color.red, 80)

// Persistent Variables (Stage 4: Array FIFO)
var box[] mtf_boxes = array.new_box()
var box mtf_body = na

if ON_MTF_OV and is_higher_tf

    // Determine Bull/Bear state
    is_up = mtf_c >= mtf_o
    cur_fill = is_up ? col_bull : col_bear
    cur_border = is_up ? col_border_bull : col_border_bear

    // Geometry: Always High to Low
    float body_top = mtf_h
    float body_bot = mtf_l

    // --- Logic ---
    if new_mtf_bar
        // Create NEW object to avoid overlap
        mtf_body := box.new(bar_index, body_top, bar_index, body_bot, border_color=cur_border, border_width=1, bgcolor=cur_fill)
        array.push(mtf_boxes, mtf_body)

        // FIFO Limit (e.g., 50)
        if array.size(mtf_boxes) > 50
            box.delete(array.shift(mtf_boxes))

    else
        // Update Existing Object (Last one created)
        // If mtf_body is maintained, we can use it directly, but getting from array is safer if logic was complex
        // Here we just reuse mtf_body var which holds the current active box
        if not na(mtf_body)
            box.set_right(mtf_body, bar_index)
            box.set_top(mtf_body, body_top)
            box.set_bottom(mtf_body, body_bot)
            box.set_bgcolor(mtf_body, cur_fill)
            box.set_border_color(mtf_body, cur_border)
else
    // Cleanup if disabled
    if array.size(mtf_boxes) > 0
        for i = 0 to array.size(mtf_boxes) - 1
            box.delete(array.get(mtf_boxes, i))
        array.clear(mtf_boxes)


//--------------------------------------------------------- Fair Value Gaps (FVG) ---------------------------------------------------------

// --- Variables to track boxes for limit ---
var box[] boxes_fvg1 = array.new_box()
var box[] boxes_fvg2 = array.new_box()

// --- FVG 1 LOGIC ---

// Helper: Timeframe Duration
tf_ms1 = (fvg1_tf_sel == "" ? timeframe.in_seconds(timeframe.period) : timeframe.in_seconds(fvg1_tf_sel)) * 1000

// Variable to track the last drawn FVG time
var int last_fvg_time1 = 0

// Stage 3: Refactored FVG1 (No security if Current TF)
float h1_mtf1 = na, float l1_mtf1 = na, float h3_mtf1 = na, float l3_mtf1 = na, int t2_mtf1 = na

// Only fetch MTF data if valid TF selection AND enabled
if ON_FVG1 and fvg1_tf_sel != ""
    [t_h1, t_l1, t_h3, t_l3, t_t2] = request.security(syminfo.tickerid, fvg1_tf_sel, [high[1], low[1], high[3], low[3], time[2]], lookahead=barmerge.lookahead_off)
    h1_mtf1 := t_h1, l1_mtf1 := t_l1, h3_mtf1 := t_h3, l3_mtf1 := t_l3, t2_mtf1 := t_t2
    active_sec_calls += 1

if ON_FVG1
    box b_new = na
    // CASE A: Current Timeframe (Direct Source)
    if fvg1_tf_sel == ""
        if low > high[2] // Bullish
            _border_bull = color.new(color.green, 90)
            b_new := box.new(left=bar_index[2], top=low, right=bar_index + (fvg1_len - 1), bottom=high[2], border_color=_border_bull, bgcolor=col_fvg1_bull)

        if high < low[2] // Bearish
            _border_bear = color.new(color.red, 90)
            b_new := box.new(left=bar_index[2], top=low[2], right=bar_index + (fvg1_len - 1), bottom=high, border_color=_border_bear, bgcolor=col_fvg1_bear)

        // Registry
        sig.fvg_bull := low > high[2]
        sig.fvg_bear := high < low[2]

    // CASE B: Higher Timeframe (Security Source)
    else
        if t2_mtf1 != last_fvg_time1 and not na(t2_mtf1)
            t_left = t2_mtf1 - tf_ms1
            t_right = t2_mtf1 + (tf_ms1 * fvg1_len)

            if l1_mtf1 > h3_mtf1 // Bullish
                _border_bull = color.new(color.green, 90)
                b_new := box.new(left=t_left, top=l1_mtf1, right=t_right, bottom=h3_mtf1, xloc=xloc.bar_time, border_color=_border_bull, bgcolor=col_fvg1_bull)

            if h1_mtf1 < l3_mtf1 // Bearish
                _border_bear = color.new(color.red, 90)
                b_new := box.new(left=t_left, top=l3_mtf1, right=t_right, bottom=h1_mtf1, xloc=xloc.bar_time, border_color=_border_bear, bgcolor=col_fvg1_bear)

            last_fvg_time1 := t2_mtf1

    // Manage Box Limit
    if not na(b_new)
        array.push(boxes_fvg1, b_new)
        if array.size(boxes_fvg1) > fvg1_limit_eff
            box.delete(array.shift(boxes_fvg1))
else
    // Cleanup
    if array.size(boxes_fvg1) > 0
        for i = 0 to array.size(boxes_fvg1) - 1
            box.delete(array.get(boxes_fvg1, i))
        array.clear(boxes_fvg1)


// --- FVG 2 LOGIC ---

// Helper: Timeframe Duration
tf_ms2 = (fvg2_tf_sel == "" ? timeframe.in_seconds(timeframe.period) : timeframe.in_seconds(fvg2_tf_sel)) * 1000

// Variable to track the last drawn FVG time
var int last_fvg_time2 = 0

// Stage 3: Refactored FVG2 (No security if Current TF)
float h1_mtf2 = na, float l1_mtf2 = na, float h3_mtf2 = na, float l3_mtf2 = na, int t2_mtf2 = na

if ON_FVG2 and fvg2_tf_sel != ""
    [t_h1, t_l1, t_h3, t_l3, t_t2] = request.security(syminfo.tickerid, fvg2_tf_sel, [high[1], low[1], high[3], low[3], time[2]], lookahead=barmerge.lookahead_off)
    h1_mtf2 := t_h1, l1_mtf2 := t_l1, h3_mtf2 := t_h3, l3_mtf2 := t_l3, t2_mtf2 := t_t2
    active_sec_calls += 1

if ON_FVG2
    box b_new = na
    // CASE A: Current Timeframe (Direct Source)
    if fvg2_tf_sel == ""
        if low > high[2] // Bullish
            _border_bull = color.new(color.green, 90)
            b_new := box.new(left=bar_index[2], top=low, right=bar_index + (fvg2_len - 1), bottom=high[2], border_color=_border_bull, bgcolor=col_fvg2_bull)

        if high < low[2] // Bearish
            _border_bear = color.new(color.red, 90)
            b_new := box.new(left=bar_index[2], top=low[2], right=bar_index + (fvg2_len - 1), bottom=high, border_color=_border_bear, bgcolor=col_fvg2_bear)

    // CASE B: Higher Timeframe
    else
        if t2_mtf2 != last_fvg_time2 and not na(t2_mtf2)
            t_left = t2_mtf2 - tf_ms2
            t_right = t2_mtf2 + (tf_ms2 * fvg2_len)

            if l1_mtf2 > h3_mtf2 // Bullish
                _border_bull = color.new(color.green, 90)
                b_new := box.new(left=t_left, top=l1_mtf2, right=t_right, bottom=h3_mtf2, xloc=xloc.bar_time, border_color=_border_bull, bgcolor=col_fvg2_bull)

            if h1_mtf2 < l3_mtf2 // Bearish
                _border_bear = color.new(color.red, 90)
                b_new := box.new(left=t_left, top=l3_mtf2, right=t_right, bottom=h1_mtf2, xloc=xloc.bar_time, border_color=_border_bear, bgcolor=col_fvg2_bear)

            last_fvg_time2 := t2_mtf2

    // Manage Box Limit
    if not na(b_new)
        array.push(boxes_fvg2, b_new)
        if array.size(boxes_fvg2) > fvg2_limit_eff
            box.delete(array.shift(boxes_fvg2))
else
    // Cleanup
    if array.size(boxes_fvg2) > 0
        for i = 0 to array.size(boxes_fvg2) - 1
            box.delete(array.get(boxes_fvg2, i))
        array.clear(boxes_fvg2)


//--------------------------------------------------------- Real-time Fractal Alert ---------------------------------------------------------

// --- Logic Calculation ---
// We cannot use ta.pivothigh/low for the realtime bar effectively, so we check the structure manually.
// Structure: [Left2][Left1][Pivot][Right1][Current(Right2)]
// Indices:    [4]    [3]    [2]     [1]       [0]

// Check if bars 4, 3, 2, and 1 form a valid pre-fractal structure
valid_up_structure = high[2] > high[3] and high[2] > high[4] and high[2] > high[1]
valid_dn_structure = low[2] < low[3] and low[2] < low[4] and low[2] < low[1]

// Check if the current running bar (0) respects the fractal rule
// Up Fractal: Current High must be lower than Pivot High
rt_up_frac = valid_up_structure and high < high[2]

// Down Fractal: Current Low must be higher than Pivot Low
rt_dn_frac = valid_dn_structure and low > low[2]

// --- Trigger Alert ---
// Trigger only if enabled, in realtime, and condition is met.
// freq_once_per_bar avoids spamming the sound on every tick.
if use_rt_alert and barstate.isrealtime and (rt_up_frac or rt_dn_frac)
    alert("Potential Fractal Forming (5th Candle Running)", alert.freq_once_per_bar)


//--------------------------------------------------------- Additional Context (No Plot-Limit Usage) ---------------------------------------------------------

// Helper to check session start (Used by both functionalities)
f_is_sess_start(_show, _sess) =>
    _show and not na(time(timeframe.period, _sess, sess_timezone)) and na(time(timeframe.period, _sess, sess_timezone)[1])

/// --- 1. 1st Session Candle (Separate Logic) ---
// Function to run on the target timeframe
f_calc_sess_1st() =>
    // Check all sessions using global inputs
    bool s_lon_s = f_is_sess_start(london_show, london_sess)
    bool s_ny_s  = f_is_sess_start(ny_show, ny_sess)
    bool s_tok_s = f_is_sess_start(tokyo_show, tokyo_sess)
    bool s_syd_s = f_is_sess_start(sydney_show, sydney_sess)
    bool s_nypm_s = f_is_sess_start(ny_show, "1930-2359")

    // Store latest session start values
    var float saved_h = na
    var float saved_l = na
    var int saved_t = na

    if s_lon_s or s_ny_s or s_tok_s or s_syd_s or s_nypm_s
        saved_h := high
        saved_l := low
        saved_t := time

    [saved_h, saved_l, saved_t]

// Retrieve from selected timeframe
float s1_h_val = na
float s1_l_val = na
int s1_t_val = na

if ON_SESS_1ST
    [t_h, t_l, t_t] = request.security(syminfo.tickerid, sess_1st_tf, f_calc_sess_1st(), lookahead=barmerge.lookahead_on)
    s1_h_val := t_h
    s1_l_val := t_l
    s1_t_val := t_t
    active_sec_calls += 1

// Variables for 1st Session Lines/Labels
var line l_s1_h = na
var line l_s1_l = na
var label lb_s1_h = na
var label lb_s1_l = na

// Stage 3: 1st Session Candle & Last Fractal S/R (Reuse)

if barstate.islast
    // Check Visibility
    is_valid_s1_tf = timeframe.in_seconds(timeframe.period) <= timeframe.in_seconds(sess_1st_tf)

    if ON_SESS_1ST and is_valid_s1_tf
        if not na(s1_h_val) and not na(s1_t_val)
            l_s1_h := f_line_get_or_create(l_s1_h, s1_t_val, s1_h_val, time, s1_h_val, color.new(color.gray, 50), line.style_solid, xloc.bar_time)
            lb_s1_h := f_label_get_or_create(lb_s1_h, bar_index + 4, s1_h_val, "1st High", color.new(color.gray, 30))

        if not na(s1_l_val) and not na(s1_t_val)
            l_s1_l := f_line_get_or_create(l_s1_l, s1_t_val, s1_l_val, time, s1_l_val, color.new(color.gray, 50), line.style_solid, xloc.bar_time)
            lb_s1_l := f_label_get_or_create(lb_s1_l, bar_index + 4, s1_l_val, "1st Low", color.new(color.gray, 30))

    else
        line.delete(l_s1_h)
        l_s1_h := na
        line.delete(l_s1_l)
        l_s1_l := na
        label.delete(lb_s1_h)
        lb_s1_h := na
        label.delete(lb_s1_l)
        lb_s1_l := na
else
    // Cleanup if disabled (Hard Gating)
    line.delete(l_s1_h)
    l_s1_h := na
    line.delete(l_s1_l)
    l_s1_l := na
    label.delete(lb_s1_h)
    lb_s1_h := na
    label.delete(lb_s1_l)
    lb_s1_l := na


// --- 2. Last Fractal S/R (Lines & Labels) ---

// Function to get last confirmed fractal price and time
f_get_last_fractal_data() =>
    ph = ta.pivothigh(high, 2, 2)
    pl = ta.pivotlow(low, 2, 2)
    // When ph is detected, the fractal apex is at [2]
    p_h_val = ta.valuewhen(not na(ph), high[2], 0)
    p_h_time = ta.valuewhen(not na(ph), time[2], 0)
    p_l_val = ta.valuewhen(not na(pl), low[2], 0)
    p_l_time = ta.valuewhen(not na(pl), time[2], 0)
    [p_h_val, p_h_time, p_l_val, p_l_time]

float frac_h_val = na
int frac_h_time = na
float frac_l_val = na
int frac_l_time = na

if ON_LAST_FR
    [t_fh, t_fht, t_fl, t_flt] = request.security(syminfo.tickerid, last_frac_tf, f_get_last_fractal_data())
    frac_h_val := t_fh
    frac_h_time := t_fht
    frac_l_val := t_fl
    frac_l_time := t_flt
    active_sec_calls += 1

var line l_last_fh = na
var line l_last_fl = na
var label lb_last_fh = na
var label lb_last_fl = na

if barstate.islast
    // Check Visibility
    is_valid_frac_tf = timeframe.in_seconds(timeframe.period) <= timeframe.in_seconds(last_frac_tf)

    if ON_LAST_FR and is_valid_frac_tf
        if not na(frac_h_val)
            l_last_fh := f_line_get_or_create(l_last_fh, frac_h_time, frac_h_val, time, frac_h_val, color.new(color.gray, 50), line.style_dashed, xloc.bar_time)
            lb_last_fh := f_label_get_or_create(lb_last_fh, bar_index + 8, frac_h_val, "Frac High", color.new(color.gray, 30))

        if not na(frac_l_val)
            l_last_fl := f_line_get_or_create(l_last_fl, frac_l_time, frac_l_val, time, frac_l_val, color.new(color.gray, 50), line.style_dashed, xloc.bar_time)
            lb_last_fl := f_label_get_or_create(lb_last_fl, bar_index + 8, frac_l_val, "Frac Low", color.new(color.gray, 30))
    else
        line.delete(l_last_fh)
        l_last_fh := na
        line.delete(l_last_fl)
        l_last_fl := na
        label.delete(lb_last_fh)
        lb_last_fh := na
        label.delete(lb_last_fl)
        lb_last_fl := na
else
    // Cleanup if disabled (Hard Gating)
    line.delete(l_last_fh)
    l_last_fh := na
    line.delete(l_last_fl)
    l_last_fl := na
    label.delete(lb_last_fh)
    lb_last_fh := na
    label.delete(lb_last_fl)
    lb_last_fl := na


// --- 3. Volume Spikes (Char) ---
// Calculates if Volume is x-times larger than the SMA(20) of Volume
avg_vol = ta.sma(volume, 20)
is_vol_spike = volume > (avg_vol * vol_mult)

// Uses plotchar (Symbol 'V' in bold RED)
plotchar(eff_show_vol ? is_vol_spike : na, char='v', location=location.bottom, color=color.new(color.red, 30), size=size.tiny, title="High Volume Spike")
sig.vol_spike := eff_show_vol and is_vol_spike


// --- Stage 2: ADR/Today Range Calculation ---
float d_range_local = na
float adr_local = na
float adr_pct = na

bool new_day = ta.change(time("D"))
var float dayHi = na
var float dayLo = na

if timeframe.isintraday
    if new_day or na(dayHi) or na(dayLo)
        dayHi := high
        dayLo := low
    else
        dayHi := math.max(dayHi, high)
        dayLo := math.min(dayLo, low)

    d_range_local := dayHi - dayLo

    var float[] adr_buf = array.new_float()
    var float adr_sum = 0.0
    if new_day and not na(dayHi[1]) and not na(dayLo[1])
        float last_closed_day_range = dayHi[1] - dayLo[1]
        array.push(adr_buf, last_closed_day_range)
        adr_sum += last_closed_day_range
        if array.size(adr_buf) > eff_adr_len
            float popped = array.shift(adr_buf)
            adr_sum -= popped

    adr_local := array.size(adr_buf) > 0 ? adr_sum / array.size(adr_buf) : na
else
    d_range_local := high - low
    adr_local := ta.sma(high - low, eff_adr_len)

// 3. ADR %
if not na(d_range_local) and not na(adr_local) and adr_local > 0
    adr_pct := (d_range_local / adr_local) * 100

// Optional Debug Info
plot(adr_pct, title="ADR %", color=color.new(color.white, 100), display=display.data_window + display.status_line)

// ADR Label removed as per design requirements (Panel only)
var label lbl_adr = na
label.delete(lbl_adr)

// Update Panel Row 9 (ADR%)
if not na(info_panel) and barstate.islast
    string adr_txt = "ADR% " + (not na(adr_pct) ? str.tostring(adr_pct, "#.#") + "%" : "n/a")
    table.merge_cells(info_panel, 0, f_panel_row(9), 2, f_panel_row(9))
    table.cell(table_id=info_panel, column=0, row=f_panel_row(9), text=adr_txt, text_size=size.small, text_color=color.silver, tooltip="ADR% = progress within Average Daily Range; helps avoid entering near exhaustion.")


// -------------------------------------------------------------------------
// DEBUG PANEL (Stage 0)
// -------------------------------------------------------------------------
// Update Peaks
if ops_trend > peak_ops_trend
    peak_ops_trend := ops_trend

if dbg_ops and barstate.islast
    if na(tbl_dbg)
        tbl_dbg := table.new(position.bottom_right, 2, 15, bgcolor=color.new(color.black, 50), frame_width=1, frame_color=color.gray)

    // Header
    table.cell(tbl_dbg, 0, 0, "Metric", text_color=color.white, text_size=size.small)
    table.cell(tbl_dbg, 1, 0, "Value", text_color=color.white, text_size=size.small)

    // Security Calls
    table.cell(tbl_dbg, 0, 1, "Sec Calls", text_color=color.white, text_size=size.small)
    table.cell(tbl_dbg, 1, 1, str.tostring(active_sec_calls), text_color=color.yellow, text_size=size.small)

    // Heavy Ops
    table.cell(tbl_dbg, 0, 2, "Ops Trend (Peak)", text_color=color.white, text_size=size.small)
    table.cell(tbl_dbg, 1, 2, str.tostring(ops_trend) + " (" + str.tostring(peak_ops_trend) + ")", text_color=ops_trend > 0 ? color.orange : color.green, text_size=size.small)

    if dbg_perf
        string adr_dbg = "len=" + str.tostring(eff_adr_len) + " rng=" + str.tostring(d_range_local, "#.##") + " adr=" + str.tostring(adr_local, "#.##") + " sec=" + str.tostring(active_sec_calls)
        table.cell(tbl_dbg, 0, 7, "ADR", text_color=color.white, text_size=size.small)
        table.cell(tbl_dbg, 1, 7, adr_dbg, text_color=color.silver, text_size=size.small)

    table.cell(tbl_dbg, 0, 5, "Ops DIV", text_color=color.white, text_size=size.small)
    table.cell(tbl_dbg, 1, 5, str.tostring(ops_div), text_color=ops_div > 0 ? color.orange : color.green, text_size=size.small)

    table.cell(tbl_dbg, 0, 6, "Ops BB", text_color=color.white, text_size=size.small)
    table.cell(tbl_dbg, 1, 6, str.tostring(ops_bb), text_color=ops_bb > 0 ? color.orange : color.green, text_size=size.small)

    // Flags Status
    table.cell(tbl_dbg, 0, 8, "ON_PS", text_color=color.white, text_size=size.small)
    table.cell(tbl_dbg, 1, 8, str.tostring(ON_PS), text_color=ON_PS ? color.green : color.red, text_size=size.small)

    table.cell(tbl_dbg, 0, 9, "ON_MTF_OV", text_color=color.white, text_size=size.small)
    table.cell(tbl_dbg, 1, 9, str.tostring(ON_MTF_OV), text_color=ON_MTF_OV ? color.green : color.red, text_size=size.small)

    table.cell(tbl_dbg, 0, 10, "ON_FVG1", text_color=color.white, text_size=size.small)
    table.cell(tbl_dbg, 1, 10, str.tostring(ON_FVG1), text_color=ON_FVG1 ? color.green : color.red, text_size=size.small)

    table.cell(tbl_dbg, 0, 11, "ON_SESS_1ST", text_color=color.white, text_size=size.small)
    table.cell(tbl_dbg, 1, 11, str.tostring(ON_SESS_1ST), text_color=ON_SESS_1ST ? color.green : color.red, text_size=size.small)

    int dbg_line_count = array.size(sess_lines)
    int dbg_box_count = array.size(mtf_boxes) + array.size(boxes_fvg1) + array.size(boxes_fvg2)
    int dbg_label_count = 0

    table.cell(tbl_dbg, 0, 12, "Lines", text_color=color.white, text_size=size.small)
    table.cell(tbl_dbg, 1, 12, str.tostring(dbg_line_count), text_color=color.yellow, text_size=size.small)

    table.cell(tbl_dbg, 0, 13, "Boxes", text_color=color.white, text_size=size.small)
    table.cell(tbl_dbg, 1, 13, str.tostring(dbg_box_count), text_color=color.yellow, text_size=size.small)

    table.cell(tbl_dbg, 0, 14, "Labels", text_color=color.white, text_size=size.small)
    table.cell(tbl_dbg, 1, 14, str.tostring(dbg_label_count), text_color=color.yellow, text_size=size.small)
else
    if not na(tbl_dbg)
        table.delete(tbl_dbg)
        tbl_dbg := na


// --- Stage 3: ATR Expansion Logic ---
float calc_atr = ta.atr(eff_atr_len)
float atr_ref  = ta.sma(calc_atr, eff_atr_norm)
float atr_norm = (not na(atr_ref) and atr_ref > 0) ? (calc_atr / atr_ref) : 1.0

bool atr_is_low  = atr_norm < eff_atr_low
bool atr_is_high = atr_norm > eff_atr_high


// --- Stage 4: Keltner Channel & Squeeze Detector ---
// KC Calc
float kc_mid = ta.ema(close, eff_kc_len)
float kc_range = ta.atr(eff_kc_len)
float kc_up = kc_mid + (kc_range * eff_kc_mult)
float kc_dn = kc_mid - (kc_range * eff_kc_mult)

// BB Calc (Specific for Squeeze - Standard 20/2.0 per Regime defaults)
[s_bb_mid, s_bb_up, s_bb_dn] = ta.bb(close, eff_bb_len, eff_bb_mult)

// KC Squeeze: BB is fully INSIDE KC
bool squeeze_kc = (s_bb_up < kc_up) and (s_bb_dn > kc_dn)


// --- Stage 5 (Regime Upgrade): Squeeze Integration ---
// Trend / Range / Squeeze

var string regime_state = "Range"
var color regime_bg = na

// Calculate Regime regardless of display for history
// Calc BBW (Standard 20, 2.0) - Reusing Stage 4 values
bbw = (s_bb_up - s_bb_dn) / s_bb_mid
avg_bbw = ta.sma(bbw, 50)

// 1. BBW Squeeze (Original Logic)
bool is_squeeze_bbw = bbw < (avg_bbw * 0.7)

// 2. Combine with KC Squeeze (Stage 4)
bool is_squeeze = is_squeeze_bbw // Default
if eff_use_kc_squeeze
    if squeeze_strict
        is_squeeze := is_squeeze_bbw and squeeze_kc
    else
        is_squeeze := is_squeeze_bbw or squeeze_kc

// Calc ADX
[_, _, adx_r] = ta.dmi(eff_adx_len, eff_adx_len)
is_trend = adx_r > eff_adx_th

// Logic
if is_squeeze
    regime_state := "SQUEEZE"
    regime_bg := color.new(color.yellow, 90)
else if is_trend
    regime_state := "TREND"
    regime_bg := color.new(color.blue, 92)
else
    regime_state := "RANGE"
    regime_bg := na

// Update Panel (Moved Up)
var string reg_conf = "RANGE"
var color reg_bg_conf = color.new(color.gray, 100)
var string rvol_conf = ""
var color rvol_bg_conf = color.new(color.gray, 100)
var string z_conf = ""
var color z_bg_conf = color.new(color.gray, 100)
if eff_regime_panel and not na(info_panel) and barstate.islast
    color c_reg_bg_live = regime_state == "SQUEEZE" ? color.new(color.yellow, 30) : regime_state == "TREND" ? color.new(color.blue, 30) : color.new(color.gray, 100)
    string m_reg = f_marker(panel_show_live and barstate.isrealtime, barstate.isconfirmed)
    bool reg_upd = barstate.isconfirmed or not barstate.isrealtime
    reg_conf := reg_upd ? regime_state : reg_conf
    reg_bg_conf := reg_upd ? c_reg_bg_live : reg_bg_conf

    string reg_disp = panel_show_live ? regime_state : reg_conf
    color reg_bg_disp = panel_show_live ? c_reg_bg_live : reg_bg_conf
    reg_bg_disp := reg_disp == "SQUEEZE" ? color.new(reg_bg_disp, 50) : reg_bg_disp
    reg_disp := f_with_marker(reg_disp, m_reg)
    table.merge_cells(info_panel, 1, f_panel_row(12), 2, f_panel_row(12))
    table.cell(info_panel, 0, f_panel_row(12), "REG", text_size=marker_size_inline, text_color=color.silver)
    table.cell(info_panel, 1, f_panel_row(12), reg_disp, text_size=marker_size_inline, text_color=color.silver, bgcolor=reg_bg_disp)

    // Row 13: RVOL
    if eff_rvol_enabled
        string rv_code = rvol_val < rvol_th_1 ? "L" : rvol_val < rvol_th_2 ? "M" : rvol_val < rvol_th_3 ? "H" : "E"
        string rvol_txt_live = str.tostring(rvol_val, "#.##") + "x " + rv_code
        color c_rv_p_live = rvol_state == "3" ? color.new(color.red, 30) : rvol_state == "2" ? color.new(color.orange, 30) : color.new(color.gray, 100)

        bool rvol_init = rvol_conf == ""
        rvol_conf := rvol_init ? rvol_txt_live : rvol_conf
        rvol_bg_conf := rvol_init ? c_rv_p_live : rvol_bg_conf
        bool rvol_upd = barstate.isconfirmed or not barstate.isrealtime
        rvol_conf := rvol_upd ? rvol_txt_live : rvol_conf
        rvol_bg_conf := rvol_upd ? c_rv_p_live : rvol_bg_conf

        string rvol_disp = panel_show_live ? rvol_txt_live : rvol_conf
        color rvol_bg_disp = panel_show_live ? c_rv_p_live : rvol_bg_conf
        rvol_disp := f_with_marker(rvol_disp, m_reg)
        table.merge_cells(info_panel, 1, f_panel_row(13), 2, f_panel_row(13))
        table.cell(info_panel, 0, f_panel_row(13), "VOL", text_size=marker_size_inline, text_color=color.silver)
        table.cell(info_panel, 1, f_panel_row(13), rvol_disp, text_size=marker_size_inline, text_color=color.silver, bgcolor=rvol_bg_disp)

    // Row 14: VWAP Z
    if eff_vwap_enabled and eff_vwap_z and not na(z_val)
        float abs_z = math.abs(z_val)
        string z_code = abs_z < z_th_entry ? "N" : abs_z < z_th_tp ? "S" : abs_z < z_th_ext ? "T" : "E"
        string z_txt_live = str.tostring(z_val, "#.1") + "Ïƒ " + z_code

        color c_z_p_live = str.contains(stretch_state, "EXTREME") ? color.new(color.red, 30) : str.contains(stretch_state, "TP") ? color.new(color.orange, 30) : color.new(color.gray, 100)

        bool z_init = z_conf == ""
        z_conf := z_init ? z_txt_live : z_conf
        z_bg_conf := z_init ? c_z_p_live : z_bg_conf
        bool z_upd = barstate.isconfirmed or not barstate.isrealtime
        z_conf := z_upd ? z_txt_live : z_conf
        z_bg_conf := z_upd ? c_z_p_live : z_bg_conf

        string z_disp = panel_show_live ? z_txt_live : z_conf
        color z_bg_disp = panel_show_live ? c_z_p_live : z_bg_conf
        z_disp := f_with_marker(z_disp, m_reg)
        table.merge_cells(info_panel, 1, f_panel_row(14), 2, f_panel_row(14))
        table.cell(info_panel, 0, f_panel_row(14), "VWP", text_size=marker_size_inline, text_color=color.silver)
        table.cell(info_panel, 1, f_panel_row(14), z_disp, text_size=marker_size_inline, text_color=color.silver, bgcolor=z_bg_disp)


//------------------------------------------------------- Squeeze Box Module -------------------------------------------------------
// Stage 6: Squeeze Box logic

var SqState sqs = SqState.new(na, na, false, false, na)

if lens_changed and not eff_sq_box_enabled
    if not na(sqs.id_box)
        box.delete(sqs.id_box)
        sqs.id_box := na
    sqs.hi := na
    sqs.lo := na
    sqs.active := false
    sqs.locked := false

// Condition (Chart TF or MTF via sq_tf)
int sq_bar_ms = timeframe.in_seconds(timeframe.period) * 1000

f_sq_mtf_pack() =>
    float kc_mid_tf = ta.ema(close, eff_kc_len)
    float kc_range_tf = ta.atr(eff_kc_len)
    float kc_up_tf = kc_mid_tf + (kc_range_tf * eff_kc_mult)
    float kc_dn_tf = kc_mid_tf - (kc_range_tf * eff_kc_mult)

    [s_bb_mid_tf, s_bb_up_tf, s_bb_dn_tf] = ta.bb(close, eff_bb_len, eff_bb_mult)

    bool squeeze_kc_tf = (s_bb_up_tf < kc_up_tf) and (s_bb_dn_tf > kc_dn_tf)

    float bbw_tf = (s_bb_up_tf - s_bb_dn_tf) / s_bb_mid_tf
    float avg_bbw_tf_50 = ta.sma(bbw_tf, 50)
    float avg_bbw_tf_20 = ta.sma(bbw_tf, 20)
    float avg_bbw_tf = na(avg_bbw_tf_50) ? avg_bbw_tf_20 : avg_bbw_tf_50
    bool is_squeeze_bbw_tf = (not na(avg_bbw_tf)) and (bbw_tf < (avg_bbw_tf * 0.7))

    bool is_squeeze_tf = is_squeeze_bbw_tf
    if eff_use_kc_squeeze
        if squeeze_strict
            is_squeeze_tf := is_squeeze_bbw_tf and squeeze_kc_tf
        else
            is_squeeze_tf := is_squeeze_bbw_tf or squeeze_kc_tf

    var float r_hi = na
    var float r_lo = na
    var int r_t0 = na
    if is_squeeze_tf and not is_squeeze_tf[1]
        r_t0 := time
        r_hi := high
        r_lo := low
    else if is_squeeze_tf
        r_hi := na(r_hi) ? high : math.max(r_hi, high)
        r_lo := na(r_lo) ? low : math.min(r_lo, low)

    [is_squeeze_tf, r_hi, r_lo, r_t0]

string sq_tf_eff = sq_tf == "" ? timeframe.period : sq_tf
int sq_tf_sec = timeframe.in_seconds(sq_tf_eff)
bool sq_use_mtf = (sq_tf != "") and (not na(sq_tf_sec)) and (sq_tf_sec > tf_sec)

bool sq_in_mtf = false
float sq_hi_mtf = na
float sq_lo_mtf = na
int sq_t0_mtf = na

if sq_use_mtf
    [sq_in_mtf, sq_hi_mtf, sq_lo_mtf, sq_t0_mtf] = request.security(syminfo.tickerid, sq_tf_eff, f_sq_mtf_pack(), lookahead=panel_update_mode == "Realtime Preview" ? barmerge.lookahead_on : barmerge.lookahead_off)

bool in_sq_condition = sq_use_mtf ? (na(sq_in_mtf) ? false : sq_in_mtf) : (regime_state == "SQUEEZE")

float sq_src_hi = sq_use_mtf ? (na(sq_hi_mtf) ? high : sq_hi_mtf) : high
float sq_src_lo = sq_use_mtf ? (na(sq_lo_mtf) ? low : sq_lo_mtf) : low
int sq_src_t0 = sq_use_mtf ? (na(sq_t0_mtf) ? time : sq_t0_mtf) : time

bool sq_start = in_sq_condition and not in_sq_condition[1]
bool sq_end = not in_sq_condition and in_sq_condition[1]

// Events
bool sq_break_up = false
bool sq_break_dn = false

if eff_sq_box_enabled
    if sq_start
        sqs.hi := sq_src_hi
        sqs.lo := sq_src_lo
        sqs.active := true
        sqs.locked := false

        // Init/Reset (Single Object Recycle)
        if na(sqs.id_box)
            sqs.id_box := box.new(sq_src_t0, sq_src_hi, time_close, sq_src_lo, xloc=xloc.bar_time, border_color=color.new(color.yellow, 30), bgcolor=color.new(color.yellow, 90))
        else
            box.set_left(sqs.id_box, sq_src_t0)
            box.set_right(sqs.id_box, time_close)
            box.set_top(sqs.id_box, sq_src_hi)
            box.set_bottom(sqs.id_box, sq_src_lo)
            box.set_border_style(sqs.id_box, line.style_solid)

    else if sqs.active
        // Update H/L
        if sq_use_mtf
            sqs.hi := sq_src_hi
            sqs.lo := sq_src_lo
        else
            sqs.hi := math.max(sqs.hi, high)
            sqs.lo := math.min(sqs.lo, low)

        box.set_top(sqs.id_box, sqs.hi)
        box.set_bottom(sqs.id_box, sqs.lo)
        box.set_right(sqs.id_box, time_close)

        if sq_end
            sqs.active := false
            if sq_lock
                sqs.locked := true
                box.set_right(sqs.id_box, time_close + (sq_bar_ms * 5))
                box.set_border_style(sqs.id_box, line.style_dashed)

    else if sqs.locked
        if barstate.islast
            box.set_right(sqs.id_box, time_close + (sq_bar_ms * 5))

        // Break Events
        if close > sqs.hi and close[1] <= sqs.hi
            sq_break_up := true
        if close < sqs.lo and close[1] >= sqs.lo
            sq_break_dn := true


//--------------------------------------------------------- CONF VWAP (Lightweight) ---------------------------------------------------------
float conf_vwap_val = na
float conf_z_val = na

if conf_use_vwap_quality
    bool use_sess = (conf_vwap_mode == "Session VWAP") or (conf_vwap_mode == "Auto" and tf_sec <= 3600)

    // Session VWAP
    var float vs_c_cumVol = 0.0
    var float vs_c_cumPV  = 0.0
    var float vwap_c_sess = na
    bool c_new_day = ta.change(time("D"))

    if use_sess
        if c_new_day
            vs_c_cumVol := 0.0
            vs_c_cumPV  := 0.0

        vs_c_cumVol += volume
        vs_c_cumPV  += volume * hlc3

        if vs_c_cumVol > 0
            vwap_c_sess := vs_c_cumPV / vs_c_cumVol
            conf_vwap_val := vwap_c_sess

    // Weekly VWAP
    var float vw_c_cumVol = 0.0
    var float vw_c_cumPV  = 0.0
    var float vwap_c_week = na
    bool c_new_week = ta.change(time("W"))

    if not use_sess
        if c_new_week
            vw_c_cumVol := 0.0
            vw_c_cumPV  := 0.0

        vw_c_cumVol += volume
        vw_c_cumPV  += volume * hlc3

        if vw_c_cumVol > 0
            vwap_c_week := vw_c_cumPV / vw_c_cumVol
            conf_vwap_val := vwap_c_week

    // Z-Score Calculation
    bool reuse_z = false
    if eff_vwap_enabled and eff_vwap_z and not na(z_val)
        if (use_sess and eff_vwap_anchor == "Session (Daily Reset)") or (not use_sess and eff_vwap_anchor == "Weekly")
            reuse_z := true

    if reuse_z
        conf_z_val := z_val
    else if not na(conf_vwap_val)
        // Independent Calculation
        // Reuse vwap_stdev_len (Default 100)
        float dev_c = close - conf_vwap_val
        float sigma_c = ta.stdev(dev_c, vwap_stdev_len)
        if sigma_c > 0
            conf_z_val := dev_c / sigma_c


//--------------------------------------------------------- CONF Engine v2: Core + Confirm + Regime Gate ---------------------------------------------------------

float conf_score = 50.0
string conf_bias = "Neutral"
float final_raw = 0.0 // Exposed for Alerts

bool eff_calc_conf = eff_show_conf_meter or show_conf_bg or show_confirmed_bias_bg

// Core Weights
float W_FR_CORE = 4.0
float W_FVG_CORE = 4.0
float W_KAMA_CORE = 2.0

// Variables for Smoothing & State
var int conf_state_engine = 0 // 0=Neut, 1=Bull, -1=Bear

if eff_calc_conf
    // --- 1. Core Score Calculation ---
    float core_w_sum = 0.0
    float core_raw_sum = 0.0

    // Fractals (Core)
    if eff_fractals_plot
        core_w_sum += W_FR_CORE
        core_raw_sum += (fr_state_inf * W_FR_CORE)

    // FVG (Core + Regime Gate)
    // Gate: Dampen FVG in SQUEEZE
    float w_fvg_effective = W_FVG_CORE
    if regime_state == "SQUEEZE"
        w_fvg_effective := W_FVG_CORE * 0.35

    // Always available (Core). FVG State is calculated globally on Current TF.
    core_w_sum += w_fvg_effective
    core_raw_sum += (fvg_state_inf * w_fvg_effective)

    // KAMA (Core)
    float kama_val_score = 0.0
    if sig.kama_bull
        kama_val_score := 1.0
    else if sig.kama_bear
        kama_val_score := -1.0

    core_w_sum += W_KAMA_CORE
    core_raw_sum += (kama_val_score * W_KAMA_CORE)

    // Calculate Core Raw (-1.0 to 1.0)
    float core_raw = (core_w_sum > 0) ? (core_raw_sum / core_w_sum) : 0.0

    // --- 2. Smoothing (AUTO SCALED) ---
    float core_smooth = ta.ema(core_raw, eff_core_ema_len)

    // --- 3. Confirm-Events (Overlay) ---
    // Trendlines & Segments with Decay
    var float ov_tl = 0.0
    var float ov_seg = 0.0

    // Update Overlay States
    if sig.tl_bull
        ov_tl := 1.0
    else if sig.tl_bear
        ov_tl := -1.0
    else
        ov_tl := ov_tl * eff_ov_decay

    if sig.seg_bull
        ov_seg := 1.0
    else if sig.seg_bear
        ov_seg := -1.0
    else
        ov_seg := ov_seg * eff_ov_decay

    // Calculate Overlay Contribution
    // Weighted Average of active overlays
    float ov_w_sum = 0.0
    float ov_raw_sum = 0.0

    if eff_plot_trendline
        ov_w_sum += 1.0
        ov_raw_sum += ov_tl

    if eff_plot_segments
        ov_w_sum += 1.0
        ov_raw_sum += ov_seg

    float overlay_raw = (ov_w_sum > 0) ? (ov_raw_sum / ov_w_sum) : 0.0

    // --- Stage 8: Confirm-Events Upgrade (ATR Filter) ---
    float ov_scale = 1.0
    if atr_is_low
        ov_scale := 0.60
    else if atr_is_high
        ov_scale := 1.00

    // Clamp Overlay (Anti-Flip)
    float overlay_clamped = math.max(-eff_ov_clamp, math.min(eff_ov_clamp, overlay_raw)) * ov_scale

    // --- 6.1 ADR Exhaustion Flags (Stage 6) ---
    bool adr_warn = eff_use_adr_gate and not na(adr_pct) and adr_pct >= eff_adr_warn
    bool adr_hard = eff_use_adr_gate and not na(adr_pct) and adr_pct >= eff_adr_hard

    // --- 4. Final Calculation & Confidence Gate ---
    final_raw := core_smooth + overlay_clamped
    // Clamp Final
    final_raw := math.max(-1.0, math.min(1.0, final_raw))

    // Regime Confidence Gate (Dampen the Score magnitude, but preserve direction/state)
    float conf_gate = 1.0
    if regime_state == "SQUEEZE"
        conf_gate := 0.40
    else if regime_state == "RANGE"
        conf_gate := 0.70

    // ADR Gate Add-on (Confidence Dampening)
    if adr_warn
        conf_gate := conf_gate * 0.85
    if adr_hard
        conf_gate := conf_gate * 0.70

    // Apply Gate to Magnitude relative to 50
    // Score 0-100. Center 50.
    // 50 + (50 * final_raw * gate)
    conf_score := 50 + (50 * final_raw * conf_gate)

    // --- 4.5 Confirmed Bias (Profile + Persistence) ---
    // Panel background is score-based; panel label is Confirmed Bias.

    float _cb_enter_bull = math.max(eff_cb_enter_bull, eff_cb_exit_bull + 0.1)
    float _cb_exit_bull  = math.min(eff_cb_exit_bull, _cb_enter_bull - 0.1)
    float _cb_enter_bear = math.min(eff_cb_enter_bear, eff_cb_exit_bear - 0.1)
    float _cb_exit_bear  = math.max(eff_cb_exit_bear, _cb_enter_bear + 0.1)

    int _cb_enter_bars = math.max(1, eff_cb_enter_bars)
    int _cb_exit_bars  = math.max(1, eff_cb_exit_bars)

    // Confirmed-only (fixed)
    bool _cb_update = barstate.isconfirmed

    // Score-color thresholds derived from Confirmed Bias neutral-zone (exit thresholds).
    float _conf_color_hi = math.max(_cb_exit_bull, _cb_exit_bear + 0.1)
    float _conf_color_lo = math.min(_cb_exit_bear, _conf_color_hi - 0.1)

    if _cb_update
        bool _enter_bull = conf_score >= _cb_enter_bull
        bool _enter_bear = conf_score <= _cb_enter_bear
        bool _exit_bull  = conf_score <= _cb_exit_bull
        bool _exit_bear  = conf_score >= _cb_exit_bear

        int _run_enter_bull = nz(ta.barssince(not _enter_bull), 0)
        int _run_enter_bear = nz(ta.barssince(not _enter_bear), 0)
        int _run_exit_bull  = nz(ta.barssince(not _exit_bull), 0)
        int _run_exit_bear  = nz(ta.barssince(not _exit_bear), 0)

        bool _enter_bull_ok = _enter_bull and _run_enter_bull >= _cb_enter_bars
        bool _enter_bear_ok = _enter_bear and _run_enter_bear >= _cb_enter_bars
        bool _exit_bull_ok  = _exit_bull  and _run_exit_bull  >= _cb_exit_bars
        bool _exit_bear_ok  = _exit_bear  and _run_exit_bear  >= _cb_exit_bars

        if conf_state_engine == 0
            if _enter_bull_ok
                conf_state_engine := 1
            else if _enter_bear_ok
                conf_state_engine := -1
        else if conf_state_engine == 1
            if _exit_bull_ok
                conf_state_engine := 0
        else if conf_state_engine == -1
            if _exit_bear_ok
                conf_state_engine := 0

    // Confirmed Bias string used in panel text.
    conf_bias := conf_state_engine == 1 ? "BULL" : conf_state_engine == -1 ? "BEAR" : "NEUT"

    // --- 5. Quality Tag (H/M/L) ---
    // Agreement: How many cores match the state?
    // Cores: FR, FVG, KAMA
    float aligned_core = 0.0
    float active_core = 0.0
    int state_sign = conf_state_engine // 1, -1, 0

    // Helper for sign match (0 matches nothing)
    // FR
    if eff_fractals_plot
        active_core += 1.0
        if state_sign != 0 and math.sign(fr_state_inf) == state_sign
            aligned_core += 1.0

    // FVG (Use effective weight presence)
    if eff_plot_fvg1 or eff_plot_fvg2
        active_core += 1.0
        if state_sign != 0 and math.sign(fvg_state_inf) == state_sign
            aligned_core += 1.0

    // KAMA
    active_core += 1.0
    float kama_sign = sig.kama_bull ? 1.0 : sig.kama_bear ? -1.0 : 0.0
    if state_sign != 0 and kama_sign == state_sign
        aligned_core += 1.0

    float agreement = (active_core > 0) ? (aligned_core / active_core) : 0.0
    float magnitude = math.abs(final_raw)

    string quality = "L"
    if magnitude >= 0.35 and agreement >= 0.66 and regime_state != "SQUEEZE"
        quality := "H"
    else if magnitude >= 0.20 and agreement >= 0.50
        quality := "M"
    else
        quality := "L"

    // --- Stage 9: Quality Degrade (ADR/ATR) ---
    if adr_warn
        if quality == "H"
            quality := "M"
        else if quality == "M"
            quality := "L"

    if adr_hard
        quality := "L"

    // Optional: Low ATR in Non-Trend degrade
    if atr_is_low and regime_state != "TREND" and quality == "H"
        quality := "M"

    // --- Stage 10: VWAP Quality Gate (Option A) ---
    string align_flag = ""
    if conf_use_vwap_quality and not na(conf_vwap_val)
        // 1. Map to Numeric (0=L, 1=M, 2=H, 3=E)
        int q_num = quality == "H" ? 2 : quality == "M" ? 1 : 0

        // 2. Alignment Logic (Bias != NEUT)
        if conf_state_engine != 0
            bool is_aligned = (conf_state_engine == 1 and close > conf_vwap_val) or (conf_state_engine == -1 and close < conf_vwap_val)

            if is_aligned
                q_num := math.min(q_num + 1, 3) // Cap at 3 (E)
                align_flag := "A"
            else
                q_num := math.max(q_num - 1, 0) // Floor at 0 (L)
                align_flag := "X"

        // 3. Stretch Penalty (Anti-Chase via |Z|)
        if not na(conf_z_val)
            float abs_z = math.abs(conf_z_val)
            int penalty = 0

            // Thresholds: z_th_entry, z_th_tp, z_th_ext (Global Inputs)
            if conf_z_penalty_mode == "Aggressive"
                if abs_z >= z_th_ext
                    penalty := -1
                else if abs_z >= z_th_tp
                    penalty := -1
            else if conf_z_penalty_mode == "Conservative"
                if abs_z >= z_th_ext
                    penalty := -3
                else if abs_z >= z_th_tp
                    penalty := -2
                else if abs_z >= z_th_entry
                    penalty := -1
            else // Default
                if abs_z >= z_th_ext
                    penalty := -2
                else if abs_z >= z_th_tp
                    penalty := -1

            q_num := math.max(q_num + penalty, 0)

        // 4. Backmap to L/M/H/E
        quality := q_num == 3 ? "E" : q_num == 2 ? "H" : q_num == 1 ? "M" : "L"

    // --- 6. Visualization (Panel) ---
    // BULL 72 H / NEUT 50 L
    if barstate.islast and eff_show_conf_meter and not na(info_panel)
        string conf_bias_panel = conf_bias
        string panel_txt_live = conf_bias_panel + " " + str.tostring(math.round(conf_score)) + " " + quality
        if align_flag != ""
            panel_txt_live := panel_txt_live + " " + align_flag

        color c_conf_live = conf_score > _conf_color_hi ? color.new(color.green, 30) : conf_score < _conf_color_lo ? color.new(color.red, 30) : color.new(color.gray, 100)

        // Neutral remains transparent
        var string conf_txt_conf = ""
        var color conf_bg_conf = color.new(color.gray, 100)
        bool conf_init = conf_txt_conf == ""
        conf_txt_conf := conf_init ? panel_txt_live : conf_txt_conf
        conf_bg_conf := conf_init ? c_conf_live : conf_bg_conf
        bool conf_upd = barstate.isconfirmed or not barstate.isrealtime
        conf_txt_conf := conf_upd ? panel_txt_live : conf_txt_conf
        conf_bg_conf := conf_upd ? c_conf_live : conf_bg_conf

        string conf_txt_disp = panel_show_live ? panel_txt_live : conf_txt_conf
        color conf_bg_disp = panel_show_live ? c_conf_live : conf_bg_conf
        string m_conf = f_marker(panel_show_live and barstate.isrealtime, barstate.isconfirmed)
        conf_txt_disp := f_with_marker(conf_txt_disp, m_conf)

        table.merge_cells(info_panel, 1, f_panel_row(11), 2, f_panel_row(11))
        table.cell(info_panel, 0, f_panel_row(11), "CONF", text_size=marker_size_inline, text_color=color.silver)
        table.cell(info_panel, 1, f_panel_row(11), conf_txt_disp, text_size=marker_size_inline, text_color=color.silver, bgcolor=conf_bg_disp)

// --- CENTRALIZED BACKGROUND ROUTING (Fix Bug #2) ---
color bg_final = na

// Logic to filter regime_bg (Squeeze/Trend only)
color regime_bg_filtered = na
if eff_regime_bg_enabled and (regime_state == "SQUEEZE" or regime_state == "TREND")
    regime_bg_filtered := regime_bg

// Logic for Confluence BG (Score vs Confirmed Bias)
color conf_bg_color = na
if show_confirmed_bias_bg
    // Confirmed Bias-driven background (stable filter)
    conf_bg_color := conf_state_engine == 1 ? color.new(color.green, transp_bg) : conf_state_engine == -1 ? color.new(color.red, transp_bg) : color.new(color.gray, 100)
else if show_conf_bg
    // Score-driven background (early pressure / heat)
    if conf_score > 55
        conf_bg_color := color.new(color.green, transp_bg)
    else if conf_score < 45
        conf_bg_color := color.new(color.red, transp_bg)
    else
        conf_bg_color := color.new(color.gray, 100) // Transparent Neutral

// Priority 1: Session (Highest)
if eff_sess_bg_enable and not na(bg_sess_color)
    bg_final := bg_sess_color
// Priority 2: Confluence BG (CONF)
else if (show_conf_bg or show_confirmed_bias_bg)
    bg_final := conf_bg_color
// Priority 3: Regime
else if not na(regime_bg_filtered)
    bg_final := regime_bg_filtered

// Single Output
bgcolor(bg_final, title="MCCS Master Background")

if barstate.islast
    prev_approach_id := approach_id


// --- Stage 5: Alerts (Centralized) ---
// alert_profile: Minimal, Normal, Moderate
// Events based on registry

// 1. Prepare Conditions
bool al_tl_break = (sig.tl_bull and not sig.tl_bull[1]) or (sig.tl_bear and not sig.tl_bear[1])
bool al_div      = (sig.div_bull and not sig.div_bull[1]) or (sig.div_bear and not sig.div_bear[1])
bool al_conf_cross = ta.crossover(conf_score, 75) or ta.crossunder(conf_score, 25) // Tighter Thresholds for Alerts
bool al_regime_chg = regime_state != regime_state[1]

// 2. Cooldown Logic
var int last_alert_time_tl = 0
var int last_alert_time_div = 0
var int last_alert_time_reg = 0
var int last_alert_time_conf = 0

// 3. Execution
if alert_profile != "Off"
    // TL Break (Minimal+)
    if (alert_profile == "Minimal" or alert_profile == "Normal" or alert_profile == "Moderate")
        if al_tl_break and (bar_index - last_alert_time_tl > alert_cooldown)
            alert("MCCS: Trendline Breakout Detected", alert.freq_once_per_bar_close)
            last_alert_time_tl := bar_index

    // Normal + Moderate
    if (alert_profile == "Normal" or alert_profile == "Moderate")
        if al_div and (bar_index - last_alert_time_div > alert_cooldown)
            alert("MCCS: Divergence Detected", alert.freq_once_per_bar_close)
            last_alert_time_div := bar_index

    // Moderate Only
    if alert_profile == "Moderate"
        if al_regime_chg and (bar_index - last_alert_time_reg > alert_cooldown)
            alert("MCCS: Regime Change to " + regime_state, alert.freq_once_per_bar_close)
            last_alert_time_reg := bar_index

        if al_conf_cross and (bar_index - last_alert_time_conf > alert_cooldown)
            alert("MCCS: High Confluence Event (Score: " + str.tostring(conf_score) + ")", alert.freq_once_per_bar_close)
            last_alert_time_conf := bar_index

// Alert Conditions (For TradingView Setup)
// Consolidated for easy selection
alertcondition(al_tl_break, "Trendline Breakout", "Fractal Trendline Breakout")
alertcondition(al_div, "Divergence", "Divergence Detected")
alertcondition(al_regime_chg, "Regime Change", "Market Regime Changed")
alertcondition(al_conf_cross, "Confluence Extreme", "Confluence Score Extreme (75/25)")

// --- Extended Alerts (New Modules) ---
// VWAP
bool al_vwap_cross_up = eff_vwap_enabled and ta.crossover(close, vwap_val)
bool al_vwap_cross_dn = eff_vwap_enabled and ta.crossunder(close, vwap_val)
bool al_z_ext_up      = eff_vwap_enabled and eff_vwap_z and not na(z_val) and z_val >= z_th_ext and z_val[1] < z_th_ext
bool al_z_ext_dn      = eff_vwap_enabled and eff_vwap_z and not na(z_val) and z_val <= -z_th_ext and z_val[1] > -z_th_ext

alertcondition(al_vwap_cross_up, "VWAP Reclaim Up", "Price reclaimed VWAP (Bullish)")
alertcondition(al_vwap_cross_dn, "VWAP Reclaim Down", "Price lost VWAP (Bearish)")
alertcondition(al_z_ext_up, "VWAP Z-Score Extreme High", "Price is extended above VWAP (Extreme)")
alertcondition(al_z_ext_dn, "VWAP Z-Score Extreme Low", "Price is extended below VWAP (Extreme)")

// OR/IB
alertcondition(or_break_up, "OR Breakout Up", "Opening Range Breakout Up")
alertcondition(or_break_dn, "OR Breakout Down", "Opening Range Breakout Down")

// RVOL
bool al_rvol_spike = eff_rvol_enabled and not na(rvol_val) and rvol_val >= 3.0 and rvol_val[1] < 3.0
alertcondition(al_rvol_spike, "RVOL Spike (3x)", "Relative Volume > 3.0 detected")

// Squeeze
alertcondition(sq_start, "Squeeze Start", "Market entered Squeeze Regime")
alertcondition(sq_end, "Squeeze Release", "Market left Squeeze Regime")
alertcondition(sq_break_up, "Squeeze Box Break Up", "Price broke Squeeze Box Up")
alertcondition(sq_break_dn, "Squeeze Box Break Down", "Price broke Squeeze Box Down")

// --- Profiling Notes ---
// Use Pine Profiler to compare before/after performance.
// Focus: VP render, intraday ADR tracking, visible mode pan/zoom.
