//@version=5
indicator("CONF REG Pro Bias Verifier", shorttitle="CONF/REG", overlay=true, max_bars_back=3000)

// -----------------------------------------------------------------------------
// 1. UI & INPUTS
// -----------------------------------------------------------------------------
grp_ui = "UI Settings"
show_panel  = input.bool(true, "Show Panel", group=grp_ui)
show_bg     = input.bool(true, "Show Background Blocks", group=grp_ui)
calc_mode   = input.string("Closed Bar", "Calculation Mode", options=["Closed Bar", "Realtime (Repainting)"], group=grp_ui)
profile     = input.string("Auto", "Profile", options=["Auto"], group=grp_ui) // Fixed to Auto
debug       = input.bool(false, "Debug Info", group=grp_ui)

// -----------------------------------------------------------------------------
// 2. HELPER FUNCTIONS & SYSTEM
// -----------------------------------------------------------------------------
f_clamp(x, lo, hi) => math.max(lo, math.min(x, hi))
f_safe_div(a, b)   => b != 0 ? a / b : 0
f_sign0(x)         => x > 0 ? 1 : x < 0 ? -1 : 0

// Update Gating
// "Closed Bar": updates strictly on confirmed bar.
// "Realtime": updates intrabar.
// NOTE: ta.* functions must run GLOBALLY (outside this check).
bool update_allowed = (calc_mode == "Realtime (Repainting)") ? true : barstate.isconfirmed

// -----------------------------------------------------------------------------
// 3. GLOBAL INDICATORS (Always calculated to maintain ta.* consistency)
// -----------------------------------------------------------------------------
// 3.1 Efficiency Ratio (ER)
len_er = 20
er_change = math.abs(close - close[len_er])
er_vol    = math.sum(math.abs(close - close[1]), len_er)
er_val    = f_safe_div(er_change, er_vol)

// 3.2 ADX
adx_len = 14
dirmov_len = 14
[di_plus, di_minus, adx_val] = ta.dmi(dirmov_len, adx_len)

// 3.3 BB Width
bb_len  = 20
bb_mult = 2.0
bb_basis = ta.sma(close, bb_len)
bb_dev   = bb_mult * ta.stdev(close, bb_len)
bb_upper = bb_basis + bb_dev
bb_lower = bb_basis - bb_dev
bbw_raw  = f_safe_div(bb_upper - bb_lower, bb_basis)
bbw_sma  = ta.sma(bbw_raw, bb_len)

// 3.4 Trend EMAs
ema_fast = ta.ema(close, 50)
ema_slow = ta.ema(close, 200)

// 3.5 ATR (Safe)
atr_len = 14
atr_val = ta.atr(atr_len)
atr_safe = math.max(atr_val, syminfo.mintick)

// 3.6 Pivots (for Structure & Divergence)
piv_l_len = 2
piv_r_len = 2
ph = ta.pivothigh(piv_l_len, piv_r_len)
pl = ta.pivotlow(piv_l_len, piv_r_len)
// Note: ph/pl are non-na only on the offset bar (index 2).
// To use them in real-time logic, we must track them.

// 3.7 RSI (for Divergence)
rsi_val = ta.rsi(close, 14)

// -----------------------------------------------------------------------------
// 4. REGIME / Trendiness Engine
// -----------------------------------------------------------------------------
// Normalize Components
trend_er  = f_clamp(er_val, 0, 1)
trend_adx = f_clamp((adx_val - 15) / (30 - 15), 0, 1)
trend_bbw = f_clamp(f_safe_div(bbw_raw - bbw_sma, bbw_sma), 0, 1) // Expansion relative to SMA

// Combine
trendiness_raw = 0.55 * trend_er + 0.35 * trend_adx + 0.10 * trend_bbw
trendiness     = f_clamp(trendiness_raw, 0, 1)
TS             = math.round(100 * trendiness)

// State Machine (Hysteresis / Ternary)
var string reg_state = "RANGE" // Init
if update_allowed
    if TS >= 55
        reg_state := "TREND"
    else if TS <= 45
        reg_state := "RANGE"
    else
        reg_state := "MIXED"

// -----------------------------------------------------------------------------
// 5. BIAS ENGINE
// -----------------------------------------------------------------------------
// 5.1 Auto Tuning & Deadzones
atrp = f_safe_div(atr_safe, close)
volF = f_clamp((atrp - 0.002) / (0.01 - 0.002), 0, 1)

dz_spread = 0.15 + 0.08 * (1 - trendiness) + 0.05 * volF
spread_scale = 1.00 * (1 + 0.2 * volF)

dz_slope  = 0.03 + 0.02 * (1 - trendiness) + 0.01 * volF
slope_scale = 0.25 * (1 + 0.2 * volF)

// 5.2 Spread Strength
spread_norm     = (ema_fast - ema_slow) / atr_safe
spread_abs      = math.abs(spread_norm)
spread_strength = spread_abs < dz_spread ? 0 : f_clamp(spread_abs / spread_scale, 0, 1)
spread_signed   = f_sign0(spread_norm) * spread_strength

// 5.3 Slope Strength
slope_len_bi = 8
slope_norm   = (ema_fast - ema_fast[slope_len_bi]) / (atr_safe * slope_len_bi)
slope_abs    = math.abs(slope_norm)
slope_strength = slope_abs < dz_slope ? 0 : f_clamp(slope_abs / slope_scale, 0, 1)
slope_signed   = f_sign0(slope_norm) * slope_strength

// 5.4 Structure State (Latched)
var float last_swing_high = na
var float last_swing_low  = na
var int   structure_state = 0

// Pivot updates happen at lag [2], but we need to track them.
// Since 'ph' and 'pl' are results of 'ta.pivothigh/low', they appear on the bar AFTER the right bars.
// They are non-na at index 0 when the pivot is confirmed (which is effectively bar[2]).
// However, strictly speaking, ph is `NaN` except on the bar it confirms.
// So we update our levels when ph/pl are valid.
// IMPORTANT: ta.pivothigh returns value at the pivot point, but it's only returned 'piv_r_len' bars later?
// Actually, ta.pivothigh returns NaN unless the CURRENT bar completes the pattern.
// If it completes, it returns the High of the pivot bar (which is at [piv_r_len]).
if not na(ph)
    last_swing_high := ph
if not na(pl)
    last_swing_low := pl

// Latch Logic (Dow Theory)
if update_allowed
    if not na(last_swing_high) and close > last_swing_high
        structure_state := 1
    else if not na(last_swing_low) and close < last_swing_low
        structure_state := -1
    // else keep state

structure_strength_factor = 0.45
structure_signed = structure_state * structure_strength_factor

// 5.5 Bias Combine
// Weights: Spread 0.45, Slope 0.25, Structure 0.30
bias_signed_raw = (spread_signed * 0.45) + (slope_signed * 0.25) + (structure_signed * 0.30)

// Trendiness Gate
bias_signed = bias_signed_raw * trendiness

// -----------------------------------------------------------------------------
// 6. EVENT / QUALITY ENGINE
// -----------------------------------------------------------------------------
// 6.1 Event Detection

// A. Fakey (Simplified & Hardcoded per user spec)
// Inside Bar at [1]
ib_cond = high[1] < high[2] and low[1] > low[2]
// False Breakout at [0] & Close inside
// Bull Fakey: trap down -> Low[0] < Low[1] but Close[0] > Low[1]. Body confirm: Close > Open.
fakey_bull = ib_cond and low < low[1] and close > low[1] and close > open
// Bear Fakey: trap up -> High[0] > High[1] but Close[0] < High[1]. Body confirm: Close < Open.
fakey_bear = ib_cond and high > high[1] and close < high[1] and close < open

float imp_fakey = 0.0
if fakey_bull
    imp_fakey := 1.0
else if fakey_bear
    imp_fakey := -1.0

// B. Outside Bar
// Enulfing range of previous bar.
outside_bull = high > high[1] and low < low[1] and close > open // directional
outside_bear = high > high[1] and low < low[1] and close < open
float imp_outside = 0.0
if outside_bull
    imp_outside := 1.0
else if outside_bear
    imp_outside := -1.0

// C. BB Touch (Regime Aware)
// RANGE: Upper -> Bear, Lower -> Bull
// TREND: Upper -> Bull, Lower -> Bear
// MIXED: Neutral/Weak (Treat like Range or ignore)
touch_upper = high >= bb_upper
touch_lower = low <= bb_lower
float imp_bb = 0.0

if touch_upper
    if reg_state == "TREND"
        imp_bb := 1.0  // Continuation
    else
        imp_bb := -1.0 // Reversion (Range/Mixed)
if touch_lower
    if reg_state == "TREND"
        imp_bb := -1.0 // Continuation
    else
        imp_bb := 1.0  // Reversion

// D. Divergence (Confirmed pivots)
// We need to store RSI at the time of pivot.
var float last_piv_rsi_high = na
var float last_piv_rsi_low  = na
// When PH confirmed, store RSI at that index
if not na(ph)
    last_piv_rsi_high := rsi_val[piv_r_len]
if not na(pl)
    last_piv_rsi_low  := rsi_val[piv_r_len]

// Check Div on Pivot Confirmation
float imp_div = 0.0
// Bull Div: Price Low < Last Pivot Low, but RSI Low > Last Pivot RSI Low
// Trigger ONLY on the bar the pivot confirms (not na(pl))
// Note: We need the PREVIOUS pivot to compare against.
// Standard logic: Current Pivot vs Previous Pivot.
// Implementing a simple queue for last 2 pivots would be best, but trying to keep minimal.
// Let's rely on looking back.
// Since this is a verifier, we compare:
//  Current confirmed pivot (pl) vs the one BEFORE it.
//  We need variables to store the *previous* pivot data.
var float prev_swing_low_price = na
var float prev_swing_low_rsi   = na
var float prev_swing_high_price = na
var float prev_swing_high_rsi   = na

if not na(pl)
    // Check Bull Div
    // Current PL is 'pl', RSI at that PL is 'rsi_val[piv_r_len]'
    curr_rsi_l = rsi_val[piv_r_len]
    if not na(prev_swing_low_price)
        if pl < prev_swing_low_price and curr_rsi_l > prev_swing_low_rsi
            imp_div := 1.0
    // Update Prev
    prev_swing_low_price := pl
    prev_swing_low_rsi   := curr_rsi_l

if not na(ph)
    // Check Bear Div
    curr_rsi_h = rsi_val[piv_r_len]
    if not na(prev_swing_high_price)
        if ph > prev_swing_high_price and curr_rsi_h < prev_swing_high_rsi
            imp_div := -1.0
    // Update Prev
    prev_swing_high_price := ph
    prev_swing_high_rsi   := curr_rsi_h


// 6.2 Trace Engine (Decay & Cooldown)
// Constants
decay_f = 0.65, cap_f = 1.0
decay_o = 0.65, cap_o = 1.0, cd_o = 1
decay_bb = 0.75, cap_bb = 2.0, cd_bb = 3
decay_div = 0.88, cap_div = 2.5, cd_div = 5

// State Vars
var float tr_f = 0.0
var float tr_o = 0.0
var float tr_bb = 0.0
var float tr_div = 0.0

var int last_idx_o   = 0
var int last_idx_bb  = 0
var int last_idx_div = 0

if update_allowed
    // F (No Cooldown mentioned, but decay)
    tr_f := f_clamp(tr_f * decay_f + imp_fakey, -cap_f, cap_f)

    // O (Cooldown 1)
    if imp_outside != 0 and (bar_index - last_idx_o) > cd_o
        tr_o := f_clamp(tr_o * decay_o + imp_outside, -cap_o, cap_o)
        last_idx_o := bar_index
    else
        tr_o := f_clamp(tr_o * decay_o, -cap_o, cap_o) // Decay only

    // BB (Cooldown 3)
    if imp_bb != 0 and (bar_index - last_idx_bb) > cd_bb
        tr_bb := f_clamp(tr_bb * decay_bb + imp_bb, -cap_bb, cap_bb)
        last_idx_bb := bar_index
    else
        tr_bb := f_clamp(tr_bb * decay_bb, -cap_bb, cap_bb)

    // DIV (Cooldown 5)
    if imp_div != 0 and (bar_index - last_idx_div) > cd_div
        tr_div := f_clamp(tr_div * decay_div + imp_div, -cap_div, cap_div)
        last_idx_div := bar_index
    else
        tr_div := f_clamp(tr_div * decay_div, -cap_div, cap_div)

// 6.3 Trigger Score & Quality
trigger_signed = (tr_f/cap_f * 0.25) + (tr_o/cap_o * 0.25) + (tr_bb/cap_bb * 0.25) + (tr_div/cap_div * 0.25)
// Note: User said "weighted_avg", but didn't specify weights for trigger, assuming equal or standard.
// "weighted_avg( (trF/capF), ... )" -> Usually implies equal weight if not specified.
// Let's stick to equal 0.25 for simplicity unless strictly specified otherwise.
// Re-reading spec: "trigger_signed = weighted_avg( ... )". No weights listed. Equal is safe.

trigger_mag = math.abs(trigger_signed)

aligned = f_sign0(trigger_signed) == f_sign0(bias_signed_raw)
misaligned = f_sign0(trigger_signed) != f_sign0(bias_signed_raw)

quality_boost = 0.10 + 0.05 * trendiness
quality = 1.0
if aligned
    quality := quality + (quality_boost * trigger_mag)
if misaligned
    quality := quality - (quality_boost * trigger_mag)

quality := f_clamp(quality, 0.85, 1.15)


// -----------------------------------------------------------------------------
// 7. CONF SCORE ENGINE
// -----------------------------------------------------------------------------
conf_signed = f_clamp(bias_signed * quality, -1, 1)

// Map to 0..100
conf_raw = 50 + 50 * conf_signed
conf_score_smooth = ta.ema(conf_raw, 7) // EMA 7 per spec

// 7.1 Bias BG State Logic
widen = math.round(6 * (1 - trendiness))
bull_on  = 60 + widen
bull_off = 55 + widen
bear_on  = 40 - widen
bear_off = 45 - widen

base_bars = timeframe.isintraday ? 2 : 3
confirm_bars = f_clamp(base_bars + (trendiness < 0.35 ? 1 : 0), 1, 4)

var int bias_state = 0
var int bull_cnt = 0
var int bear_cnt = 0

// Range Kill-Switch
if update_allowed
    if TS < 45
        bias_state := 0
        bull_cnt   := 0
        bear_cnt   := 0
    else
        // Counters
        if conf_score_smooth > bull_on
            bull_cnt += 1
        else
            bull_cnt := 0

        if conf_score_smooth < bear_on
            bear_cnt += 1
        else
            bear_cnt := 0

        // State Transitions
        if bias_state != 1 and bull_cnt >= confirm_bars
            bias_state := 1
        if bias_state != -1 and bear_cnt >= confirm_bars
            bias_state := -1

        // Exits (Hysteresis)
        if bias_state == 1 and conf_score_smooth < bull_off
            bias_state := 0
        if bias_state == -1 and conf_score_smooth > bear_off
            bias_state := 0

// -----------------------------------------------------------------------------
// 8. VISUALIZATION
// -----------------------------------------------------------------------------
// 8.1 Background Blocks
intensity = f_clamp(TS / 100.0, 0, 1)
alpha_val = 90 - math.round(60 * intensity) // Stronger trend = less transparent

bg_col = color.new(color.gray, 100)
if show_bg
    if bias_state == 1
        bg_col := color.new(color.green, alpha_val)
    else if bias_state == -1
        bg_col := color.new(color.red, alpha_val)

bgcolor(bg_col, title="Regime Background")

// 8.2 Info Panel
// Table logic
var table panel = table.new(position.bottom_right, 2, 2, bgcolor=color.new(color.black, 50), border_color=color.gray, border_width=1)

if show_panel and barstate.islast
    // Row 1: CONF
    table.cell(panel, 0, 0, "CONF", text_color=color.white, text_size=size.small)
    conf_col = conf_score_smooth > 55 ? color.green : conf_score_smooth < 45 ? color.red : color.gray
    table.cell(panel, 1, 0, str.tostring(math.round(conf_score_smooth)), text_color=conf_col, text_size=size.small)

    // Row 2: REG
    table.cell(panel, 0, 1, "REG", text_color=color.white, text_size=size.small)
    reg_col = reg_state == "TREND" ? color.orange : color.silver
    table.cell(panel, 1, 1, reg_state, text_color=reg_col, text_size=size.small)

// Debug Plots (Hidden by default, useful for dev)
plot(debug ? TS : na, "Trend Strength", color=color.yellow, display=display.none)
plot(debug ? bias_signed : na, "Bias Signed", color=color.blue, display=display.none)
plot(debug ? conf_score_smooth : na, "CONF Score", color=color.purple, display=display.none)

// -----------------------------------------------------------------------------
// 9. ALERTS
// -----------------------------------------------------------------------------
// Only trigger on closed bar confirmed states if mode is Closed Bar?
// Spec says: "Alerts nur Closed-Bar sicher (wenn calc_mode Closed Bar)"
// But usually alerts should fire based on the calculated values.
// We will use the 'conf_score_smooth' which respects the gating.
// If calc_mode is Closed Bar, 'conf_score_smooth' updates only on close, so crossover happens once per bar close.

bull_entry = ta.crossover(conf_score_smooth, 70) and TS >= 55
bear_entry = ta.crossunder(conf_score_smooth, 30) and TS >= 55

reg_to_trend = reg_state == "TREND" and reg_state[1] != "TREND"
reg_to_range = reg_state == "RANGE" and reg_state[1] != "RANGE"

alertcondition(bull_entry, "Bull Entry Zone", "CONF entered Bull Zone (70+) with Trend")
alertcondition(bear_entry, "Bear Entry Zone", "CONF entered Bear Zone (30-) with Trend")
alertcondition(reg_to_trend, "REG Trend", "Regime changed to TREND")
alertcondition(reg_to_range, "REG Range", "Regime changed to RANGE")

// End of Script
